\documentclass{juliacon}
% JuliaCon proceedings template
\setcounter{page}{1}
\usepackage{amsmath,booktabs,mathtools,amssymb}
\usepackage{tikz}
\usetikzlibrary{arrows.meta}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\usepackage{balance}
\pgfplotsset{compat=1.18}

\usepackage{siunitx}

\newcommand{\term}[1]{\emph{#1}}
\newcommand{\e}{\ensuremath{\mathrm{e}}}
\newcommand{\im}{\ensuremath{\mathrm{i}}}
\newcommand{\LieGroupsVersion}{0.1.8}
%
% Define muted colours.
\definecolor{TolMutedBlue}{HTML}{332288}
\definecolor{TolMutedCyan}{HTML}{88CCEE}
\definecolor{TolMutedTeal}{HTML}{44AA99}
\definecolor{TolMutedGreen}{HTML}{117733}
\definecolor{TolMutedOlive}{HTML}{999933}
\definecolor{TolMutedSand}{HTML}{DDCC77}
\definecolor{TolMutedRose}{HTML}{CC6677}
\definecolor{TolMutedWine}{HTML}{882255}
\definecolor{TolMutedPurple}{HTML}{AA4499}
%
\hypersetup{colorlinks=true}
%
\begin{document}

\input{header}
% TODO : How to specify an email-address?
\maketitle

\begin{abstract}
    \href{https://juliamanifolds.github.io/LieGroups.jl/stable/}{\texttt{LieGroups.jl}} is a
    Julia package that provides an interface to define Lie groups as well as the corresponding Lie algebra and Lie group actions. The package also offers a well-documented, performant, and well-tested library of such objects, with a focus on numerical computations in engineering.

    This paper presents the main features of the interfaces and how that is integrated within
    the \verb|JuliaManifolds| ecosystem. We further present an overview on existing Lie groups
    implemented in \verb|LieGroups.jl| as well as how to get started to use the package in practice.
\end{abstract}
%
\section{Introduction}%
\label{sec:Introduction}
%
In many situations, one encounters data that does not reside in a vector space.
We can hence not use standard linear algebra tools to work with such data.
For example in robotics, the configuration space of a rigid body in three-dimensional
space is given by the special Euclidean group \(\mathrm{SE}(3)\),
consisting of all translations and rotations.
A subset of these is the space of rotations, given by the special orthogonal group \(\mathrm{SO}(3)\),
or more generally \(\mathrm{SO}(n)\) in \(n\)-dimensional space.

These are examples of Lie groups, formally defined as a smooth manifold equipped with a group structure.
They have applications in physics, robotics, stochastic processes, information geometry, and many other areas see~\cite{Chirikjian:2009,Chirikjian:2012},
but are also interesting from their mathematical viewpoint~\cite{HilgertNeeb:2012}
and their numerical aspects, for example when solving differential equations on Lie groups~\cite{IserlesMunthe-KaasNoersettZanna:2000, Munthe-Kaas:1998}.

The package~\href{https://juliamanifolds.github.io/LieGroups.jl/stable/}{\texttt{LieGroups.jl}}\footnote{%
Available at~\href{https://juliamanifolds.github.io/LieGroups.jl/stable/}{juliamanifolds.github.io/LieGroups.jl/stable/},
see also the zenodo archive~\cite{LieGroups.jl}.%
}
provides an easy access to both defining and using Lie groups within
the Julia programming language~\cite{bezanson2017julia} by defining an interface of Lie groups, as well as implementing a library of Lie groups, that can directly be used.

This paper provides an overview of the main features of \verb|LieGroups.jl|, whose logo is shown on the right, as of version \LieGroupsVersion{}.
%
After introducing some mathematical background in Section~\ref{sec:Notation},
we present the interface in Section~\ref{sec:Interface} for the Lie group, the Lie algebra, and group actions.
Section~\ref{sec:LieGroups} provides an overview of all currently implemented Lie groups.
Finally, in Section~\ref{sec:Example}, we demonstrate how to get started and use \verb|LieGroups.jl|.

\section{Mathematical Background}%
\label{sec:Notation}

\begin{figure}[tbp]
    \centering
    \includegraphics[width=0.15\textwidth]{logo.png}
    \vspace{.5\baselineskip}
    \caption*{Logo of \texttt{LieGroups.jl}.}%
    \label{fig:liegroups_logo}
\end{figure}

The following notation and definitions follow the text book~\cite{HilgertNeeb:2012},
for more details on Riemannian manifolds, see also~\cite{DoCarmo:1992}.

\subsection{Lie groups}
We denote a Lie group by \(\mathcal{G} = (\mathcal{M}, \cdot)\) where \(\mathcal{M}\) is a smooth manifold and \(\cdot\) is the group operation.
A smooth manifold \(\mathcal{M}\) is a topological space that is locally homeomorphic to an Euclidean space \(\mathbb{R}^n\) for some \(n \in \mathbb{N}\), but globally may have a different topology.
We call \(n\) the dimension of the manifold \(\mathcal{M}\), denoted by \(\dim(\mathcal{M}) = n\).
As an example, take the \(2\)-dimensional sphere
\begin{equation*}
\mathbb{S}^2 = \bigl\{ p \in \mathbb{R}^3 \bigm| \lVert p\rVert = 1\bigr\},
\end{equation*}
% MB: maybe it would be better to replace it with an example that can have a group structure? For example the 3-dimensional sphere?

which locally looks like \(\mathbb{R}^2\), think of charts in an atlas, but globally it is not.
Finally we denote the tangent space at a point \(p \in \mathcal{M}\) by \(T_p\mathcal{M}\). This can be thought of as all “velocities” (direction and speed) in which a curve can “pass through” a point. Formally it is set the equivalence classes of derivatives of smooth curves. Each tangent space $T_p\mathcal M$ is a $n$-dimensional vector space and we call the disjoint union of all tangent spaces
\begin{equation*}
    T\mathcal M = \dot\bigcup_{p \in \mathcal M} T_p\mathcal M
\end{equation*}
the \term{tangent bundle} of $\mathcal M$.
\\
A group operation \(\cdot\colon\mathcal{G} \times \mathcal{G} \to \mathcal{G}\) is a function that satisfies the group axioms: associativity, existence of an identity element \(e \in \mathcal{G}\), and existence of inverses \(g^{-1} \in \mathcal{G}\) for all \(g \in \mathcal{G}\). Furthermore the group operation \(\cdot\) (on \( \mathcal{G}\times\mathcal{G} \)) and the inversion map \(\iota\colon\mathcal{G} \to \mathcal{G}, g \mapsto g^{-1}\) have to be smooth maps.
As an example, consider the special orthogonal group \(\mathrm{SO}(n)\), consisting of all \(n \times n\) orthogonal matrices, with determinant \(1\), that is, for \(p\in \mathrm{SO}(n)\), we have \(p^{\mathrm{T}} p = I\) and \(\det(p) = 1\) together with the group operation \(\cdot\) given by matrix multiplication.
For $n=2$ these are rotations in the plane, hence each operation can be identified with an angle $\alpha \in [-\pi, \pi)$\footnote{Note that the identification is not continuous.}, or, continuously, with the circle. % chktex 9ok
The identity element is given by the identity matrix \(I\) (or the angle $\alpha=0$) and the inverse of a rotation matrix is given by its transpose $p^{\mathrm{T}}$ (or an angle $-\alpha$ when $\alpha \neq -\pi$ and $-\pi$ otherwise). %

\subsection{The Lie algebra} The tangent space at the identity element \(e \in \mathcal{G}\), denoted by \(\mathfrak{g} = T_e\mathcal{G}\), plays a special role and is called the \term{Lie algebra} $\frak g$ of the Lie group \(\mathcal{G}\).
The reason is that to represent arbitrary tangent vectors $X \in T_g\mathcal{G}$ at a point $g \in \mathcal{G}$ we can use the group operation: we denote by $\lambda_g(h) = g \cdot h$ the left multiplication with $g, h \in \mathcal{G}$.
For a map \(f\colon \mathcal G \to \mathcal H\) between two Lie groups, its \term{differential} (or push forward) at a point \(g \in \mathcal G\) is a linear map \(Df(g)\colon T_g\mathcal G \to T_{f(g)}\mathcal H\) between the corresponding tangent spaces.
Using the differential $D\lambda_g(h)\colon T_h\mathcal G \to T_{g\cdot h}\mathcal G$, we can generate a so-called \term{left-invariant vector field} defined by $\mathcal X(g) \coloneqq D\lambda_g(e)[X]$ which is uniquely determined by the choice of $X \in \mathfrak{g}$%
\footnote{Analogously, one can use the right multiplication $\rho_g(h) = h \cdot g$ and its differential $D\rho_g(e)$ to define right-invariant vector fields. \texttt{LieGroups.jl} uses left-invariant vector fields as default.}%
.
Hence we can identify tangent vectors $\mathcal X(g) \in T_g\mathcal G$ at arbitrary points $g \in \mathcal G$ with $X$ from the Lie algebra $\mathfrak{g}$.
\\
As a first example, consider $\mathcal G = (\mathbb R^n, +)$, where the tangent space at any point $g$ is again $\mathbb R^n$, especially at the identity $e=0$. We further have $\lambda_g(h) = g + h$ and hence $D\lambda_g(h)[X] = X$ for all $g, h, X \in \mathbb R^n$.
Here, a tangent vector $X$ induces the constant vector field $\mathcal X(g) = X$ for all $g \in \mathbb R^n$.\\
As a second example, consider again the special orthogonal group $\mathrm{SO}(n)$.
The tangent space at the identity element $e = I$ is given by the Lie algebra $\mathfrak{so}(n) = T_e\mathrm{SO}(n) = \{ X \in \mathbb{R}^{n \times n} \mid X = -X^{\mathrm{T}} \}$ that consists of all skew-symmetric $n \times n$ matrices.
For $g, h \in \mathrm{SO}(n)$ and $X \in \mathfrak{so}(n)$ we have $\lambda_g(h) = g \cdot h$ and hence $D\lambda_g(h)[X] = g \cdot X$. Here, the tangent vector $X \in \mathfrak{so}(n)$ induces the left-invariant vector field $\mathcal X(g) = g \cdot X \in T_g\mathrm{SO}(n)$, $g \in \mathrm{SO}(n)$.
In other words, this formulation allows to represent tangent vectors $Y\in T_g\mathrm{SO}(n)$ also using $X = g^{-1}Y \in \mathfrak{g}$.

An important tool to “move around” on the Lie group is the exponential.
The (Lie group) exponential (function) \(\exp\colon \mathfrak{g} \to \mathcal{G}\) maps elements from the Lie algebra to the Lie group, and is formally defined~\cite[Def.~9.2.2]{HilgertNeeb:2012} by evaluating the unique curve \(\gamma\colon \mathbb{R} \to \mathcal{G}\) that fulfils the differential equation
\begin{equation*}
\gamma'(t) = D\lambda_{\gamma(t)}(e)[X]
\quad\text{ with }\quad\gamma(0) = e \text{ and }\gamma'(0) = X
\end{equation*}
at time $t=1$, that is \(\exp(X) = \gamma(1)\).
This can be interpreted as starting at the identity element \(e \in \mathcal{G}\) and following the curve whose velocity at each point is given by the left-invariant vector field induced by \(X \in \mathfrak{g}\) for one time unit.

For \((\mathbb{R}^n, +)\) the exponential is given by \(\exp(X) = X\), $X\in \mathbb R^n$ and for \(\mathrm{SO}(n)\) it is given by the matrix exponential \(\exp(X) = \e^{X}\) for all \(X \in \mathfrak{so}(n)\).
Additionally for the unit circle in the complex plane, using the group operation of multiplication, the exponential function is given by the complex exponential \(\exp(X) = \e^{\im X}\) for all \(X \in \mathbb{R}\).

From the interpretation of the exponential function to follow a curve starting at the identity, we can define the (Lie group) \term{exponential map} to “start from an arbitrary point” \(g \in \mathcal{G}\) by \(\exp_g\colon \mathfrak{g} \to \mathcal{G}\), \(\exp_g(X) \coloneqq g \cdot \exp(X)\) for all \(X \in \mathfrak{g}\).

Concerning a metric on the tangent spaces, smooth manifolds are turned into Riemannian manifolds when they are equipped with a Riemannian metric \(\langle \cdot, \cdot \rangle_p\colon T_p\mathcal{M} \times T_p\mathcal{M} \to \mathbb{R}\) for each point \(p \in \mathcal{M}\) that smoothly varies with \(p\).
For Lie groups, we can use a single inner product \(\langle \cdot, \cdot \rangle\) on the Lie algebra \(\mathfrak{g}\) and use the change in representation as mentioned above to define
\begin{equation*}
\langle X, Y \rangle_g = \langle D\lambda_{g^{-1}}(g)[X], D\lambda_{g^{-1}}(g)[Y] \rangle_e
\end{equation*}
for all \(X, Y \in T_g\mathcal{G}\) and \(g \in \mathcal{G}\). Representing tangent vectors at arbitrary points \(g \in \mathcal{G}\) using the Lie algebra \(\mathfrak{g}\) yields here, that we can use the single inner product directly to evaluate this Riemannian metric. Hence representing tangent vectors using the Lie algebra is the default in the following.
\\
For the two examples above we obtain the Euclidean inner product \(\langle X, Y \rangle = X^{\mathrm{T}} Y\) for \(X, Y \in \mathbb{R}^n\) for \((\mathbb{R}^n, +)\) and the Frobenius inner product \(\langle X, Y \rangle = \mathrm{trace}(X^{\mathrm{T}} Y)\), \(X, Y \in \mathfrak{so}(n)\) can be used for \(\mathrm{SO}(n)\).

Note that a Riemannian metric can also be used to define an exponential map using the Levi-Civita affine connection.
This exponential map often differs from the Lie group exponential, in particular many Lie groups, such as the special Euclidean group in two or more dimensions, can not have a metric compatible with the Lie group exponential.

\subsection{Group Actions}\label{subsec:GroupActions}
A \term{group action} of a Lie group \(\mathcal{G}\) on a smooth manifold \(\mathcal{M}\) is a smooth map \(\sigma\colon \mathcal{G} \times \mathcal{M} \to \mathcal{M}\) such that for all \(g, h \in \mathcal{G}\) and \(p \in \mathcal{M}\) it holds that \(\sigma(e, p) = p\) and \(\sigma(g, \sigma(h, p)) = \sigma(g \cdot h, p)\).\footnote{This is the convention for left actions. Alternatively, right actions fulfil \(\sigma(g, \sigma(h, p)) = \sigma(h \cdot g, p)\).}
Informally a group action describes how elements of the Lie group \(\mathcal{G}\) “act on” points on the manifold \(\mathcal{M}\). As an example, think of the special orthogonal group \(\mathrm{SO}(3)\) acting on points on Euclidean space $\mathbb{R}^3$ “moving” them somewhere by rotating them around the origin. We obtain the group action \(\sigma\colon \mathrm{SO}(3) \times \mathbb{R}^3 \to \mathbb{R}^3\), \(\sigma(R, x) \coloneqq Rx\).

The same action can also be applied to points from the sphere \(\mathbb{S}^2\), resulting in a similar group action \(\sigma\colon \mathrm{SO}(3) \times \mathbb{S}^2 \to \mathbb{S}^2\), \(\sigma(R, p) \coloneqq Rp\).

\section{The interface}\label{sec:Interface}

Since a Lie group \(\mathcal{G}\) consists of two main components, the smooth manifold \(\mathcal{M}\) and the group operation \(\cdot\), we can reuse existing functionality from the existing interface for manifolds provided by \verb|ManifoldsBase.jl|, and later concrete manifolds provided by \verb|Manifolds.jl|~\cite{AxenBaranBergmannRzecki:2023}.
This is done in a transparent way, i.e.\ the \verb|AbstractLieGroup| itself is a subtype of \verb|AbstractManifold| from \verb|ManifoldsBase.jl| and can hence also be used in all existing places, as for example optimization on manifolds provided by \verb|Manopt.jl|~\cite{Bergmann:2022}.
In notation, we use typewriter font to denote functions in the interface, but we keep the same letters of notation as before, i.e.\ $\mathcal G$ for a Lie group is \verb|G| in code, a point $g \in \mathcal G$ is \verb|g| in code, and so on, just that for the Lie algebra we use $\mathfrak g$ in both text and code.

The interface follows the philosophy of \verb|ManifoldsBase.jl|, that the Lie group or algebra is the first argument and even a mutated argument comes second.
Similarly, if a function computes something like a new point on the Lie group or a tangent vector, there also exists a variant, that computes this in-place.
For example \verb|identity_element(G)| returns the identity element $e$ of a Lie group $G$ in a default representation, \verb|identity_element!(G, e)| writes the result into the pre-allocated variable \verb|e|, which can also be used with other representation types.
To generate a point in a specific representation by objects of type \verb|T|, one can use \verb|identity_element(G, T)|.
For example, a points on the special Euclidean group $\mathrm{SE}(n)$ can be represented either as a $(n+1) \times (n+1)$ matrix or a \verb|ArrayPartition| with rotation and translation stored separately.

\subsection{Lie groups}

The main type for Lie Groups is the \verb|LieGroup{|$\mathbb {F}$\verb|, O, M} <: AbstractLieGroup{|$\mathbb {F}$\verb|, O, M}|, which contains a manifold \verb|M <: AbstractManifold{|$\mathbb F$\verb|}| as well as the group operation \verb| O <: AbstractGroupOperation|, where $\mathbb {F}$ is the set of scalars used in the representation of the manifold, usually \(\mathbb {F} = \mathbb{R}\) and in some cases \(\mathbb {F}\) is the field of complex numbers \(\mathbb{C}\) or the ring of quaternions \(\mathbb H\).

In general, when a function within the interfaces of \verb|JuliaManifolds| returns a point, a tangent vector or any other mutable object, there always exist two variants of the function, one that allocates a new object and returns it, and one that takes an additional argument to write the result into. For example for a function \verb|f(G, g)| that returns a point on the Lie group \verb|G|, there also exists a variant \verb|f!(G, h, g)| that computes the result in-place of \verb|h|, possibly using the memory also for interims results. All methods are written such that the result is correct even if arguments \verb|h| and \verb|g| use the same memory. By default the allocating variant is implemented by allocating memory accordingly and calling the in-place variant. This default can be overridden, for example for performance reasons.

\subsubsection*{Topological functions}
Points and tangent vectors can be represented by the same Julia objects, although they are distinct from a topological viewpoint.%
\footnote{\texttt{LieGroups.jl} introduces an abstract type \texttt{AbstractLieGroupPoint <: AbstractManifoldPoint}, that is used to represent points on the Lie group.
This abstract supertype is not necessary, points can be represented by arrays or other types as well.}
Separate types are necessary when one Lie group has \emph{different representations} of points, that have to be distinguished. When there are different representations, it is recommended to introduce a point type for each representation and make the default one fall back to (just) using arrays.
Several functions in the interface return points or tangent vectors, where the type might not be known from the input argument. For such a function, for example again a function \verb|f(G)| a positional argument \verb|T| can be used to specify the desired return type, i.e.\ \verb|f(G, T)| returns a point or tangent vector of type \verb|T|.
The in-place variant does not require this, since in its signature of the form \verb|f!(G, g::T)| the type \verb|T| is known from the argument \verb|g|.

Alternatively to points, the same group structure can be defined over different topological manifolds. This is for example the case for the circle group \(\mathbb{S}^1\), which can be represented as angles, points on the unit circle in \(\mathbb{R}^2\) or as complex numbers with unit norm, all three of which are different manifolds to be used internally. To access the underlying manifold, the function \verb|base_manifold(G)| is provided.



The following functions are available and pass directly to the underlying manifold interface from \verb|ManifoldsBase.jl|:
\verb|is_approx(G, g, h)| to check for (approximate) equality of two points,
\verb|is_point(G, g; error=:none)| to check if a point is a valid point on the manifold, where the keyword can be used to throw an \verb|:error|, a \verb|:warn| or an \verb|:info|.
Similarly
\verb|manifold_dimension(G)| to get the dimension of the manifold,
\verb|project(G, q)|, to project a point onto the manifold, as well as %
%\footnote{in-place variant \texttt{project!(G, p, q)}.} 
\verb|rand(G)| and \verb|rand(rng, G)| %
%\footnote{in-place variant \texttt{rand!(G, p)} and \texttt{rand!(rng, G, p)}, respectively.}
to sample a random point from the manifold using a random number generator \verb|rng| also pass directly on to the manifold.
To access the underlying manifold of the Lie group one can use \verb|base_manifold(G)|.


\subsubsection*{Group operation related functions}

\begin{table}
    \centering
    \caption{Group operations available in \texttt{LieGroups.jl}.}
    \begin{tabular}{@{}ll@{}}
        \toprule
        \textbf{Group operation} $\cdot$ & comment/code\\
        \midrule
        \verb|AdditionGroupOperation| & falls back to \verb|+|\\
        \verb|AbelianMultiplicationGroupOperation| & falls back to \verb|*|\\
        \verb|MatrixMultiplicationGroupOperation| & falls back to \verb|*|\\
        \verb|PowerGroupOperation{Op}| & \verb|PowerLieGroup|\\
        \verb|ProductGroupOperation{Ops}| & product Lie groups\\
        \verb|SemidirectProductGroupOperation| & semidirect products\\
        \bottomrule
    \end{tabular}%
    \label{tab:GroupOperations}
\end{table}

For the group operation \(\cdot\) of a Lie group \(\mathcal{G}\), the abstract supertype \verb|AbstractGroupOperation| is mandatory. There are two main group operation types provided in \verb|LieGroups.jl|. On the one hand operations that fall back to using $\cdot = +$ or $\cdot = *$, where the latter has two variants, the one where it is Abelian (like for numbers) and where it is not (like for matrices).
On the other hand, specific meta groups like the (direct) product of two or more groups, the case where the product is taken for just one group, i.e.\ the power group, or semidirect products. The available group operation types are summarized in Table~\ref{tab:GroupOperations}. More on these meta groups is explained in Subsection~\ref{subsec:MetaLieGroups}.

For all these group operations, the following functions have default implementations. They might not be the most performant ones for every case, but provide working implementations out-of-the-box.
It is always possible to override these by defining a new group operation type and implementing the following functions for a \verb|LieGroup| with that new group operation type.

The identity element can be represented as a value of a special type, \verb|e = Identity(G)| or \verb|Identity(op)| where \verb|op| is the group operation of \verb|G|. This allows for dispatching on the type when defining functions and avoiding unnecessary allocations. If the actual value is needed, one can call
\verb|identity_element(G)| or \verb|identity_element(G, typeof(g))|, where \verb|g| is an element of the group. The first variant will always generate a point in the default representation of the group, while the latter will generate a point in the same representation as \verb|g|%
%\footnote{The in-place variant \texttt{identity\_element!(G, e::T)} infers the representation from the type \texttt{T} of \texttt{e}.}
.

The two central functions are \verb|compose(G, g, h)|
%\footnote{in-place variant \texttt{compose!(G, k, g, h)}.}
to compute the group operation \(g \cdot h\) for two points \(g, h \in \mathcal{G}\) and the inverse \verb|inv(G, g)|
%\footnote{in-place variant \texttt{inv!(G, h, g)}.}
which computes \(g^{-1}\) for a point \(g \in \mathcal{G}\).
Another function is $c_g(h) = g \cdot h \cdot g^{-1}$ called \term{conjugation}, which is available as \verb|conjugate(G, g, h)|%
%\footnote{in-place variant \texttt{conjugate!(G, k, g, h)}.}
.

For these three functions, also the differentials are available: adding a \verb|diff_| prefix to the function name and a final argument for the Lie algebra tangent vector, for compose additionally the argument with which to  differentiate to, i.e.\ \verb|diff_left_compose(G, g, h, X)| and \verb|diff_right_compose(G, g, h, X)|, respectively%
%\footnote{in-place variants have a second argument \texttt{Y} to compute the result in.}
.

Finally, there is a specific function for the differential of the conjugate at the identity $h=e$, called \verb|adjoint(G, g, X)|,
%\footnote{in-place variant \texttt{adjoint!(G, Y, g, X)}.}
as well as the combinations \verb|inv_left_compose(G, g, h)|
%\footnote{in-place variant \texttt{inv\_left\_compose!(G, k, g, h)}}
for computing $g^{-1}\cdot h$ and \verb|inv_right_compose(G, g, h)|
%\footnote{in-place variant \texttt{inv\_right\_compose!(G, k, g, h)}
for computing $g \cdot h^{-1}$. All three fall back to the previously defined functions, but provide an interface to possibly implement more efficient variants in case such exist.

\subsubsection*{Exponential and logarithm}

In \verb|LieGroups.jl|, the group exponential function is given by \verb|exp(G, X)|%
%\footnote{in-place variant \texttt{exp!(G, g, X)}.}
.
If we want to “start walking” from another point, we can “move” (or interpret $X$) as being from the tangent space at some point $g$ and obtain by the chain rule the exponential map $\exp_g\colon\mathfrak g\to\mathcal G$ defined by $\exp_g(X)\coloneqq g \cdot \exp(X)$.
In \verb|LieGroups.jl|, the exponential map is implemented as \verb|exp(G, g, X)|%
%\footnote{in-place variant \texttt{exp!(G, h, g, X)}.}
.
Note that on the underlying manifold, there is a further exponential map, the Riemannian exponential map.
This usually differs from the Lie group exponential map.
The Riemannian exponential map \verb|exp(M, p, X)|
%\footnote{with the same in-place signature as before \texttt{exp!(M, q, p, X)}.}
can be distinguished in that the first argument is a manifold, and the tangent vector \verb|X| has to be from the tangent space at the point \verb|p| on the manifold.
Here, again, to access the Riemannian exponential, one can use the base manifold of the Lie group, i.e.\ \verb|exp(base_manifold(G), g, X)| and have to make sure that \verb|X| is from the tangent space at \verb|g|.

Locally around the identity element $e\in\mathcal G$, the exponential map is a diffeomorphism, i.e.\ there exists an inverse map on some neighbourhood of $e$. The logarithmic function \(\log\colon \mathcal{G} \to \mathfrak{g}\) and logarithmic map \(\log_g\colon \mathcal{G} \to \mathfrak{g}\)have the function signatures \verb|log(G, g)|%
%\footnote{in-place variant \texttt{log!(G, X, g)}.}
and \verb|log(G, h, g)|%
%\footnote{in-place variant \texttt{log!(G, X, h, g)}.}
, respectively, with the same caveat to the Riemannian logarithmic map as for the exponential.

When the exponential and logarithmic map are not known in closed form, it might be beneficial to use retractions and inverse retractions instead, respectively.
These are first or second order approximations of the exponential and logarithmic map, respectively and their interface is already provided in \verb|ManifoldsBase.jl|\footnote{see \href{https://juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/}{juliamanifolds.github.io/ManifoldsBase.jl/stable/retractions/}.}.
In \verb|LieGroups.jl|, one can either implement new variants based on a subtype of \verb|AbstractRetractionMethod| and \verb|AbstractInverseRetractionMethod|, resp., or use the wrappers \verb|BaseManifoldRetraction| and \verb|BaseManifoldInverseRetraction|, resp., to directly use the retraction and inverse retraction from the underlying manifold.

\subsection{Lie algebras}

Similar to points on the Lie group, when representing elements $X \in \mathfrak g$ from a Lie algebra, we do not type the general functions of the interface.
This allows to use either plain arrays or own structures to represent these in code%
\footnote{The optional abstract supertype \texttt{AbstractLieAlgebraTangentVector}, which is a \texttt{AbstractTangentVector}, is provided to also distinguish different representations here.}%
.
Keep in mind, that the Lie algebra is a vector space, so that addition, subtraction and scalar multiplication, as well as their broadcasted variants, are assumed to be defined in case you use an individual data type.

A major difference to the usual representation of tangent vectors on the underlying manifold is, that here the usual representation is done in the Lie algebra.

A central function on the Lie algebra is the Lie bracket $[\cdot, \cdot]\colon \mathfrak g \times \mathfrak g \to \mathfrak g$, which is available as \verb|lie_bracket(|$\mathfrak g$\verb|, X, Y)|.
% \footnote{in-place variant \texttt{lie\_bracket!($\mathfrak g$, Z, X, Y)}.}
For more details on the Lie bracket see~\cite[Ch.~5]{HilgertNeeb:2012}.

\subsubsection*{Topological basics}
Given a Lie group \verb|G|, we obtain the Lie algebra by calling $\mathfrak g$ \verb|= LieAlgebra(G)|.
To access the Lie group again, use \verb|base_lie_group(|$\mathfrak g$\verb|)|. Similarly \verb|base_manifold(|$\mathfrak g$\verb|)| returns the underlying manifold of the Lie group.\\
As a technical detail, the Lie algebra is modelled as a tangent space\footnote{see the documentation of~\href{https://juliamanifolds.github.io/ManifoldsBase.jl/stable/metamanifolds/\#ManifoldsBase.TangentSpace}{ManifoldsBase.TangentSpace}} using the already mentioned \verb|Identity(G)| as base point.
A zero vector is generated via \verb|zero_vector(|$\mathfrak g$\verb|)| for the default representation and \verb|zero_vector(|$\mathfrak g$\verb|, T)| for a specific representation type \verb|T|%
%\footnote{the in-place variant \texttt{zero\_vector!($\mathfrak g$, X::T)} can infer the type \texttt{T} of \texttt{X} automatically.}
.

The main topological function is to test the validity of a tangent vector \verb|is_vector(|$\mathfrak g$\verb|, X; error=:none)| using the same \verb|error=| keyword as \verb|is_point| on the Lie group.

\subsubsection*{Vector space related functions}
For the following functions related to vector space features, using the Lie algebra $\mathfrak g$ as first argument is equivalent to specifying the Lie Group $G$ and an arbitrary point $g \in \mathcal G$. This yields that the Lie group complies with the general interface for manifolds.

The inner product and norm on the Lie algebra are available as \verb|inner(|$\mathfrak g$\verb|, X, Y)| and \verb|norm(|$\mathfrak g$\verb|, X)|, respectively.
Furthermore, there are two functions to convert between a coordinate-free representation of $X$ as a tangent vector and its representation in coordinates of a basis.

Given a vector $c \in \mathbb R^{\dim(\mathfrak g)}$, we obtain the corresponding tangent vector by calling \verb|get_vector(|$\mathfrak g$\verb|, c, B)| where \verb|B| is a basis of the tangent space, i.e.\ a subtype of \verb|AbstractBasis| and defaults within \verb|LieGroups.jl| to \verb|DefaultLieAlgebraOrthogonalBasis()|.
When a Lie group has different representations of points and tangent vectors, these are distinguished by calling \verb|get_vector(|$\mathfrak g$\verb|, c, B, T)| specifying the tangent vector type%
%\footnote{the in-place variant \texttt{get\_vector!($\mathfrak g$, X::T, c, B)} can infer the type \texttt{T} of \texttt{X} directly.}
.
Given a tangent vector $X \in \mathfrak g$, we obtain its coordinates by calling \verb|get_coordinates(|$\mathfrak g$\verb|, X, B)|%
%\footnote{in-place variant \texttt{get\_coordinates!($\mathfrak g$, c, X, B)}}
, where the basis is again optional.

For the case of the default, the \verb|DefaultLieAlgebraOrthogonalBasis()| the more commonly used names \verb|hat(|$\mathfrak g$\verb|, c)|
%\footnote{in-place variant \texttt{hat!($\mathfrak g$, X::T, c)}}
(again with an optional vector type \verb|T|) and \verb|vee(|$\mathfrak g$\verb|, X)|
%\footnote{in-place variant \texttt{vee!($\mathfrak g$, c, X)}}
are implemented

\subsubsection*{Push forward and pull back of tangent vectors}
To get a tangent vector $X_g \in T_g \mathcal G$ at point $g \in \mathcal G$ from its Lie algebra representation $X \in \mathfrak g$ we have to use the push forward of the left multiplication with $g$, i.e.\ $D\lambda_g(e)[X]$. This is implemented as \verb|push_forward_tangent(G, g, X)|%
%\footnote{in-place variant \texttt{push\_forward\_tangent!(G, Y, g, X)}.}
.
Conversely, to represent a tangent vector $Y \in T_g\mathcal G$ back in the Lie algebra $\mathfrak g$, we have to use the pull back of the left multiplication with $g^{-1}$, i.e.\ $D\lambda_{g^{-1}}(g)[Y]$. This is implemented as \verb|pull_back_tangent(G, g, Y)|%
%\footnote{in-place variant \texttt{pull\_back\_tangent!(G, X, g, Y)}.}
.

\subsubsection*{Jacobians}
On a Euclidean space, the terms differential and Jacobian are often used interchangeably. Within differential geometry, the differential (or push forward) of a smooth map $f\colon \mathcal M \to \mathcal N$ between two manifolds is a map between the corresponding tangent spaces. We denote it by $Df(p)\colon T_p\mathcal M \to T_{f(p)}\mathcal N$, where $p \in \mathcal M$.
The differential is a linear map between the tangent spaces.
However, in the coordinate-free representation of tangent vectors, no matrix representation of this linear map is constructed.
But as soon as we choose bases for the tangent spaces and we represent tangent vectors in coordinates (cf.~\verb|get_coordinates| previously), we can represent the differential as a matrix, called the Jacobian matrix.

Currently for both \verb|exp| as well as \verb|conjugate|, the Jacobian is implemented. Note that for \verb|exp|, the domain is the Lie algebra. Since that is a vector space, its tangent space(s) can be identified with the Lie algebra again. Hence both Jacobians are maps from the Lie algebra to itself. The signatures are
\verb|jacobian_exp(G, p, X, B)|
%\footnote{in-place variant \texttt{jacobian\_exp!($\mathfrak g$, J, p, X, B)}}
and \verb|jacobian_conjugate(G, g, X, B)|%
%\footnote{in-place variant \texttt{jacobian\_conjugate!($\mathfrak g$, J, g, X, B)}}
, where \verb|B| is again the basis to represent the tangent vectors in coordinates and defaults to \verb|DefaultLieAlgebraOrthogonalBasis()|.

\subsection{Group actions}

\begin{table}
    \centering
    \caption{Group actions types available in \texttt{LieGroups.jl}.}
    \begin{tabular}{@{}ll@{}}
        \toprule
        \textbf{Group action type} & comment/code\\
        \midrule
        \verb|AdditionGroupAction| & falls back to \verb|+|\\
        \verb|ColumnwiseGroupAction{A}| & of a group action type \verb|A|\\
        \verb|(Inverse)LeftGroupOperationAction| & requires $\mathcal M = \mathcal G$\\
        \verb|LeftMultiplicationAction| & falls back to \verb|*|\\
        \verb|(Inverse)RightGroupOperationAction| & requires $\mathcal M = \mathcal G$\\
        \verb|RotationAroundAxisAction| & \\
        \verb|RowwiseGroupAction{A}| & of a group action type \verb|A|\\
        \bottomrule
    \end{tabular}%
    \label{tab:GroupActionTypes}
\end{table}

Group actions as defined in Subsection~\ref{subsec:GroupActions} are implemented as a struct \verb|GroupAction{G, M, A} <: AbstractGroupAction| containing the Lie group \verb|G <: AbstractLieGroup|, the manifold \verb|M|, and a group action tpe \verb|A| in order to distinguish possible different ways a group could act on a manifold.
Table~\ref{tab:GroupActionTypes} summarizes the currently available group action types in \verb|LieGroups.jl|.

The main functions then are \verb|apply(a::GroupAction, g, p)|
%\footnote{in-place variant \texttt{apply!(a::GroupAction, q, g, p)}.}
to compute \(\sigma(g, p)\) for a group action \verb|a|, where $g\in \mathcal G$ and $p \in \mathcal M$, as well as its differential \verb|diff_apply(a::GroupAction, g, p, X)|
%\footnote{in-place variant \texttt{diff\_apply!(a::GroupAction, Y, g, p, X)}.}
to compute \(D_{\mathcal M}\sigma(g, p)[X]\) for a tangent vector \(X \in T_p\mathcal M\) with respect to the manifold argument as well as \verb|diff_group_apply(a::GroupAction, g, p, Y)|
%\footnote{in-place variant \texttt{diff\_group\_apply!(a::GroupAction, Z, g, p, Y)}.}
to compute \(D_{\mathcal G}\sigma(g, p)[Y]\) for a Lie algebra element \(Y \in \mathfrak g\).

Due to the property that \(\sigma(g^{-1}, \sigma(g, p)) = p\) for all \(g \in \mathcal{G}\) and \(p \in \mathcal{M}\), there is also an inverse group action available $\sigma^{-1}(g, p) = \sigma(g^{-1}, p)$, which can be obtained by calling \verb|inv(a)|.

Note that while the group action $\sigma(g, \sigma(h, p)) = \sigma(g \cdot h, p)$ “appends” a new action (w.r.t.~$g$) on the left, for the inverse we have
\begin{align*}
        \sigma^{-1}(g, \sigma^{-1}(h, p))
        &= \sigma(g^{-1}\cdot h^{-1}, p)
        = \sigma((h \cdot g)^{-1}, p)
        \\
        &= \sigma^{-1}(h \cdot g, p)
\end{align*}
for all \(g, h \in \mathcal{G}\). This is a so-called right action.
Similarly for a right group action the inverse is a left group action.
This is taken into account when using \verb|apply|.

\section{Implemented Lie groups}\label{sec:LieGroups}

\begin{table}[tbp]
    \centering
    \caption{Implemented Lie groups in \texttt{LieGroups.jl} version~\LieGroupsVersion{}.}
    \begin{tabular}{@{}lll@{}}
        \toprule
        \textbf{Lie Group $\mathcal G$} & \textbf{Symbol} & comment/code\\
        \midrule
        \verb|CircleGroup()| & \(\mathbb{S}^1\) & 3 representations \\
        \verb|GeneralLinearGroup(n, F)| & \(\mathrm{GL}(n, \mathbb{F})\) & $\mathbb{F} \in \{\mathbb{R}, \mathbb{C}\}$\\
        \verb|HeisenbergGroup(n)| & \(\mathrm{H}(n)\)\\
        \verb|OrthogonalGroup(n)| & \(\mathrm{O}(n)\) &\\
        \midrule
        \verb|PowerLieGroup(G, n)| & \(\mathcal G^n\) & \verb|G^n|\\
        \verb|ProductLieGroup(G1, G2,...)| & \(\mathcal G_1 \times \mathcal G_2 \times \ldots\) & \verb|G1| $\times$ \verb|G2| $\times$ \ldots\\
        Semidirect product group & \(\mathcal G_1 \ltimes \mathcal G_2\) & \verb|G1| $\ltimes$ \verb|G2|\\
                                 & \(\mathcal G_1 \rtimes \mathcal G_2\) & \verb|G1| $\rtimes$ \verb|G2|\\
        \midrule
        \verb|SpecialEuclideanGroup(n)| & \(\mathrm{SE}(n)\) & \\
        \verb|SpecialGalileanGroup(n)| & \(\mathrm{SGal}(n)\) &  \\
        \verb|SpecialLinearGroup(n, F)| & \(\mathrm{SL}(n, \mathbb{F})\) & $\mathbb{F} \in \{\mathbb{R}, \mathbb{C}\}$\\
        \verb|SpecialOrthogonalGroup(n)| & \(\mathrm{SO}(n)\) &  \\
        \verb|SpecialUnitaryGroup(n)| & \(\mathrm{SU}(n)\) & \\
        \midrule
        \verb|SymplecticGroup(n)| & \(\mathrm{Sp}(2n)\) & \\
        \verb|TranslationGroup(n; field=|$\mathbb{F}$\verb|)| & \((\mathbb{F}^n, +)\) & $\mathbb{F} \in \{\mathbb{R}, \mathbb{C}, \mathbb{H}\}$\\
        \verb|UnitaryGroup(n, |$\mathbb{F}$\verb|)| & \(\mathrm{U}(n)\) & $\mathbb{F} \in \{\mathbb{C}, \mathbb{H}\}$ \\
        \verb|ValidationLieGroup(G)| & \multicolumn{2}{l}{wraps \texttt{G} for numerical verification}\\
        \bottomrule
    \end{tabular}%
    \label{tab:available_lie_groups}
\end{table}

Table~\ref{tab:available_lie_groups} summarizes the currently implemented Lie groups in \verb|LieGroups.jl| \LieGroupsVersion.

\subsection{Meta Lie groups}\label{subsec:MetaLieGroups}

There are three Lie groups that are built upon other Lie groups. We mention them here briefly and point out specific functions and features that are additionally available for these.

\subsubsection*{Product Lie group}

Given two Lie groups \(\mathcal{G} = (\mathcal M, \ast) \) and \(\mathcal{H} = (\mathcal N, \diamond)\), their (direct) product \(\mathcal{G} \times \mathcal{H}\) is again a Lie group \((\mathcal{M} \times \mathcal{N}, \cdot)\) with group operation defined component-wise, i.e.
\begin{equation*}
    (g_1, h_1) \cdot (g_2, h_2) = (g_1 \ast g_2, h_1 \diamond h_2)
\end{equation*}
for \(g_1, g_2 \in \mathcal{G}\) and \(h_1, h_2 \in \mathcal{H}\).
Since $\times$ is a binary operator in Julia, given two Lie Groups \verb|G,H|, their product Lie group can be constructed via \verb|G|\,$\times$\,\verb|H|.
The same applies for more than two groups, i.e.\ you can construct arbitrary long product Lie groups \verb|G1|\,$\times$\,\verb|G2|\,$\times$\,\verb|G3|\,$\times$\,\ldots.

As for the representation of points and tangent vectors, the default representation requires to load \verb|RecursiveArrayTools.jl|\footnote{see \href{https://docs.sciml.ai/RecursiveArrayTools/stable/}{docs.sciml.ai/RecursiveArrayTools/stable/}}.

The binary operator $\times$ automatically flattens the input, so that the points are represented by non-nested \verb|ArrayPartition| objects.
If you want to construct products of Lie groups where points are represented by nested \verb|ArrayPartition| objects, for example \((\mathcal G_1 \times \mathcal G_2) \times \mathcal G_3\), use \verb|ProductLieGroup(ProductLieGroup(G1, G2), G3)| instead.

\subsubsection*{Power Lie groups}
Mathematically power groups are product Lie groups where all manifolds are the same. Computationally we can sometimes benefit by exploiting this special structure.
Therefore the \verb|PowerManifold(G, n1, n2, ...)| is provided to construct the \(n_1 \times n_2 \times \ldots\)-fold Cartesian product of the Lie group \(\mathcal G\) with itself.
As a shortcut, you can use \verb|G^n| to construct the \(n\)-fold Cartesian product of the Lie group \(\mathcal G\) with itself.

Note that inheriting from the power manifold, there are two different data types to represent data, per default a single large array. Alternatively, one can use the constructor \verb|PowerLieGroup(G, NestedPowerRepresentation(), n)| to use the other representation of points and tangent vectors, namely as a vector of points/tangent vectors.

To abstract the access of elements here, similar to the \verb|PowerManifold| in \verb|ManifoldsBase.jl|, the access functions \verb|g[G, i]| are available.

\subsubsection*{Semidirect product Lie groups}

Given two Lie groups \(\mathcal{G} = (\mathcal M, \ast)\) and \(\mathcal{H} = (\mathcal N, \diamond)\) as well as a group action \(\sigma\colon \mathcal{G} \times \mathcal{H} \to \mathcal{H}\),
the \term{(left) semidirect product Lie Group} $\mathcal{G} \ltimes \mathcal{H} = (\mathcal{M} \times \mathcal{N}, \cdot)$ is defined via the group operation given by
\begin{equation*}
    (g_1, h_1) \cdot (g_2, h_2) = (g_1 \ast g_2, h_1 \diamond \sigma(g_1, h_2))
\end{equation*}
This semidirect product Lie group is constructed calling \verb|LeftSemidirectProductLieGroup(G, H, a)|, where the \verb|GroupAction a| is optional, since one can define a default action by setting \verb|default_left_action(G, H)|.
With this default, also the shortcut \verb|G|\,$\ltimes$\,\verb|H| is available.
%
Similarly, the \term{right semidirect product Lie Group} $\mathcal{H} \rtimes \mathcal{G}$ is defined analogously with the positions of the groups are swapped in the group operation and the default for the group action is given by \verb|default_right_action(G, H)|. This can be constructed via \verb|H|\,$\rtimes$\,\verb|G| then as well.

\subsection{Decorators for Lie groups}

The decorator pattern is used within the \verb|JuliaManifolds| ecosystem to add or modify existing functionality.
For Lie groups there are currently two such decorators available: one for adding a custom metric structure (inner product) to the group and one for numerical validation.

\subsubsection*{Specifying a different inner product}

By implementing \verb|inner(|$\mathfrak g$\verb|, X, Y)| and \verb|norm(|$\mathfrak g$\verb|, X)| for a Lie algebra $\mathfrak g$\verb| = LieAlgebra(G)|,
the Lie group \verb|G| is equipped with a certain inner product on the Lie algebra and hence on all tangent spaces to the Lie group.
This is an implicit choice of a default metric on the Lie group, that is considered the default thereafter.

If more than one metric is used in applications, a second metric can be introduced
by wrapping the Lie group into a \verb|MetricLieGroup|, i.e.\ \verb|G2 = MetricLieGroup(G, m::M)|, where \verb|M| has to be a subtype of
\verb|AbstractMetric| available from \verb|Manifolds.jl|\footnote{where analogously a manifold of type~\texttt{MetricManifold} is defined.}.
All functions unrelated to the metric are forwarded from \verb|G2| to \verb|G|, while all functions
related to the inner product have to be specified for \verb|G2| anew.

\subsubsection*{Adding numerical validation to a Lie group}

The \verb|ValidationLieGroup| is a special Lie group that is intended for numerical verification and debugging of code using Lie groups.

The \verb|ValidationLieGroup| is implemented as a wrapper around any existing Lie group, \verb|G2 = ValidationLieGroup(G)|. It provides additional functionality to check the correctness of computations involving the Lie group. Most prominently,
all input and output of group functions are checked for validity, e.g.\ by calling \verb|is_point| and \verb|is_vector| on all points and tangent vectors, respectively. Similarly, the inner manifold is wrapped into the similar decorator from \verb|ManifoldsBase.jl|, the \verb|ValidationManifold|.
While by default failures in these checks result in errors, this can be changed by setting the \verb|error=| keyword of the \verb|ValidationLieGroup| constructor to either \verb|:warn| or \verb|:info|.

\subsection{Concrete Lie groups}\label{subsec:ConcreteLieGroups}

From the list of available Lie groups in Table~\ref{tab:available_lie_groups}, we want to highlight some specific features of a few of them.

For the \verb|CircleGroup()|, three different representations of points are available: as angles in \([-\pi, \pi)\), as complex numbers with unit norm, and as points on the unit circle in \(\mathbb{R}^2\).
These are constructed by specifying the representation of points, i.e.\ \verb|CircleGroup(|$\mathbb R$\verb|)|, \verb|CircleGroup(|$\mathbb C$\verb|)|, and \verb|CircleGroup(|$\mathbb R^2$\verb|)|, respectively. Note that each of these representations uses a different underlying manifold, namely \verb|Circle(|$\mathbb R$\verb|)|, \verb|Circle(|$\mathbb C$\verb|)|, and \verb|Sphere(1)|, respectively.
This is a case, where it is not only the representation of points and tangent vectors that differ, but indeed even the underlying manifold.

The special Euclidean group \(\mathcal G = \mathrm{SE}(n)\), there are three different representations available:
\\
The first one is the matrix representation, where points are represented as \((n+1) \times (n+1)\) matrices combining rotation and translation, i.e.\ as
\begin{equation*}
    g = \begin{pmatrix} R & t \\
    0 & 1 \end{pmatrix},
\end{equation*}
where \(R \in \mathrm{SO}(n)\) and \(t \in \mathbb{R}^n\).

The second representation is the tuple representation, where points are represented as tuples \(g' = (R, t)\) and the third is the tuple representation with the translation in the first component, i.e.\ \(g'' = (t, R)\). These two are available when \verb|RecursiveArrayTools.jl| is loaded and specifying the \verb|variant=:left| (default) or \verb|variant=:right|, respectively.
The matrix representation works on either \verb|variant|.

For all three representations, one can access the component semantically by writing \verb|g[G, :Rotation]| and \verb|g[G, :Translation]|, which works independent of the representation used.

\section{Examples how to use {\texttt{LieGroups.jl}}}%
\label{sec:Example}

In this section, we provide examples of how to use the {\texttt{LieGroups.jl}} package in Julia.

\subsection{A Beziér curve on a Lie group}

\begin{lstlisting}[
    float=tbp,
    language = Julia,
    numbers=left,
    label={lst:deCasteljauLieGroup},
    caption={de-Casteljau algorithm on a Lie group.}
]
using LieGroups, ManifoldsBase, RecursiveArrayTools
using CairoMakie
"""
    deCasteljauLieGroup(G, cp, t)

Evaluate the Beziér curve at parameter `t` given
a vector of control points `cp` on the Lie group `G`.
"""
function deCasteljauLieGroup(
        G::AbstractLieGroup, cp::Vector{P}, t::Real
    ) where {P}
    n = length(cp)
    points = [copy(G, g) for g in cp]
    for r in 1:n-1
        for i in 1:n-r
            X = log(G, points[i], points[i+1])
            exp!(G, points[i], points[i], t * X)
        end
    end
    return points[1]
end
\end{lstlisting}

In the first example we illustrate how to construct and plot a Beziér curve on a Lie group, here the special Euclidean group \(\mathrm{SE}(2)\).

We first can generalize the de-Casteljau algorithm for Beziér curves to Lie groups by replacing the linear interpolation step with using the exponential and logarithmic map.

In Code~\ref{lst:deCasteljauLieGroup}, we define the general de-Casteljau algorithm on a Lie group \verb|G|, given a vector of control points \verb|cp| and a parameter \verb|t| in \([0,1]\).

We can now compare the algorithm on the Lie group \(\mathrm{SE}(2)\) with the corresponding Bézier curve on the (direct) product Lie group $\mathrm{SO}(2) \times \mathcal T(2)$, where \(\mathcal T(2) = (\mathbb{R}^2, +)\) is the \verb|TranslationGroup(2)|.
Denote by $R_\alpha$ the rotation matrix in \(\mathrm{SO}(2)\) for an angle \(\alpha\in[0,2\pi)\).
We consider the control points
\begin{align*}
    g_1 &= \Bigl(R_{\frac{\pi}{2}}, \begin{pmatrix} 0 \\ 0 \end{pmatrix}\Bigr),
    &\quad
    g_2 &= \Bigl(R_{\frac{\pi}{4}}, \begin{pmatrix} 1/3 \\ 1/2 \end{pmatrix}\Bigr),
    \\%\quad
    g_3 &= \Bigl(R_{\frac{3\pi}{4}}, \begin{pmatrix} 2/3 \\ -1/2 \end{pmatrix}\Bigr),
    &\quad
    g_4 &= \Bigl(R_{\pi}, \begin{pmatrix} 1 \\ 0 \end{pmatrix}\Bigr).
\end{align*}

We evaluate the corresponding Bézier curves on both Lie groups using the Code~\ref{lst:bezierLieGroupExample}.
\begin{lstlisting}[
    float=tbp,
    language = Julia,
    numbers=left,
    label={lst:bezierLieGroupExample},
    caption={Evaluating Bézier curves on \(\mathrm{SE}(2)\) and \(\mathrm{SO}(2) \times \mathcal T(2)\).},
    mathescape
]
SO2 = SpecialOrthogonalGroup(2)
R2 = TranslationGroup(2)
SO2xR2 = SO2 $\times$ R2
ts = range(0, 1, length=35)
q1 = [
    deCasteljauLieGroup(SO2xT2, cp, t) for t in ts
]
SE2 = SpecialEuclideanGroup(2)
q2 = [deCasteljauLieGroup(SE2, cp, t) for t in ts]
\end{lstlisting}

\begin{figure}[tbp]
    % Arrow scale factor
    \def\arrowscale{0.15}

    \begin{tikzpicture}
        \begin{axis}[
            grid=major,
            width=.5\textwidth,
            legend style={at={(0.95,0.9)}},
            xmin=-0.05, xmax=1.05,
            ymin=-0.525, ymax=0.625,
            unit vector ratio=1 1,
            title style={yshift=-.5\baselineskip,},
            title={Two Bézier curves on different Lie groups},
        ]
            % Control points
            % Quiver plot from CSV file
            \addplot[
                quiver={u=\thisrow{u}, v=\thisrow{v}, scale arrows=\arrowscale},
                -stealth, very thick, TolMutedBlue,
            ] table[col sep=comma] {data/bezier_example_control_points.csv};
            \addlegendentry{Control points}
            % Plot the base points from CSV file
            \addplot[only marks, mark=*, mark size=2pt, TolMutedBlue, forget plot,
                ] table[col sep=comma] {data/bezier_example_control_points.csv};
            % SO2xR2 Curve and quiver
            \addplot[solid, thick, TolMutedSand, forget plot] table[col sep=comma, x=x, y=y] {data/bezier_example_so2r2_dense_curve.csv};
            % Quiver plot from CSV file
            \addplot[
                quiver={u=\thisrow{u}, v=\thisrow{v}, scale arrows=\arrowscale},
                -stealth, TolMutedSand,
            ] table[col sep=comma] {data/bezier_example_so2r2.csv};
            \addlegendentry{$\mathrm{SO}(2)\times \mathcal T(2)$}
            % Plot the base points from CSV file
            \addplot[only marks, mark=*, mark size=1.5pt, TolMutedSand, forget plot,
                ] table[col sep=comma] {data/bezier_example_so2r2.csv};
            % SE2 Curve and quiver
            \addplot[solid, thick, TolMutedTeal, forget plot] table[col sep=comma, x=x, y=y] {data/bezier_example_se2_dense_curve.csv};
            % Quiver plot from CSV file
            \addplot[
                quiver={u=\thisrow{u}, v=\thisrow{v}, scale arrows=\arrowscale},
                -stealth, TolMutedTeal,
            ] table[col sep=comma] {data/bezier_example_se2.csv};
            \addlegendentry{$\mathrm{SE}(2)$}
            % Plot the base points from CSV file
            \addplot[only marks, mark=*, mark size=1.5pt, TolMutedTeal, forget plot,
                ] table[col sep=comma] {data/bezier_example_se2.csv};
        \end{axis}
    \end{tikzpicture}
    \caption{Bézier curves on the Lie groups \(\mathrm{SE}(2)\) (teal) and \(\mathrm{SO}(2) \times \mathbb{R}^2\) (sand) based on the same control points
    $g_1,\ldots,g_4$ (blue).}%
    \label{fig:Bezier}
\end{figure}

The resulting Bézier curves on both Lie groups are shown in Figure~\ref{fig:Bezier}.
One can see that the product Lie group works the same as if one would have done that
separately component-wise, while the Bézier curve on \(\mathrm{SE}(2)\) behaves differently.
A main feature here is, that due to the generic implementation on arbitrary Lie groups,
we can easily switch between different Lie groups, where the data is still valid.

\subsection{Simulating a charged rod in a static electric field}

Physical systems can often be described by ordinary differential equations on Lie groups.
For example, the state of a charged metal rod moving on a plane can be specified by its position, orientation, linear velocity, and angular velocity.
Such state naturally belongs to a Lie group: a direct product of \(\mathcal G_1 = \mathrm{SO}(2) \times \mathbb{R}^2\) and its Lie algebra, \(\mathfrak{g}_1\), denoted \(\mathcal G = \mathcal G_1 \times \mathfrak{g}_1\).
The ordinary differential equation governing the dynamics of the system can be derived from the electrostatic approximation, in particular the Coulomb's law.
Electric point charges \(q_i, i \in {1, \dots, N}\) at positions \(R_i\) generate a static electric field \(E(p)\) at every point \(p\) in the plane.
The force and the moment of force affecting the rod of length \(L\), mass \(M\), moment of inertia \(I_M\) linear charge density \(\lambda\), with the center at position \(p\), orientation \(\theta\), and where \(u\) is the direction along the rod can be expressed as the following two second order ODEs
\begin{align*}
    M\ddot{p} &= \lambda \int_{-L/2}^{L/2} E(p + su) ds,  \\
    I_M \ddot{\theta} &= \int_{-L/2}^{L/2} \lambda s u_{\perp} \cdot E(p + su) ds,
\end{align*}
where \(u_{\perp}\) is the vector perpendicular to \(u\). The pair \(g=(p, \theta)\) represents a point on \(\mathcal G_1\), while \(\dot g = (\dot{p}, \dot{\theta})\) is an element of the Lie algebra \(\mathfrak{g}_1\).
This second order ODE on \(\mathcal G_1\) can be converted to a first order ODE on \(\mathcal G = \mathcal G_1 \times \mathfrak{g}_1\) by introducing \((\dot{p}, \dot{\theta})\) as additional state variables.

The overall ODE has the form
\begin{equation*}
    \frac{d}{dt}\begin{pmatrix} g \\ \dot{g} \end{pmatrix}
    = \begin{pmatrix} \dot{g} \\ f(g, \dot{g}, t) \end{pmatrix},
\end{equation*}
where \(g \in \mathcal G_1\) and \(f(g, \dot{g}, t)\) is derived from the above equations. We further require initial conditions for both \(g\) and \(\dot{g}\) at time \(t_0=0\).
Then this can be solved using Lie group methods, such as the Runge-Kutta-Munthe-Kaas (RKMK) variant~\cite{Munthe-Kaas:1998} of Heun's method~\cite[App.~A.1]{IserlesMunthe-KaasNoersettZanna:2000}.

Code~\ref{lst:rod-dynamics} shows functions that calculate the right hand side of the ODE, where \verb|E_field| is a function that calculates electric field strength from the point charges at the given point.
The function \verb|force_and_torque| calculates the force and torque affecting the rod, while \verb|dynamics| converts them to the Lie algebra element can be used by the solver.
\begin{lstlisting}[
    float=tbp,
    language = Julia,
    numbers=left,
    label={lst:rod-dynamics},
    caption={Dynamics of a rod affected by point charges.},
    mathescape
]
function force_and_torque(
        sp::SystemParameters, Fθ, r
    )
    u, u${}_\perp$ = eachrow(Fθ)
    F, $\tau$ = zeros(2), 0.0
    for s in range(-sp.L/2, sp.L/2; length=Nq)
        E = E_field(sp, r .+ s .* u)
        F .+= sp.$\lambda$ * E * (sp.L/(Nq-1))
        $\tau$ += sp.$\lambda$ * s * dot(u${}_\perp$, E) * (sp.L/(Nq-1))
    end
    return F, $\tau$
end
# f((p,θ), (dp,dθ), t) where (p,θ) and (dp,dθ) are
# passed as the first argument, system parameters
# as the second one and time as the last one
function dynamics(state, sp::SystemParameters, t)
    p, dp = state.x
    F, tau = force_and_torque(sp, p.x...)
    a = F ./ sp.M
    c = [tau / sp.Icm, a...]
    ddx = hat(sp.lie_algebra, c, ArrayPartition)
    return ArrayPartition(dp, ddx)
end
\end{lstlisting}

The RKMK Heun method is a second order method that can solve ordinary differential equations defined on Lie groups.
A single step of an RKMK-type Heun solver is implemented in Code~\ref{lst:heun}.
For our special case the \verb|manifold| is equal to the \verb|group|, namely $\mathcal G$, and the group action is the left group operation.

The main advantage of using a Lie group solver for this problem is that we do not have to consider parametrization of the Lie group.
The presented approach can be easily generalized to three spatial dimensions, where parametrization of rotations on $\mathrm{SO}(3)$ would be even more challenging numerically.

\begin{lstlisting}[
    float=tbp,
    language = Julia,
    numbers=left,
    label={lst:heun},
    caption={Step calculation for the RKMK Heun method.}
]
function integrator_step!(
        A::GroupAction, sp::SystemParameters,
        y, f, t, dt
) # The dynamics function is passed as f
    Ie = Identity(A.group)
    F1 = (dt / 2) * f(y, sp, t)
    tmp = zero_vector(A.manifold, y)
    diff_group_apply!(A, tmp, Ie, y, F1)
    y2 = exp(A.manifold, y, tmp)
    F2 = dt * f(y2, sp, t + dt/2)
    diff_group_apply!(A, tmp, Ie, y, F2)
    exp!(base_manifold(A), y, y, tmp)
end
\end{lstlisting}

\begin{figure}[tbp]
    % Arrow scale factor
    \def\arrowscale{1.0}

    \begin{tikzpicture}
        \begin{axis}[
            grid=major,
            width=.5\textwidth,
            legend style={at={(0.95,0.25)}, anchor=east},
            unit vector ratio=1 1,
            xmin = -1.5, xmax = 4.5,
            ymin = -3.25, ymax = 2.75,
            align=center,
            title style={yshift=-.5\baselineskip,},
            title={Trajectories of a charged rod in the electric field\\ generated by two point charges},
            xlabel={x [m]},
            ylabel={y [m]},
        ] %
            \addplot[only marks, mark=*, mark size=2pt, color=TolMutedSand] coordinates {(-1, 0.0)};
            \addlegendentry{$q_1$};
            \addplot[only marks, mark=*, mark size=2pt, color=TolMutedOlive] coordinates {(1, 0.0)};
            \addlegendentry{$q_2$};
            % Curve and quiver+-
            \addplot[solid, thick, TolMutedBlue] table[col sep=comma, x=x, y=y] {data/ex2_rod_1_dense.csv} node[circle, black, inner sep=1.25pt, fill=TolMutedBlue, pos=0.0] {};
            \addlegendentry{$\gamma_1$}
            % Quiver plot from CSV file
            \addplot[
                quiver={u=\thisrow{up}, v=\thisrow{vp}, scale arrows=\arrowscale}, -{Bar[width=3pt]}, TolMutedBlue, forget plot,
            ] table[col sep=comma] {data/ex2_rod_1_sparse.csv};
            \addplot[
                quiver={u=\thisrow{um}, v=\thisrow{vm}, scale arrows=\arrowscale}, -{Circle[length=1.75pt]}, TolMutedBlue, forget plot,
            ] table[col sep=comma] {data/ex2_rod_1_sparse.csv};
            % Plot the base points from CSV file
            \addplot[
                only marks, mark=*, mark size=.0pt, TolMutedBlue, forget plot,
            ] table[col sep=comma] {data/ex2_rod_1_sparse.csv};
            %
            %
            % Curve and quiver+-
            \addplot[solid, thick, TolMutedGreen] table[col sep=comma, x=x, y=y] {data/ex2_rod_2_dense.csv}node[circle, black, inner sep=1.25pt, fill=TolMutedGreen, pos=0.0] {};
            \addlegendentry{$\gamma_2$}
            % Quiver plot from CSV file
            \addplot[
                quiver={u=\thisrow{up}, v=\thisrow{vp}, scale arrows=\arrowscale}, -{Bar[width=3pt]}, TolMutedGreen, forget plot,
            ] table[col sep=comma] {data/ex2_rod_2_sparse.csv};
            \addplot[
                quiver={u=\thisrow{um}, v=\thisrow{vm}, scale arrows=\arrowscale}, -{Circle[length=1.75pt]}, TolMutedGreen, forget plot,
            ] table[col sep=comma] {data/ex2_rod_2_sparse.csv};
            % Plot the base points from CSV file
            \addplot[
                only marks, mark=*, mark size=.0pt, TolMutedGreen, forget plot,
            ] table[col sep=comma] {data/ex2_rod_2_sparse.csv};
            %
            %
            % Curve and quiver+-
            \addplot[solid, thick, TolMutedPurple] table[col sep=comma, x=x, y=y] {data/ex2_rod_3_dense.csv} node[circle, black, inner sep=1.25pt, fill=TolMutedPurple, pos=0.0] {};
            \addlegendentry{$\gamma_3$}
            % Quiver plot from CSV file
            \addplot[
                quiver={u=\thisrow{up}, v=\thisrow{vp}, scale arrows=\arrowscale}, -{Bar[width=3pt]}, TolMutedPurple, forget plot,
            ] table[col sep=comma] {data/ex2_rod_3_sparse.csv};
            \addplot[
                quiver={u=\thisrow{um}, v=\thisrow{vm}, scale arrows=\arrowscale}, -{Circle[length=1.75pt]}, TolMutedPurple, forget plot,
            ] table[col sep=comma] {data/ex2_rod_3_sparse.csv};
            % Plot the base points from CSV file
            \addplot[
                only marks, mark=*, mark size=.0pt, TolMutedPurple, forget plot,
            ] table[col sep=comma] {data/ex2_rod_3_sparse.csv};
        \end{axis}
    \end{tikzpicture}
    \caption{Three solution curves \(\gamma_1\) (blue), \(\gamma_2\) (green), and \(\gamma_3\) (purple) of a Lie group Heun method on the product of Lie groups \(\mathrm{SO}(2) \times \mathbb R^2\)
    modelling the movement within an electric field with two point charges located at
    $q_1$ (sand) and $q_2$ (olive).
    The initial start points of the rods are indicated by circles, the rods themselves have two
    different end markers to indicate their orientation.
    }%
    \label{fig:Heun}
\end{figure}

The presented method was applied to a case with two static charges: \SI{1e-6}{C} at position (\SI{-1}{m}, \SI{0}{m}) and \SI{-1e-6}{C} at position (\SI{1}{m}, \SI{0}{m}).
A rod of length \SI{0.67}{m} with charge density \SI{1e-6}{C/m} and mass \SI{1}{kg} started from three different initial states:
\begin{enumerate}
    \item position (\SI{0}{m}, \SI{-1.5}{m}), angle \SI{0.1}{rad}, velocity (\SI{0}{m/s}, \SI{0}{m/s}), angular velocity \SI{0}{rad/s},
    \item position (\SI{-0.2}{m}, \SI{1}{m}), angle \SI{0.2}{rad}, velocity (\SI{-0.12}{m/s}, \SI{-0.15}{m/s}), angular velocity \SI{0}{rad/s},
    \item position (\SI{-0.5}{m}, \SI{-0.5}{m}), angle \SI{0.6}{rad}, velocity (\SI{-0.04}{m/s}, \SI{0.12}{m/s}), angular velocity \SI{0}{rad/s}.
\end{enumerate}
The trajectories obtained in a simulation with time step \SI{0.001}{s} are presented in Figure~\ref{fig:Heun}.
Simulation times between \SI{30}{s} and \SI{135}{s} were chosen to have the rod remain relatively close to point charges.
Position and orientation of the rod is indicated at 20 equally spaced times, along with a densely sampled trajectory of the center of the rod.
\\
For more advanced methods of solving differential equations on Manifolds and Lie groups in Julia, see
\verb|ManifoldDiffEq.jl|.\footnote{see \href{https://juliamanifolds.github.io/ManifoldDiffEq.jl/stable/}{juliamanifolds.github.io/ManifoldDiffEq.jl/stable/}.}

%\balance
\newpage
\input{bib.tex}
\end{document}