<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lie group ¬∑ LieGroups.jl</title><meta name="title" content="Lie group ¬∑ LieGroups.jl"/><meta property="og:title" content="Lie group ¬∑ LieGroups.jl"/><meta property="twitter:title" content="Lie group ¬∑ LieGroups.jl"/><meta name="description" content="Documentation for LieGroups.jl."/><meta property="og:description" content="Documentation for LieGroups.jl."/><meta property="twitter:description" content="Documentation for LieGroups.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/link-icons.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="LieGroups.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="LieGroups.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LieGroups.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../../tutorials/getstarted/">üöÄ Get Started with LieGroups.jl</a></li><li><a class="tocitem" href="../../tutorials/transition/">Transition from <code>GroupManifolds</code></a></li></ul></li><li><span class="tocitem">Lie groups</span><ul><li><a class="tocitem" href="../../groups/">List of Lie groups</a></li><li><a class="tocitem" href="../../groups/circle_group/">Circle Group</a></li><li><a class="tocitem" href="../../groups/general_linear/">General linear group</a></li><li><a class="tocitem" href="../../groups/heisenberg_group/">Heisenberg group</a></li><li><a class="tocitem" href="../../groups/orthogonal_group/">Orthogonal group</a></li><li><a class="tocitem" href="../../groups/power_group/">Power group</a></li><li><a class="tocitem" href="../../groups/product_group/">Product group</a></li><li><a class="tocitem" href="../../groups/semidirect_product_group/">Semidirect product group</a></li><li><a class="tocitem" href="../../groups/special_euclidean_group/">Special Euclidean group</a></li><li><a class="tocitem" href="../../groups/special_galilean_group/">Special Galilean group</a></li><li><a class="tocitem" href="../../groups/special_linear/">Special linear</a></li><li><a class="tocitem" href="../../groups/special_orthogonal_group/">Special orthogonal group</a></li><li><a class="tocitem" href="../../groups/special_unitary_group/">Special unitary group</a></li><li><a class="tocitem" href="../../groups/symplectic_group/">Symplectic group</a></li><li><a class="tocitem" href="../../groups/translation_group/">Translation group</a></li><li><a class="tocitem" href="../../groups/unitary_group/">Unitary group</a></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li class="is-active"><a class="tocitem" href>Lie group</a><ul class="internal"><li><a class="tocitem" href="#Special-types"><span>Special types</span></a></li><li><a class="tocitem" href="#Functions-on-Lie-groups"><span>Functions on Lie groups</span></a></li><li><a class="tocitem" href="#Internal-functions-and-macros"><span>Internal functions and macros</span></a></li><li><a class="tocitem" href="#A-validation-Lie-group"><span>A validation Lie group</span></a></li><li><a class="tocitem" href="#A-metric-Lie-group-to-change-the-metric-on-a-Lie-Algebra"><span>A metric Lie group to change the metric on a Lie Algebra</span></a></li><li><a class="tocitem" href="#Literature"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="../algebra/">Lie algebra</a></li><li><a class="tocitem" href="../operations/">Group operation</a></li><li><a class="tocitem" href="../actions/">Group action</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing to LieGroups.jl</a></li><li><a class="tocitem" href="../../notation/">Notation</a></li><li><a class="tocitem" href="../../news/">Changelog</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Interfaces</a></li><li class="is-active"><a href>Lie group</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lie group</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/LieGroups.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/main/docs/src/interface/group.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="An-interface-for-Lie-groups"><a class="docs-heading-anchor" href="#An-interface-for-Lie-groups">An interface for Lie groups</a><a id="An-interface-for-Lie-groups-1"></a><a class="docs-heading-anchor-permalink" href="#An-interface-for-Lie-groups" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.AbstractLieGroup" href="#LieGroups.AbstractLieGroup"><code>LieGroups.AbstractLieGroup</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractLieGroup{ùîΩ, O&lt;:AbstractGroupOperation, M&lt;:AbstractManifold{ùîΩ}} &lt;: AbstractManifold{ùîΩ}</code></pre><p>An abstract type to represent Lie groups. For most cases it should suffice to ‚Äúcombine‚Äù an <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> with an <a href="../operations/#LieGroups.AbstractGroupOperation"><code>AbstractGroupOperation</code></a>, see <a href="#LieGroups.LieGroup"><code>LieGroup</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.LieGroup" href="#LieGroups.LieGroup"><code>LieGroups.LieGroup</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LieGroup{ùîΩ, O&lt;:AbstractGroupOperation, M&lt;:AbstractManifold{ùîΩ}} &lt;:  AbstractLieGroup{ùîΩ, O, M}</code></pre><p>Represent a Lie Group <span>$\mathcal G$</span>.</p><p>A <em>Lie Group</em> <span>$\mathcal G$</span> is a group endowed with the structure of a manifold such that the group operations <span>$‚àò: \mathcal G√ó\mathcal G ‚Üí \mathcal G$</span>, see <a href="../../groups/semidirect_product_group/#LieGroups.compose-Union{Tuple{AO}, Tuple{A}, Tuple{O2}, Tuple{O1}, Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, &lt;:LieGroups.SemidirectProductGroupOperation{O1, O2, A, AO}, &lt;:ManifoldsBase.ProductManifold}, Any, Any}} where {ùîΩ, O1, O2, A&lt;:AbstractLeftGroupActionType, AO&lt;:ActionActsOnLeft}"><code>compose</code></a> and the inverse operation <span>$‚ãÖ^{-1}: \mathcal G ‚Üí \mathcal G$</span>, see <a href="../../groups/semidirect_product_group/#Base.inv-Union{Tuple{AO}, Tuple{A}, Tuple{O2}, Tuple{O1}, Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, &lt;:LieGroups.SemidirectProductGroupOperation{O1, O2, A, AO}, &lt;:ManifoldsBase.ProductManifold}, Any}} where {ùîΩ, O1, O2, A&lt;:AbstractGroupActionType, AO&lt;:AbstractActionActsOnType}"><code>inv</code></a> are smooth, see for example [<a href="../../references/#HilgertNeeb_2012">HN12</a>, Definition 9.1.1].</p><p>Lie groups are named after the Norwegian mathematician <a href="https://en.wikipedia.org/wiki/Sophus_Lie">Marius Sophus Lie</a> (1842‚Äì1899).</p><p><strong>Fields</strong></p><ul><li><code>manifold</code>: an <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <span>$\mathcal M$</span></li><li><code>op</code>: an <a href="../operations/#LieGroups.AbstractGroupOperation"><code>AbstractGroupOperation</code></a> <span>$‚àò$</span> on that manifold</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">LieGroup(M::AbstractManifold, op::AbstractGroupOperation)</code></pre><p>Generate a Lie group based on a manifold <code>M</code> and a group operation <code>op</code>, where vectors by default are stored in the Lie Algebra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L74-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.AbstractLieAlgebraTangentVector" href="#LieGroups.AbstractLieAlgebraTangentVector"><code>LieGroups.AbstractLieAlgebraTangentVector</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractLieAlgebraTangentVector &lt;: ManifoldsBase.AbstractTangentVector</code></pre><p>An abstract type for a tangent vector represented in a <a href="../algebra/#LieGroups.LieAlgebra"><code>LieAlgebra</code></a>.</p><p>While an tangent vectors are usually kept untyped for flexibility, it might be necessary to distinguish different types of points, for example</p><ul><li>for complicated representations that require a struct</li></ul><p>@ semantic verification</p><ul><li>when there exist different representations</li></ul><p>By sub-typing the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types/#ManifoldsBase.AbstractManifoldPoint"><code>AbstractManifoldPoint</code></a>, this follows the same idea as in <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/"><code>ManifoldsBase.jl</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L143-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.AbstractLieGroupPoint" href="#LieGroups.AbstractLieGroupPoint"><code>LieGroups.AbstractLieGroupPoint</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractLieGroupPoint &lt;: ManifoldsBase.AbstractManifoldPoint end</code></pre><p>An abstract type for a point on an <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a>. While an points and tangent vectors are usually kept untyped for flexibility, it might be necessary to distinguish different types of points, for example</p><ul><li>for complicated representations that require a struct</li><li>semantic verification</li><li>when there exist different representations</li></ul><p>By sub-typing the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types/#ManifoldsBase.AbstractManifoldPoint"><code>AbstractManifoldPoint</code></a>, this follows the same idea as in <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/"><code>ManifoldsBase.jl</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L128-L140">source</a></section></article><h2 id="Special-types"><a class="docs-heading-anchor" href="#Special-types">Special types</a><a id="Special-types-1"></a><a class="docs-heading-anchor-permalink" href="#Special-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.BaseManifoldInverseRetraction" href="#LieGroups.BaseManifoldInverseRetraction"><code>LieGroups.BaseManifoldInverseRetraction</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BaseManifoldInverseRetraction{IRM&lt;:AbstractInverseRetractionMethod} &lt;: AbstractInverseRetractionMethod</code></pre><p>Compute an inverse retraction by using the inverse retraction of type <code>IRM</code> on the base manifold of a <a href="#LieGroups.LieGroup"><code>LieGroup</code></a>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">BaseManifoldInverseRetraction(irm::AbstractInverseRetractionMethod)</code></pre><p>Generate the inverse retraction with inverse retraction <code>rm</code> to use on the base manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L13-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.BaseManifoldRetraction" href="#LieGroups.BaseManifoldRetraction"><code>LieGroups.BaseManifoldRetraction</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BaseManifoldRetraction{RM&lt;:AbstractRetractionMethod} &lt;: AbstractRetractionMethod</code></pre><p>Compute a retraction by using the retraction of type <code>RM</code> on the base manifold of a <a href="#LieGroups.LieGroup"><code>LieGroup</code></a>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">BaseManifoldRetraction(rm::AbstractRetractionMethod)</code></pre><p>Generate the retraction with retraction <code>rm</code> to use on the base manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L30-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.BaseManifoldVectorTransportMethod" href="#LieGroups.BaseManifoldVectorTransportMethod"><code>LieGroups.BaseManifoldVectorTransportMethod</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BaseManifoldVectorTransportMethod{VTM&lt;:AbstractVectorTransportMethod} &lt;:
    AbstractVectorTransportMethod</code></pre><p>Compute a vector transport by using the transport of type <code>VTM</code> on the base manifold of a <a href="#LieGroups.LieGroup"><code>LieGroup</code></a>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">BaseManifoldVectorTransportMethod(vtm::AbstractVectorTransportMethod)</code></pre><p>Generate the vector transport with transport <code>vtm</code> to use on the base manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L1181-L1193">source</a></section></article><h2 id="Functions-on-Lie-groups"><a class="docs-heading-anchor" href="#Functions-on-Lie-groups">Functions on Lie groups</a><a id="Functions-on-Lie-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-on-Lie-groups" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.adjoint-Tuple{AbstractLieGroup, Any, Any}" href="#Base.adjoint-Tuple{AbstractLieGroup, Any, Any}"><code>Base.adjoint</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjoint(G::AbstractLieGroup, g, X)
adjoint!(G::AbstractLieGroup, Y, g, X)</code></pre><p>Compute the adjoint <span>$\mathrm{Ad}(g): \mathfrak g ‚Üí \mathfrak g$</span>, which is defined as the differential <a href="../../groups/circle_group/#LieGroups.diff_conjugate-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, &lt;:Manifolds.Circle{‚Ñù}}, Any, Any, Number}"><code>diff_conjugate</code></a> of the <a href="../../groups/circle_group/#LieGroups.conjugate-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, &lt;:Manifolds.Circle{‚Ñù}}, Any, Any}"><code>conjugate</code></a> <span>$c_g(h) = g‚àòh‚àòg^{-1}$</span> evaluated at the <a href="../operations/#LieGroups.Identity"><code>Identity</code></a> <span>$h=\mathrm{e}$</span>. The operation can be performed in-place of <code>Y</code>.</p><p class="math-container">\[  \mathrm{Ad}(g)[X] = \mathrm{d} c_g(\mathrm{e}) [X], \qquad X ‚àà \mathfrak g.\]</p><p>see [<a href="../../references/#HilgertNeeb_2012">HN12</a>, Section 9.2.3].</p><p>On matrix Lie groups the adjoint reads <span>$\mathrm{Ad}(g)[X] = gXg^{-1}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L182-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.exp-Tuple{AbstractLieGroup, Any, Any}" href="#Base.exp-Tuple{AbstractLieGroup, Any, Any}"><code>Base.exp</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exp(G::AbstractLieGroup, g, X)
exp!(G::AbstractLieGroup, h, g, X)</code></pre><p>Compute the Lie group exponential map for <span>$g‚àà\mathcal G$</span> and <span>$X‚àà\mathfrak g$</span>, where <span>$\mathfrak g$</span> denotes the <a href="../algebra/#LieGroups.LieAlgebra"><code>LieAlgebra</code></a> of <span>$\mathcal G$</span>. It is given by</p><p class="math-container">\[\exp_g X = g‚àò\exp_{\mathcal G}(X)\]</p><p>where <code>X</code> can be scaled by <code>t</code>, the computation can be performed in-place of <code>h</code>, and <span>$\exp_{\mathcal G}$</span> denotes the  <a href="../../groups/circle_group/#Base.exp-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, &lt;:Manifolds.Circle{‚Ñù}}, Number}">Lie group exponential function</a>.</p><p>If <code>g</code> is the <a href="../operations/#LieGroups.Identity"><code>Identity</code></a> the <a href="../../groups/circle_group/#Base.exp-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, &lt;:Manifolds.Circle{‚Ñù}}, Number}">Lie group exponential function</a> <span>$\exp_{\mathcal G}$</span> is computed directly. Implementing the Lie group exponential function introduces a default implementation with the formula above.</p><div class="admonition is-info" id="Note-ab5fdb94eee10cc4"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ab5fdb94eee10cc4" title="Permalink"></a></header><div class="admonition-body"><p>The Lie group exponential map is usually different from the exponential map with respect to the metric of the underlying Riemannian manifold <span>$\mathcal M$</span>. To access the (Riemannian) exponential map, use <code>exp(</code><a href="../actions/#ManifoldsBase.base_manifold-Tuple{GroupAction}"><code>base_manifold</code></a><code>(G), g, X)</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L496-L518">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.exp-Tuple{AbstractLieGroup, Any}" href="#Base.exp-Tuple{AbstractLieGroup, Any}"><code>Base.exp</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exp(G::AbstractLieGroup, X::T)
exp!(G::AbstractLieGroup, g, X)</code></pre><p>Compute the (Lie group) exponential function</p><p class="math-container">\[\exp_{\mathcal G}: \mathfrak g ‚Üí \mathcal G,\qquad \exp_{\mathcal G}(X) = Œ≥_X(1),\]</p><p>where <span>$Œ≥_X$</span> is the unique solution of the initial value problem</p><p class="math-container">\[Œ≥(0) = \mathrm{e}, \quad Œ≥&#39;(s) = Œ≥(s)‚ãÖX.\]</p><p>See also [<a href="../../references/#HilgertNeeb_2012">HN12</a>, Definition 9.2.2]. On matrix Lie groups this is the same as the <a href="https://en.wikipedia.org/wiki/Matrix_exponential">matrix exponential</a>.</p><p>The computation can be performed in-place of <code>g</code>.</p><div class="admonition is-info" id="Naming-convention-fd2cfc901bc6a35"><header class="admonition-header">Naming convention<a class="admonition-anchor" href="#Naming-convention-fd2cfc901bc6a35" title="Permalink"></a></header><div class="admonition-body"><p>There are at least two different objects usually called ‚Äúexponential‚Äù that need to be distinguished</p><ul><li>the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.exp-Tuple%7BAbstractManifold%2C%20Any%2C%20Any%7D">(Riemannian) exponential map</a> <code>exp(M, p, X)</code> from <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/"><code>ManifoldsBase.jl</code></a>. This can be accessed here using <code>exp(base_manifold(G), p, X)</code></li><li>the exponential map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric <code>exp(G, g, X)</code>, which we use as a default within this package</li><li>the (matrix/Lie group) exponential function <code>exp(G, g)</code> which agrees with the previous one for <code>g</code> being the identity there.</li></ul></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L541-L569">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.inv-Tuple{AbstractLieGroup, Any}" href="#Base.inv-Tuple{AbstractLieGroup, Any}"><code>Base.inv</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inv(G::AbstractLieGroup, g)
inv!(G::AbstractLieGroup, h, g)</code></pre><p>Compute the inverse group element <span>$g^{-1}$</span> with respect to the <a href="../operations/#LieGroups.AbstractGroupOperation"><code>AbstractGroupOperation</code></a> <span>$‚àò$</span> on the <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <span>$\mathcal G$</span>, that is, return the unique element <span>$h=g^{-1}$</span> such that <span>$h‚àòg=\mathrm{e}$</span>, where <span>$\mathrm{e}$</span> denotes the <a href="../operations/#LieGroups.Identity"><code>Identity</code></a>.</p><p>This can be done in-place of <code>h</code>, without side effects, that is you can do <code>inv!(G, g, g)</code>.</p><div class="admonition is-info" id="Info-f51f2420db92deaf"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-f51f2420db92deaf" title="Permalink"></a></header><div class="admonition-body"><p>This function also handles the case where <code>g</code> is the <a href="../operations/#LieGroups.Identity"><code>Identity</code></a><code>(G)</code>. Since this would lead to ambiguities when implementing a new group operations, this function calls <code>_inv</code> and <code>_inv!</code>, respectively, which is meant for the actual computation of group operations on (non-<a href="../operations/#LieGroups.Identity"><code>Identity</code></a>` but maybe its numerical representation) elements.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L623-L638">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isapprox-Tuple{AbstractLieGroup, Any, Any}" href="#Base.isapprox-Tuple{AbstractLieGroup, Any, Any}"><code>Base.isapprox</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isapprox(M::AbstractLieGroup, g, h; kwargs...)</code></pre><p>Check if points <code>g</code> and <code>h</code> from <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> are approximately equal. this function calls the corresponding <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.isapprox-Tuple%7BAbstractManifold%2C%20Any%2C%20Any%2C%20Any%7D"><code>isapprox</code></a> on the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> after handling the cases where one or more of the points are the <a href="../operations/#LieGroups.Identity"><code>Identity</code></a>. All keyword argments are passed to this function as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L800-L808">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.log-Tuple{AbstractLieGroup, Any, Any}" href="#Base.log-Tuple{AbstractLieGroup, Any, Any}"><code>Base.log</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">log(G::AbstractLieGroup, g, h)
log!(G::AbstractLieGroup, X, g, h)</code></pre><p>Compute the Lie group logarithmic map <span>$\log_g: \mathcal G ‚Üí \mathfrak g$</span>, where <span>$\mathfrak g$</span> denotes the <a href="../algebra/#LieGroups.LieAlgebra"><code>LieAlgebra</code></a> of <span>$\mathcal G$</span>. It is given by</p><p class="math-container">\[\log_g h = \log_{\mathcal G}(g^{-1}‚àòh)\]</p><p>where <span>$\log_{\mathcal G}$</span> denotes the <a href="#Base.log-Tuple{AbstractLieGroup, Any}">Lie group logarithmic function</a> The computation can be performed in-place of <code>X</code>.</p><div class="admonition is-info" id="Naming-convention-4ae1f24b6f1ae628"><header class="admonition-header">Naming convention<a class="admonition-anchor" href="#Naming-convention-4ae1f24b6f1ae628" title="Permalink"></a></header><div class="admonition-body"><p>There are at least two different objects usually called ‚Äúlogarithm‚Äù that need to be distinguished</p><ul><li>the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.log-Tuple%7BAbstractManifold%2C%20Any%2C%20Any%7D">(Riemannian) logarithmic map</a> <code>log(M, p, X)</code> from <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/"><code>ManifoldsBase.jl</code></a></li><li>the exponential map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric <code>exp(G, g, X)</code>, which we use as a default within this package</li><li>the (matrix/Lie group) exponential function <code>exp(G, g)</code> which agrees with the previous one for <code>g</code> being the identity there.</li></ul></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L936-L957">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.log-Tuple{AbstractLieGroup, Any}" href="#Base.log-Tuple{AbstractLieGroup, Any}"><code>Base.log</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">log(G::AbstractLieGroup, g, h)
log(G::AbstractLieGroup, g)
log(G::AbstractLieGroup, g::Identity, T)
log!(G::AbstractLieGroup, X::T, g)</code></pre><p>Compute the (Lie group) logarithmic function <span>$\log_{\mathcal G}: \mathcal G ‚Üí \mathfrak g$</span>, which is the inverse of the <a href="#Base.exp-Tuple{AbstractLieGroup, Any}">Lie group exponential function</a>. For the allocating variant, you can specify the type <code>T</code>, when the point argument is the identity and hence does not provide the representation used. The computation can be performed in-place of <code>X::T</code>, which then determines the type.</p><div class="admonition is-info" id="Naming-convention-74cfd1606a59e1b8"><header class="admonition-header">Naming convention<a class="admonition-anchor" href="#Naming-convention-74cfd1606a59e1b8" title="Permalink"></a></header><div class="admonition-body"><p>There are at least two different objects usually called ‚Äúlogarithm‚Äù that need to be distinguished</p><ul><li>the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.log-Tuple%7BAbstractManifold%2C%20Any%2C%20Any%7D">(Riemannian) logarithm</a> map <code>log(M, p, q)</code> from <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/"><code>ManifoldsBase.jl</code></a>. This can be accessed here using <code>log(base_manifold(G), p, q)</code>.</li><li>the logarithmic map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric <code>log(G, g, h)</code>, which we use as a default within this package</li><li>the (matrix/Lie group) logarithm function <code>log(G, h)</code> which agrees with the previous one for <code>g</code> being the identity there.</li></ul></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L968-L985">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{AbstractLieGroup, Type}" href="#Base.rand-Tuple{AbstractLieGroup, Type}"><code>Base.rand</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand(::AbstractLieGroup; vector_at=nothing, œÉ::Real=1.0, kwargs...)
rand(::AbstractLieGroup, PT::Type; vector_at=nothing, œÉ::Real=1.0, kwargs...)
rand!(::LieAlgebra, T::Type; œÉ::Real=1.0, kwargs...)
rand!(::AbstractLieGroup, gX::PT; vector_at=nothing, œÉ::Real=1.0, kwargs...)
rand!(::LieAlgebra, X::T; œÉ::Real=1.0, kwargs...)</code></pre><p>Compute a random point or tangent vector on a Lie group.</p><p>For points this just means to generate a random point on the underlying manifold itself.</p><p>For tangent vectors, an element in the Lie Algebra is generated, see also <a href="../algebra/#Base.rand-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O&lt;:AbstractGroupOperation, G&lt;:(AbstractLieGroup{var&quot;#s25&quot;, O, M} where {var&quot;#s25&quot;, M&lt;:ManifoldsBase.AbstractManifold{var&quot;#s25&quot;}})}}"><code>rand(::LieAlgebra; kwargs...)</code></a></p><p>For both cases, you can provide the type <span>$T$</span> for the tangent vector and/or point <span>$PT$</span>, if you want to generate a random point in a certain representation. For the in-place variants the type is inferred from <code>pX</code> and <code>X</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L1095-L1113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{AbstractLieGroup}" href="#Base.rand-Tuple{AbstractLieGroup}"><code>Base.rand</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand(::AbstractLieGroup; vector_at=nothing, œÉ::Real=1.0, kwargs...)
rand(::AbstractLieGroup, PT::Type; vector_at=nothing, œÉ::Real=1.0, kwargs...)
rand!(::LieAlgebra, T::Type; œÉ::Real=1.0, kwargs...)
rand!(::AbstractLieGroup, gX::PT; vector_at=nothing, œÉ::Real=1.0, kwargs...)
rand!(::LieAlgebra, X::T; œÉ::Real=1.0, kwargs...)</code></pre><p>Compute a random point or tangent vector on a Lie group.</p><p>For points this just means to generate a random point on the underlying manifold itself.</p><p>For tangent vectors, an element in the Lie Algebra is generated, see also <a href="../algebra/#Base.rand-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O&lt;:AbstractGroupOperation, G&lt;:(AbstractLieGroup{var&quot;#s25&quot;, O, M} where {var&quot;#s25&quot;, M&lt;:ManifoldsBase.AbstractManifold{var&quot;#s25&quot;}})}}"><code>rand(::LieAlgebra; kwargs...)</code></a></p><p>For both cases, you can provide the type <span>$T$</span> for the tangent vector and/or point <span>$PT$</span>, if you want to generate a random point in a certain representation. For the in-place variants the type is inferred from <code>pX</code> and <code>X</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L1091-L1109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.compose!-Tuple{AbstractLieGroup, Any, Any, Any}" href="#LieGroups.compose!-Tuple{AbstractLieGroup, Any, Any, Any}"><code>LieGroups.compose!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compose(G::AbstractLieGroup, g, h)
compose!(G::AbstractLieGroup, k, g, h)</code></pre><p>Perform the group operation <span>$g ‚àò h$</span> for two <span>$g, h ‚àà \mathcal G$</span> on the <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <code>G</code>. This can also be done in-place of <code>h</code>.</p><div class="admonition is-info" id="Info-62b31a52d2289aa6"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-62b31a52d2289aa6" title="Permalink"></a></header><div class="admonition-body"><p>This function also handles the case where <code>g</code> or/and <code>h</code> are the <a href="../operations/#LieGroups.Identity"><code>Identity</code></a><code>(G)</code>. Since this would lead to ambiguities when implementing a new group operations, this function calls <code>_compose</code> and <code>_compose!</code>, respectively, which is meant for the actual computation of group operations on (non-<a href="../operations/#LieGroups.Identity"><code>Identity</code></a>` but maybe its numerical representation) elements.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L247-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.compose-Tuple{AbstractLieGroup, Any, Any}" href="#LieGroups.compose-Tuple{AbstractLieGroup, Any, Any}"><code>LieGroups.compose</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compose(G::AbstractLieGroup, g, h)
compose!(G::AbstractLieGroup, k, g, h)</code></pre><p>Perform the group operation <span>$g ‚àò h$</span> for two <span>$g, h ‚àà \mathcal G$</span> on the <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <code>G</code>. This can also be done in-place of <code>h</code>.</p><div class="admonition is-info" id="Info-62b31a52d2289aa6"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-62b31a52d2289aa6" title="Permalink"></a></header><div class="admonition-body"><p>This function also handles the case where <code>g</code> or/and <code>h</code> are the <a href="../operations/#LieGroups.Identity"><code>Identity</code></a><code>(G)</code>. Since this would lead to ambiguities when implementing a new group operations, this function calls <code>_compose</code> and <code>_compose!</code>, respectively, which is meant for the actual computation of group operations on (non-<a href="../operations/#LieGroups.Identity"><code>Identity</code></a>` but maybe its numerical representation) elements.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L230-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.conjugate!-Tuple{AbstractLieGroup, Any, Any, Any}" href="#LieGroups.conjugate!-Tuple{AbstractLieGroup, Any, Any, Any}"><code>LieGroups.conjugate!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conjugate(G::AbstractLieGroup, g, h)
conjugate!(G::AbstractLieGroup, k, g, h)</code></pre><p>Compute the conjugation map <span>$c_g: \mathcal G ‚Üí \mathcal G$</span> given by <span>$c_g(h) = g‚àòh‚àòg^{-1}$</span>. This can be done in-place of <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L286-L292">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.conjugate-Tuple{AbstractLieGroup, Any, Any}" href="#LieGroups.conjugate-Tuple{AbstractLieGroup, Any, Any}"><code>LieGroups.conjugate</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conjugate(G::AbstractLieGroup, g, h)
conjugate!(G::AbstractLieGroup, k, g, h)</code></pre><p>Compute the conjugation map <span>$c_g: \mathcal G ‚Üí \mathcal G$</span> given by <span>$c_g(h) = g‚àòh‚àòg^{-1}$</span>. This can be done in-place of <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L279-L285">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.diff_conjugate!-Tuple{AbstractLieGroup, Vararg{Any, 4}}" href="#LieGroups.diff_conjugate!-Tuple{AbstractLieGroup, Vararg{Any, 4}}"><code>LieGroups.diff_conjugate!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diff_conjugate(G::AbstractLieGroup, g, h, X)
diff_conjugate!(G::AbstractLieGroup, Y, g, h, X)</code></pre><p>Compute the differential of the <a href="../../groups/circle_group/#LieGroups.conjugate-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, &lt;:Manifolds.Circle{‚Ñù}}, Any, Any}"><code>conjugate</code></a> <span>$c_g(h) = g‚àòh‚àòg^{-1}$</span> on the <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <code>G</code>. The operation can be performed in-place of <code>Y</code>.</p><p class="math-container">\[  \mathrm{d}(c_g(h))[X], \qquad X ‚àà \mathfrak g.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L344-L354">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.diff_conjugate-Tuple{AbstractLieGroup, Any, Any, Any}" href="#LieGroups.diff_conjugate-Tuple{AbstractLieGroup, Any, Any, Any}"><code>LieGroups.diff_conjugate</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diff_conjugate(G::AbstractLieGroup, g, h, X)
diff_conjugate!(G::AbstractLieGroup, Y, g, h, X)</code></pre><p>Compute the differential of the <a href="../../groups/circle_group/#LieGroups.conjugate-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, &lt;:Manifolds.Circle{‚Ñù}}, Any, Any}"><code>conjugate</code></a> <span>$c_g(h) = g‚àòh‚àòg^{-1}$</span> on the <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <code>G</code>. The operation can be performed in-place of <code>Y</code>.</p><p class="math-container">\[  \mathrm{d}(c_g(h))[X], \qquad X ‚àà \mathfrak g.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L337-L347">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.diff_inv!-Tuple{AbstractLieGroup, Any, Any, Any}" href="#LieGroups.diff_inv!-Tuple{AbstractLieGroup, Any, Any, Any}"><code>LieGroups.diff_inv!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diff_inv(G::AbstractLieGroup, g, X)
diff_inv!(G::AbstractLieGroup, Y, g, X)</code></pre><p>Compute the differential of the function <span>$Œπ_{\mathcal G}(g) = g^{-1}$</span>, where <span>$\mathrm{d}Œπ_{\mathcal G}(g): \mathfrak g ‚Üí \mathfrak g$</span>. This can be done in-place of <code>Y</code>. Note that we represent tangent vectors in the Lie algebra <span>$ùî§$</span>.</p><p>For example on matrix manifolds this means, we use <span>$X ‚àà ùî§$</span> and hence <span>$W = gX ‚àà T_g\mathcal G$</span>. The (classical) differential <span>$\mathrm{D}Œπ_{\mathcal G}(g): T_g\mathcal G ‚Üí T_{g^{-1}}\mathcal G$</span> reads</p><p class="math-container">\[  \mathrm{D}Œπ_{\mathcal G}(g)[W] = -g^{-1}Wg^{-1} = -Xg^{-1} = -g^{-1}(gXg^{-1}) = -g^{-1}\mathrm{Ad}(g)[X] = V ‚àà T_{g^{-1}}\mathcal G,\]</p><p>see e.g. [<a href="../../references/#Giles_2008">Gil08</a>]. To bring this back to the Lie algebra, we Write <span>$V = g^{-1}Y ‚àà T_{g^{-1}}\mathcal G$</span> for some <span>$Y ‚àà ùî§$</span> and obtain</p><p class="math-container">\[  \mathrm{d} Œπ_{\mathcal G}(g)[X] = -\mathrm{Ad}(g)[X] ‚àà ùî§,\]</p><p>where we use <span>$\mathrm{d}$</span> to denote the differential in the Lie algebra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L380-L404">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.diff_inv-Tuple{AbstractLieGroup, Any, Any}" href="#LieGroups.diff_inv-Tuple{AbstractLieGroup, Any, Any}"><code>LieGroups.diff_inv</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diff_inv(G::AbstractLieGroup, g, X)
diff_inv!(G::AbstractLieGroup, Y, g, X)</code></pre><p>Compute the differential of the function <span>$Œπ_{\mathcal G}(g) = g^{-1}$</span>, where <span>$\mathrm{d}Œπ_{\mathcal G}(g): \mathfrak g ‚Üí \mathfrak g$</span>. This can be done in-place of <code>Y</code>. Note that we represent tangent vectors in the Lie algebra <span>$ùî§$</span>.</p><p>For example on matrix manifolds this means, we use <span>$X ‚àà ùî§$</span> and hence <span>$W = gX ‚àà T_g\mathcal G$</span>. The (classical) differential <span>$\mathrm{D}Œπ_{\mathcal G}(g): T_g\mathcal G ‚Üí T_{g^{-1}}\mathcal G$</span> reads</p><p class="math-container">\[  \mathrm{D}Œπ_{\mathcal G}(g)[W] = -g^{-1}Wg^{-1} = -Xg^{-1} = -g^{-1}(gXg^{-1}) = -g^{-1}\mathrm{Ad}(g)[X] = V ‚àà T_{g^{-1}}\mathcal G,\]</p><p>see e.g. [<a href="../../references/#Giles_2008">Gil08</a>]. To bring this back to the Lie algebra, we Write <span>$V = g^{-1}Y ‚àà T_{g^{-1}}\mathcal G$</span> for some <span>$Y ‚àà ùî§$</span> and obtain</p><p class="math-container">\[  \mathrm{d} Œπ_{\mathcal G}(g)[X] = -\mathrm{Ad}(g)[X] ‚àà ùî§,\]</p><p>where we use <span>$\mathrm{d}$</span> to denote the differential in the Lie algebra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L373-L397">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.diff_left_compose!-Tuple{AbstractLieGroup, Vararg{Any, 4}}" href="#LieGroups.diff_left_compose!-Tuple{AbstractLieGroup, Vararg{Any, 4}}"><code>LieGroups.diff_left_compose!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diff_left_compose(G::AbstractLieGroup, g, h, X)
diff_left_compose!(G::AbstractLieGroup, Y, g, h, X)</code></pre><p>Compute the differential of the group operation <span>$g‚àòh$</span>, on an <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <code>G</code> with respect to its first (left) argument <code>g</code>.</p><p>Another interpretation is to consider a function where we do a fixed multiplication from the right with <code>h</code>. i..e. the right group multiplication function <span>$œÅ_h(g) = g‚àòh$</span> (where the <em>right</em> refers to the fixed argument <span>$h$</span>).</p><p>In this notation, this function computes the differential <span>$\mathrm{d}œÅ_h: ùî§ ‚Üí ùî§$</span>.</p><p>For example on matrix Lie groups this means that for <span>$X ‚àà ùî§$</span> we can start with <span>$W = gX ‚àà T_g\mathcal G$</span> and compute the (classical) differential <span>$\mathrm{D}œÅ_h(g): T_g\mathcal G ‚Üí T_{g‚àòh}\mathcal G$</span>.</p><p>It reads</p><p class="math-container">\[  \mathrm{D}œÅ_h(g)[W] = Wh = gXh = V ‚àà T_{g‚àòh}\mathcal G.\]</p><p>To obtain the Lie group differential <span>$\mathrm{d}œÅ_h(g)$</span> we have to ‚Äúpull back‚Äù <span>$V$</span> from the tangent space <span>$T_{g‚àòh}\mathcal G$</span> to the Lie algebra <span>$ùî§$</span>. We use the same identification, that we can write <span>$V = ghY ‚àà T_{g‚àòh}\mathcal G$</span>. This means in practice that with <span>$V = gXh = gh(h^{-1}Xh)$</span> differential reads</p><p class="math-container">\[\mathrm{d} œÅ_h(g)[X] = h^{-1}Xh = \mathrm{Ad}(h^{-1})[X] ‚àà ùî§,\]</p><p>where <span>$\mathrm{Ad}$</span> denotes the <a href="#Base.adjoint-Tuple{AbstractLieGroup, Any, Any}"><code>adjoint</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L426-L457">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.diff_left_compose-Tuple{AbstractLieGroup, Any, Any, Any}" href="#LieGroups.diff_left_compose-Tuple{AbstractLieGroup, Any, Any, Any}"><code>LieGroups.diff_left_compose</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diff_left_compose(G::AbstractLieGroup, g, h, X)
diff_left_compose!(G::AbstractLieGroup, Y, g, h, X)</code></pre><p>Compute the differential of the group operation <span>$g‚àòh$</span>, on an <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <code>G</code> with respect to its first (left) argument <code>g</code>.</p><p>Another interpretation is to consider a function where we do a fixed multiplication from the right with <code>h</code>. i..e. the right group multiplication function <span>$œÅ_h(g) = g‚àòh$</span> (where the <em>right</em> refers to the fixed argument <span>$h$</span>).</p><p>In this notation, this function computes the differential <span>$\mathrm{d}œÅ_h: ùî§ ‚Üí ùî§$</span>.</p><p>For example on matrix Lie groups this means that for <span>$X ‚àà ùî§$</span> we can start with <span>$W = gX ‚àà T_g\mathcal G$</span> and compute the (classical) differential <span>$\mathrm{D}œÅ_h(g): T_g\mathcal G ‚Üí T_{g‚àòh}\mathcal G$</span>.</p><p>It reads</p><p class="math-container">\[  \mathrm{D}œÅ_h(g)[W] = Wh = gXh = V ‚àà T_{g‚àòh}\mathcal G.\]</p><p>To obtain the Lie group differential <span>$\mathrm{d}œÅ_h(g)$</span> we have to ‚Äúpull back‚Äù <span>$V$</span> from the tangent space <span>$T_{g‚àòh}\mathcal G$</span> to the Lie algebra <span>$ùî§$</span>. We use the same identification, that we can write <span>$V = ghY ‚àà T_{g‚àòh}\mathcal G$</span>. This means in practice that with <span>$V = gXh = gh(h^{-1}Xh)$</span> differential reads</p><p class="math-container">\[\mathrm{d} œÅ_h(g)[X] = h^{-1}Xh = \mathrm{Ad}(h^{-1})[X] ‚àà ùî§,\]</p><p>where <span>$\mathrm{Ad}$</span> denotes the <a href="#Base.adjoint-Tuple{AbstractLieGroup, Any, Any}"><code>adjoint</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L415-L446">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.diff_right_compose!-Tuple{AbstractLieGroup, Vararg{Any, 4}}" href="#LieGroups.diff_right_compose!-Tuple{AbstractLieGroup, Vararg{Any, 4}}"><code>LieGroups.diff_right_compose!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diff_right_compose(G::AbstractLieGroup, g, h, X)
diff_right_compose!(G::AbstractLieGroup, Y, g, h, X)</code></pre><p>Compute the differential of the group operation <span>$g‚àòh$</span>, on an <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <code>G</code> with respect to its second (right) argument <code>h</code>.</p><p>Another interpretation is to consider a function where we do a fixed multiplication from the left with <code>g</code>. i..e. the left group multiplication function <span>$Œª_g(h) = g‚àòh$</span> (where the <em>left</em> refers to the fixed argument <span>$g$</span>.).</p><p>In this notation, this function <span>$\mathrm{d}Œª_g: ùî§ ‚Üí ùî§$</span>.</p><p>For example on matrix Lie groups this means that for <span>$X ‚àà ùî§$</span> we can start with <span>$W = hX ‚àà T_h\mathcal G$</span> and compute the (classical) differential <span>$\mathrm{D}Œª_g(h): T_h\mathcal G ‚Üí T_{g‚àòh}\mathcal G$</span>.</p><p>It reads</p><p class="math-container">\[  \mathrm{D}Œª_g(h)[W] = gW = ghX ‚àà T_{g‚àòh}\mathcal G.\]</p><p>To obtain the Lie group differential <span>$\mathrm{d}Œª_g(h)$</span> we have to multiply the result with <span>$(gh)^{-1}$</span> from the left and move from <span>$W$</span> to <span>$X$</span>. Then the differential just simplifies to the identity. It reads</p><p class="math-container">\[\mathrm{d} Œª_g(h)[X] = X ‚àà ùî§.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L469-L496">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.diff_right_compose-Tuple{AbstractLieGroup, Any, Any, Any}" href="#LieGroups.diff_right_compose-Tuple{AbstractLieGroup, Any, Any, Any}"><code>LieGroups.diff_right_compose</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diff_right_compose(G::AbstractLieGroup, g, h, X)
diff_right_compose!(G::AbstractLieGroup, Y, g, h, X)</code></pre><p>Compute the differential of the group operation <span>$g‚àòh$</span>, on an <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <code>G</code> with respect to its second (right) argument <code>h</code>.</p><p>Another interpretation is to consider a function where we do a fixed multiplication from the left with <code>g</code>. i..e. the left group multiplication function <span>$Œª_g(h) = g‚àòh$</span> (where the <em>left</em> refers to the fixed argument <span>$g$</span>.).</p><p>In this notation, this function <span>$\mathrm{d}Œª_g: ùî§ ‚Üí ùî§$</span>.</p><p>For example on matrix Lie groups this means that for <span>$X ‚àà ùî§$</span> we can start with <span>$W = hX ‚àà T_h\mathcal G$</span> and compute the (classical) differential <span>$\mathrm{D}Œª_g(h): T_h\mathcal G ‚Üí T_{g‚àòh}\mathcal G$</span>.</p><p>It reads</p><p class="math-container">\[  \mathrm{D}Œª_g(h)[W] = gW = ghX ‚àà T_{g‚àòh}\mathcal G.\]</p><p>To obtain the Lie group differential <span>$\mathrm{d}Œª_g(h)$</span> we have to multiply the result with <span>$(gh)^{-1}$</span> from the left and move from <span>$W$</span> to <span>$X$</span>. Then the differential just simplifies to the identity. It reads</p><p class="math-container">\[\mathrm{d} Œª_g(h)[X] = X ‚àà ùî§.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L457-L484">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.identity_element!-Tuple{AbstractLieGroup, Any}" href="#LieGroups.identity_element!-Tuple{AbstractLieGroup, Any}"><code>LieGroups.identity_element!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">identity_element(G::AbstractLieGroup)
identity_element(G::AbstractLieGroup, T)
identity_element!(G::AbstractLieGroup, e::T)</code></pre><p>Return a point representation of the <a href="../operations/#LieGroups.Identity"><code>Identity</code></a> on the <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <code>G</code>. By default this representation is the default array or number representation. If there exist several representations, the type <code>T</code> can be used to distinguish between them, and it should be provided for both the <a href="#LieGroups.AbstractLieGroupPoint"><code>AbstractLieGroupPoint</code></a> as well as the <a href="#LieGroups.AbstractLieAlgebraTangentVector"><code>AbstractLieAlgebraTangentVector</code></a> if they differ, since maybe only one of these types might be available for the second signature.</p><p>It returns the corresponding default representation of <span>$e$</span> as a point on <code>G</code>. This can be performed in-place of <code>e</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L601-L614">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.identity_element-Tuple{AbstractLieGroup}" href="#LieGroups.identity_element-Tuple{AbstractLieGroup}"><code>LieGroups.identity_element</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">identity_element(G::AbstractLieGroup)
identity_element(G::AbstractLieGroup, T)
identity_element!(G::AbstractLieGroup, e::T)</code></pre><p>Return a point representation of the <a href="../operations/#LieGroups.Identity"><code>Identity</code></a> on the <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <code>G</code>. By default this representation is the default array or number representation. If there exist several representations, the type <code>T</code> can be used to distinguish between them, and it should be provided for both the <a href="#LieGroups.AbstractLieGroupPoint"><code>AbstractLieGroupPoint</code></a> as well as the <a href="#LieGroups.AbstractLieAlgebraTangentVector"><code>AbstractLieAlgebraTangentVector</code></a> if they differ, since maybe only one of these types might be available for the second signature.</p><p>It returns the corresponding default representation of <span>$e$</span> as a point on <code>G</code>. This can be performed in-place of <code>e</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L594-L607">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.inv_left_compose!-Tuple{AbstractLieGroup, Any, Any, Any}" href="#LieGroups.inv_left_compose!-Tuple{AbstractLieGroup, Any, Any, Any}"><code>LieGroups.inv_left_compose!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inv_left_compose(G::AbstractLieGroup, g, h)
inv_left_compose!(G::AbstractLieGroup, k, g, h)</code></pre><p>Compute the inverse of the left group operation <span>$Œª_g(h) = g‚àòh$</span>, on the <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <code>G</code>, that is, compute <span>$Œª_g^{-1}(h) = g^{-1}‚àòh$</span>. This can be done in-place of <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L663-L670">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.inv_left_compose-Tuple{AbstractLieGroup, Any, Any}" href="#LieGroups.inv_left_compose-Tuple{AbstractLieGroup, Any, Any}"><code>LieGroups.inv_left_compose</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inv_left_compose(G::AbstractLieGroup, g, h)
inv_left_compose!(G::AbstractLieGroup, k, g, h)</code></pre><p>Compute the inverse of the left group operation <span>$Œª_g(h) = g‚àòh$</span>, on the <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <code>G</code>, that is, compute <span>$Œª_g^{-1}(h) = g^{-1}‚àòh$</span>. This can be done in-place of <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L656-L663">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.inv_right_compose!-Tuple{AbstractLieGroup, Any, Any, Any}" href="#LieGroups.inv_right_compose!-Tuple{AbstractLieGroup, Any, Any, Any}"><code>LieGroups.inv_right_compose!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inv_right_compose(G::AbstractLieGroup, h, g)
inv_right_compose!(G::AbstractLieGroup, k, h, g)</code></pre><p>Compute the inverse of the right group operation <span>$œÅ_g(h) = h‚àòg$</span>, on the <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <code>G</code>, that is compute <span>$œÅ_g^{-1}(h) = h‚àòg^{-1}$</span>. This can be done in-place of <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L685-L692">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.inv_right_compose-Tuple{AbstractLieGroup, Any, Any}" href="#LieGroups.inv_right_compose-Tuple{AbstractLieGroup, Any, Any}"><code>LieGroups.inv_right_compose</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inv_right_compose(G::AbstractLieGroup, h, g)
inv_right_compose!(G::AbstractLieGroup, k, h, g)</code></pre><p>Compute the inverse of the right group operation <span>$œÅ_g(h) = h‚àòg$</span>, on the <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <code>G</code>, that is compute <span>$œÅ_g^{-1}(h) = h‚àòg^{-1}$</span>. This can be done in-place of <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L678-L685">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.is_identity-Tuple{AbstractLieGroup, Any}" href="#LieGroups.is_identity-Tuple{AbstractLieGroup, Any}"><code>LieGroups.is_identity</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_identity(G::AbstractLieGroup, q; kwargs...)</code></pre><p>Check whether <code>q</code> is the identity on the <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <span>$\mathcal G$</span>. This means it is either the <a href="../operations/#LieGroups.Identity"><code>Identity</code></a><code>{O}</code> with the respect to the corresponding <a href="../operations/#LieGroups.AbstractGroupOperation"><code>AbstractGroupOperation</code></a> <code>O</code>, or (approximately) the correct point representation.</p><p><strong>See also</strong></p><p><a href="#LieGroups.identity_element-Tuple{AbstractLieGroup}"><code>identity_element</code></a>, <a href="#LieGroups.identity_element!-Tuple{AbstractLieGroup, Any}"><code>identity_element!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L730-L740">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.jacobian_conjugate" href="#LieGroups.jacobian_conjugate"><code>LieGroups.jacobian_conjugate</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jacobian_conjugate(G::AbstractLieGroup, g, h; basis::AbstractBasis=DefaultLieAlgebraOrthogonalBasis(); X=zero_vector(LieAlgebar(G)))
jacobian_conjugate!(G::AbstractLieGroup, J, g, h; basis::AbstractBasis=DefaultLieAlgebraOrthogonalBasis(); X=zero_vector(LieAlgebar(G)))</code></pre><p>Compute the Jacobian of the <a href="../../groups/circle_group/#LieGroups.conjugate-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, &lt;:Manifolds.Circle{‚Ñù}}, Any, Any}"><code>conjugate</code></a> <span>$c_g(h) = g‚àòh‚àòg^{-1}$</span>, with respect to an <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.AbstractBasis"><code>AbstractBasis</code></a> of the <a href="../algebra/#LieGroups.LieAlgebra"><code>LieAlgebra</code></a>.</p><p>A default is implemented using <a href="../../groups/circle_group/#LieGroups.diff_conjugate-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, &lt;:Manifolds.Circle{‚Ñù}}, Any, Any, Number}"><code>diff_conjugate</code></a> <span>$\mathrm{d}(c_g(h))[X]$</span>: the <span>$j$</span>th column of of the Jacobian matrix <span>$J$</span> are given by the coefficients of the tangent vector <span>$\mathrm{d}(c_g(h))[X_j]$</span> with respect to the basis <span>$B$</span>, where <span>$X_j$</span> is the <span>$j$</span>th basis vector of <span>$B$</span>.</p><div class="admonition is-info" id="Note-e07833bc53bdc124"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-e07833bc53bdc124" title="Permalink"></a></header><div class="admonition-body"><p>For the case that <code>h</code> is the <a href="../operations/#LieGroups.Identity"><code>Identity</code></a> and the relation of <span>$\mathrm{d}(c_g(h))[X]$</span> to the <a href="#Base.adjoint-Tuple{AbstractLieGroup, Any, Any}"><code>adjoint</code></a> <span>$\mathrm{Ad}(g)$</span>, the Jacobian then sometimes called ‚Äúadjoint matrix‚Äù, e.g. in [<a href="../../references/#SolaDerayAtchuthan_2021">SDA21</a>], when choosing as a basis the <a href="../algebra/#LieGroups.DefaultLieAlgebraOrthogonalBasis"><code>DefaultLieAlgebraOrthogonalBasis</code></a><code>()</code> that is used for <a href="../../groups/special_galilean_group/#ManifoldsBase.hat-Tuple{ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, SpecialGalileanGroup{ManifoldsBase.TypeParameter{Tuple{3}}, LeftSemidirectProductGroupOperation{LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, ProductGroupOperation{Tuple{AdditionGroupOperation, AdditionGroupOperation}}, LieGroups.RotationBoostAction, ActionActsOnRight}, ManifoldsBase.ProductManifold{‚Ñù, Tuple{ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{‚Ñù, ManifoldsBase.TypeParameter{Tuple{3}}}}}, ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{‚Ñù, ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{‚Ñù, ManifoldsBase.TypeParameter{Tuple{1}}}}}}}}, Identity{LeftSemidirectProductGroupOperation{LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, ProductGroupOperation{Tuple{AdditionGroupOperation, AdditionGroupOperation}}, LieGroups.RotationBoostAction, ActionActsOnRight}}}, Any}"><code>hat</code></a> and <a href="../../groups/special_galilean_group/#ManifoldsBase.vee-Tuple{ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, SpecialGalileanGroup{ManifoldsBase.TypeParameter{Tuple{3}}, LeftSemidirectProductGroupOperation{LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, ProductGroupOperation{Tuple{AdditionGroupOperation, AdditionGroupOperation}}, LieGroups.RotationBoostAction, ActionActsOnRight}, ManifoldsBase.ProductManifold{‚Ñù, Tuple{ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{‚Ñù, ManifoldsBase.TypeParameter{Tuple{3}}}}}, ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{‚Ñù, ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{‚Ñù, ManifoldsBase.TypeParameter{Tuple{1}}}}}}}}, Identity{LeftSemidirectProductGroupOperation{LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, ProductGroupOperation{Tuple{AdditionGroupOperation, AdditionGroupOperation}}, LieGroups.RotationBoostAction, ActionActsOnRight}}}, Any}"><code>vee</code></a>.</p></div></div><p><strong>Keyword arguments</strong></p><ul><li><code>X=zero_vector(LieAlgebra(G))</code> pass an interims memory to store the Lie algebra tangent vector in.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L859-L880">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.jacobian_conjugate!" href="#LieGroups.jacobian_conjugate!"><code>LieGroups.jacobian_conjugate!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jacobian_conjugate(G::AbstractLieGroup, g, h; basis::AbstractBasis=DefaultLieAlgebraOrthogonalBasis(); X=zero_vector(LieAlgebar(G)))
jacobian_conjugate!(G::AbstractLieGroup, J, g, h; basis::AbstractBasis=DefaultLieAlgebraOrthogonalBasis(); X=zero_vector(LieAlgebar(G)))</code></pre><p>Compute the Jacobian of the <a href="../../groups/circle_group/#LieGroups.conjugate-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, &lt;:Manifolds.Circle{‚Ñù}}, Any, Any}"><code>conjugate</code></a> <span>$c_g(h) = g‚àòh‚àòg^{-1}$</span>, with respect to an <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.AbstractBasis"><code>AbstractBasis</code></a> of the <a href="../algebra/#LieGroups.LieAlgebra"><code>LieAlgebra</code></a>.</p><p>A default is implemented using <a href="../../groups/circle_group/#LieGroups.diff_conjugate-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, &lt;:Manifolds.Circle{‚Ñù}}, Any, Any, Number}"><code>diff_conjugate</code></a> <span>$\mathrm{d}(c_g(h))[X]$</span>: the <span>$j$</span>th column of of the Jacobian matrix <span>$J$</span> are given by the coefficients of the tangent vector <span>$\mathrm{d}(c_g(h))[X_j]$</span> with respect to the basis <span>$B$</span>, where <span>$X_j$</span> is the <span>$j$</span>th basis vector of <span>$B$</span>.</p><div class="admonition is-info" id="Note-e07833bc53bdc124"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-e07833bc53bdc124" title="Permalink"></a></header><div class="admonition-body"><p>For the case that <code>h</code> is the <a href="../operations/#LieGroups.Identity"><code>Identity</code></a> and the relation of <span>$\mathrm{d}(c_g(h))[X]$</span> to the <a href="#Base.adjoint-Tuple{AbstractLieGroup, Any, Any}"><code>adjoint</code></a> <span>$\mathrm{Ad}(g)$</span>, the Jacobian then sometimes called ‚Äúadjoint matrix‚Äù, e.g. in [<a href="../../references/#SolaDerayAtchuthan_2021">SDA21</a>], when choosing as a basis the <a href="../algebra/#LieGroups.DefaultLieAlgebraOrthogonalBasis"><code>DefaultLieAlgebraOrthogonalBasis</code></a><code>()</code> that is used for <a href="../../groups/special_galilean_group/#ManifoldsBase.hat-Tuple{ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, SpecialGalileanGroup{ManifoldsBase.TypeParameter{Tuple{3}}, LeftSemidirectProductGroupOperation{LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, ProductGroupOperation{Tuple{AdditionGroupOperation, AdditionGroupOperation}}, LieGroups.RotationBoostAction, ActionActsOnRight}, ManifoldsBase.ProductManifold{‚Ñù, Tuple{ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{‚Ñù, ManifoldsBase.TypeParameter{Tuple{3}}}}}, ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{‚Ñù, ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{‚Ñù, ManifoldsBase.TypeParameter{Tuple{1}}}}}}}}, Identity{LeftSemidirectProductGroupOperation{LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, ProductGroupOperation{Tuple{AdditionGroupOperation, AdditionGroupOperation}}, LieGroups.RotationBoostAction, ActionActsOnRight}}}, Any}"><code>hat</code></a> and <a href="../../groups/special_galilean_group/#ManifoldsBase.vee-Tuple{ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, SpecialGalileanGroup{ManifoldsBase.TypeParameter{Tuple{3}}, LeftSemidirectProductGroupOperation{LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, ProductGroupOperation{Tuple{AdditionGroupOperation, AdditionGroupOperation}}, LieGroups.RotationBoostAction, ActionActsOnRight}, ManifoldsBase.ProductManifold{‚Ñù, Tuple{ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{‚Ñù, ManifoldsBase.TypeParameter{Tuple{3}}}}}, ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{‚Ñù, ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{‚Ñù, ManifoldsBase.TypeParameter{Tuple{1}}}}}}}}, Identity{LeftSemidirectProductGroupOperation{LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, ProductGroupOperation{Tuple{AdditionGroupOperation, AdditionGroupOperation}}, LieGroups.RotationBoostAction, ActionActsOnRight}}}, Any}"><code>vee</code></a>.</p></div></div><p><strong>Keyword arguments</strong></p><ul><li><code>X=zero_vector(LieAlgebra(G))</code> pass an interims memory to store the Lie algebra tangent vector in.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L868-L889">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.jacobian_exp" href="#LieGroups.jacobian_exp"><code>LieGroups.jacobian_exp</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jacobian_exp(G::AbstractLieGroup, g, X, b)
jacobian_exp!(G::AbstractLieGroup, J, g, X, b)</code></pre><p>Compute the Jacobian of the <a href="../../groups/circle_group/#Base.exp-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, &lt;:Manifolds.Circle{‚Ñù}}, Number}"><code>exp</code></a> <span>$\exp_g(X)$</span> with respect to an <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.AbstractBasis"><code>AbstractBasis</code></a> of the <a href="../algebra/#LieGroups.LieAlgebra"><code>LieAlgebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L898-L904">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.jacobian_exp!" href="#LieGroups.jacobian_exp!"><code>LieGroups.jacobian_exp!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jacobian_exp(G::AbstractLieGroup, g, X, b)
jacobian_exp!(G::AbstractLieGroup, J, g, X, b)</code></pre><p>Compute the Jacobian of the <a href="../../groups/circle_group/#Base.exp-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, &lt;:Manifolds.Circle{‚Ñù}}, Number}"><code>exp</code></a> <span>$\exp_g(X)$</span> with respect to an <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases/#ManifoldsBase.AbstractBasis"><code>AbstractBasis</code></a> of the <a href="../algebra/#LieGroups.LieAlgebra"><code>LieAlgebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L907-L913">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.point_type-Tuple{AbstractLieGroup, Type}" href="#LieGroups.point_type-Tuple{AbstractLieGroup, Type}"><code>LieGroups.point_type</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">point_type(G::AbstractLieGroup, tangent_vector_type::Type)</code></pre><p>Change <code>tangent_vector_type</code> that is a type of tangent vector type on Lie group <code>G</code> to its matching type for representing points.</p><p>By default both these types are assumed to be identical.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L1023-L1030">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.pull_back_tangent!-Tuple{AbstractLieGroup, Any, Any, Any}" href="#LieGroups.pull_back_tangent!-Tuple{AbstractLieGroup, Any, Any, Any}"><code>LieGroups.pull_back_tangent!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pull_back_tangent(G::AnstractLieGroup, g, X; kwargs...)
pull_back_tangent!(G::AbstractLiegroup, Y, g, X; kwargs...)</code></pre><p>Given a tangent vector <code>X</code> on the tangent space at <code>g</code> interpreted as the one on the manifold, this function pulls it back to the <a href="../algebra/#LieGroups.LieAlgebra"><code>LieAlgebra</code></a>.</p><p>By default this function falls back to calling <a href="../../groups/circle_group/#LieGroups.diff_left_compose-Tuple{LieGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, &lt;:Manifolds.Circle{‚ÑÇ}}, Number, Any, Number}"><code>diff_left_compose</code></a>, but compared to that function, this function also takes care about the change of representation.</p><p>For example if a default representation for tangent vectors on a manifold is also the Lie algebra, then this function simplifies to the identity. This is for example the case for the <a href="../../groups/special_orthogonal_group/#LieGroups.SpecialOrthogonalGroup"><code>SpecialOrthogonalGroup</code></a> and its <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/rotations/#Manifolds.Rotations"><code>Rotations</code></a> manifold.</p><p><strong>Keyword argument</strong></p><ul><li><code>e = identity_element(G, typeof(g))</code> ‚Äì if you have a memory available to store an identity point in, you can pass that memory here.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L1059-L1076">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.pull_back_tangent-Tuple{AbstractLieGroup, Any, Any}" href="#LieGroups.pull_back_tangent-Tuple{AbstractLieGroup, Any, Any}"><code>LieGroups.pull_back_tangent</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pull_back_tangent(G::AnstractLieGroup, g, X; kwargs...)
pull_back_tangent!(G::AbstractLiegroup, Y, g, X; kwargs...)</code></pre><p>Given a tangent vector <code>X</code> on the tangent space at <code>g</code> interpreted as the one on the manifold, this function pulls it back to the <a href="../algebra/#LieGroups.LieAlgebra"><code>LieAlgebra</code></a>.</p><p>By default this function falls back to calling <a href="../../groups/circle_group/#LieGroups.diff_left_compose-Tuple{LieGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, &lt;:Manifolds.Circle{‚ÑÇ}}, Number, Any, Number}"><code>diff_left_compose</code></a>, but compared to that function, this function also takes care about the change of representation.</p><p>For example if a default representation for tangent vectors on a manifold is also the Lie algebra, then this function simplifies to the identity. This is for example the case for the <a href="../../groups/special_orthogonal_group/#LieGroups.SpecialOrthogonalGroup"><code>SpecialOrthogonalGroup</code></a> and its <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/rotations/#Manifolds.Rotations"><code>Rotations</code></a> manifold.</p><p><strong>Keyword argument</strong></p><ul><li><code>e = identity_element(G, typeof(g))</code> ‚Äì if you have a memory available to store an identity point in, you can pass that memory here.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L1052-L1069">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.push_forward_tangent!-Tuple{AbstractLieGroup, Any, Any, Any}" href="#LieGroups.push_forward_tangent!-Tuple{AbstractLieGroup, Any, Any, Any}"><code>LieGroups.push_forward_tangent!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">push_forward_tangent(G::AnstractLieGroup, g, X)
push_forward_tangent!(G::AbstractLiegroup, Y, g, X)</code></pre><p>Given a Lie algebra vector <code>X</code> on the <a href="../algebra/#LieGroups.LieAlgebra"><code>LieAlgebra</code></a>, this function pushes the vector forward to the tangent space at <code>g</code> interpreted as the one on the manifold.</p><p>By default this function falls back to calling <a href="../../groups/circle_group/#LieGroups.diff_left_compose-Tuple{LieGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, &lt;:Manifolds.Circle{‚ÑÇ}}, Number, Any, Number}"><code>diff_left_compose</code></a>, but compared to that function, this function also takes care about the change of representation.</p><p>For example if a default representation for tangent vectors on a manifold is also the Lie algebra, then this function simplifies to the identity. This is for example the case for the <a href="../../groups/special_orthogonal_group/#LieGroups.SpecialOrthogonalGroup"><code>SpecialOrthogonalGroup</code></a> and its <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/rotations/#Manifolds.Rotations"><code>Rotations</code></a> manifold.</p><p><strong>Keyword argument</strong></p><ul><li><code>e = identity_element(G, typeof(g))</code> ‚Äì if you have a memory available to store an identity point in, you can pass that memory here.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L1088-L1105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.push_forward_tangent-Tuple{AbstractLieGroup, Any, Any}" href="#LieGroups.push_forward_tangent-Tuple{AbstractLieGroup, Any, Any}"><code>LieGroups.push_forward_tangent</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">push_forward_tangent(G::AnstractLieGroup, g, X)
push_forward_tangent!(G::AbstractLiegroup, Y, g, X)</code></pre><p>Given a Lie algebra vector <code>X</code> on the <a href="../algebra/#LieGroups.LieAlgebra"><code>LieAlgebra</code></a>, this function pushes the vector forward to the tangent space at <code>g</code> interpreted as the one on the manifold.</p><p>By default this function falls back to calling <a href="../../groups/circle_group/#LieGroups.diff_left_compose-Tuple{LieGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, &lt;:Manifolds.Circle{‚ÑÇ}}, Number, Any, Number}"><code>diff_left_compose</code></a>, but compared to that function, this function also takes care about the change of representation.</p><p>For example if a default representation for tangent vectors on a manifold is also the Lie algebra, then this function simplifies to the identity. This is for example the case for the <a href="../../groups/special_orthogonal_group/#LieGroups.SpecialOrthogonalGroup"><code>SpecialOrthogonalGroup</code></a> and its <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/rotations/#Manifolds.Rotations"><code>Rotations</code></a> manifold.</p><p><strong>Keyword argument</strong></p><ul><li><code>e = identity_element(G, typeof(g))</code> ‚Äì if you have a memory available to store an identity point in, you can pass that memory here.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L1081-L1098">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.adjoint!-Tuple{AbstractLieGroup, Any, Any, Any}" href="#LinearAlgebra.adjoint!-Tuple{AbstractLieGroup, Any, Any, Any}"><code>LinearAlgebra.adjoint!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjoint(G::AbstractLieGroup, g, X)
adjoint!(G::AbstractLieGroup, Y, g, X)</code></pre><p>Compute the adjoint <span>$\mathrm{Ad}(g): \mathfrak g ‚Üí \mathfrak g$</span>, which is defined as the differential <a href="../../groups/circle_group/#LieGroups.diff_conjugate-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, &lt;:Manifolds.Circle{‚Ñù}}, Any, Any, Number}"><code>diff_conjugate</code></a> of the <a href="../../groups/circle_group/#LieGroups.conjugate-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, &lt;:Manifolds.Circle{‚Ñù}}, Any, Any}"><code>conjugate</code></a> <span>$c_g(h) = g‚àòh‚àòg^{-1}$</span> evaluated at the <a href="../operations/#LieGroups.Identity"><code>Identity</code></a> <span>$h=\mathrm{e}$</span>. The operation can be performed in-place of <code>Y</code>.</p><p class="math-container">\[  \mathrm{Ad}(g)[X] = \mathrm{d} c_g(\mathrm{e}) [X], \qquad X ‚àà \mathfrak g.\]</p><p>see [<a href="../../references/#HilgertNeeb_2012">HN12</a>, Section 9.2.3].</p><p>On matrix Lie groups the adjoint reads <span>$\mathrm{Ad}(g)[X] = gXg^{-1}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L189-L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manifolds.inv!-Tuple{AbstractLieGroup, Any, Any}" href="#Manifolds.inv!-Tuple{AbstractLieGroup, Any, Any}"><code>Manifolds.inv!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inv(G::AbstractLieGroup, g)
inv!(G::AbstractLieGroup, h, g)</code></pre><p>Compute the inverse group element <span>$g^{-1}$</span> with respect to the <a href="../operations/#LieGroups.AbstractGroupOperation"><code>AbstractGroupOperation</code></a> <span>$‚àò$</span> on the <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <span>$\mathcal G$</span>, that is, return the unique element <span>$h=g^{-1}$</span> such that <span>$h‚àòg=\mathrm{e}$</span>, where <span>$\mathrm{e}$</span> denotes the <a href="../operations/#LieGroups.Identity"><code>Identity</code></a>.</p><p>This can be done in-place of <code>h</code>, without side effects, that is you can do <code>inv!(G, g, g)</code>.</p><div class="admonition is-info" id="Info-f51f2420db92deaf"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-f51f2420db92deaf" title="Permalink"></a></header><div class="admonition-body"><p>This function also handles the case where <code>g</code> is the <a href="../operations/#LieGroups.Identity"><code>Identity</code></a><code>(G)</code>. Since this would lead to ambiguities when implementing a new group operations, this function calls <code>_inv</code> and <code>_inv!</code>, respectively, which is meant for the actual computation of group operations on (non-<a href="../operations/#LieGroups.Identity"><code>Identity</code></a>` but maybe its numerical representation) elements.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L631-L646">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.base_manifold-Tuple{AbstractLieGroup}" href="#ManifoldsBase.base_manifold-Tuple{AbstractLieGroup}"><code>ManifoldsBase.base_manifold</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">base_manifold(G::AbstractLieGroup)</code></pre><p>Return the manifold stored within the <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L195-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.exp!-Tuple{AbstractLieGroup, Any, Any, Any}" href="#ManifoldsBase.exp!-Tuple{AbstractLieGroup, Any, Any, Any}"><code>ManifoldsBase.exp!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exp(G::AbstractLieGroup, g, X)
exp!(G::AbstractLieGroup, h, g, X)</code></pre><p>Compute the Lie group exponential map for <span>$g‚àà\mathcal G$</span> and <span>$X‚àà\mathfrak g$</span>, where <span>$\mathfrak g$</span> denotes the <a href="../algebra/#LieGroups.LieAlgebra"><code>LieAlgebra</code></a> of <span>$\mathcal G$</span>. It is given by</p><p class="math-container">\[\exp_g X = g‚àò\exp_{\mathcal G}(X)\]</p><p>where <code>X</code> can be scaled by <code>t</code>, the computation can be performed in-place of <code>h</code>, and <span>$\exp_{\mathcal G}$</span> denotes the  <a href="../../groups/circle_group/#Base.exp-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, &lt;:Manifolds.Circle{‚Ñù}}, Number}">Lie group exponential function</a>.</p><p>If <code>g</code> is the <a href="../operations/#LieGroups.Identity"><code>Identity</code></a> the <a href="../../groups/circle_group/#Base.exp-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, &lt;:Manifolds.Circle{‚Ñù}}, Number}">Lie group exponential function</a> <span>$\exp_{\mathcal G}$</span> is computed directly. Implementing the Lie group exponential function introduces a default implementation with the formula above.</p><div class="admonition is-info" id="Note-ab5fdb94eee10cc4"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ab5fdb94eee10cc4" title="Permalink"></a></header><div class="admonition-body"><p>The Lie group exponential map is usually different from the exponential map with respect to the metric of the underlying Riemannian manifold <span>$\mathcal M$</span>. To access the (Riemannian) exponential map, use <code>exp(</code><a href="../actions/#ManifoldsBase.base_manifold-Tuple{GroupAction}"><code>base_manifold</code></a><code>(G), g, X)</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L499-L521">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.exp!-Tuple{AbstractLieGroup, Any, Any}" href="#ManifoldsBase.exp!-Tuple{AbstractLieGroup, Any, Any}"><code>ManifoldsBase.exp!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exp(G::AbstractLieGroup, X::T)
exp!(G::AbstractLieGroup, g, X)</code></pre><p>Compute the (Lie group) exponential function</p><p class="math-container">\[\exp_{\mathcal G}: \mathfrak g ‚Üí \mathcal G,\qquad \exp_{\mathcal G}(X) = Œ≥_X(1),\]</p><p>where <span>$Œ≥_X$</span> is the unique solution of the initial value problem</p><p class="math-container">\[Œ≥(0) = \mathrm{e}, \quad Œ≥&#39;(s) = Œ≥(s)‚ãÖX.\]</p><p>See also [<a href="../../references/#HilgertNeeb_2012">HN12</a>, Definition 9.2.2]. On matrix Lie groups this is the same as the <a href="https://en.wikipedia.org/wiki/Matrix_exponential">matrix exponential</a>.</p><p>The computation can be performed in-place of <code>g</code>.</p><div class="admonition is-info" id="Naming-convention-fd2cfc901bc6a35"><header class="admonition-header">Naming convention<a class="admonition-anchor" href="#Naming-convention-fd2cfc901bc6a35" title="Permalink"></a></header><div class="admonition-body"><p>There are at least two different objects usually called ‚Äúexponential‚Äù that need to be distinguished</p><ul><li>the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.exp-Tuple%7BAbstractManifold%2C%20Any%2C%20Any%7D">(Riemannian) exponential map</a> <code>exp(M, p, X)</code> from <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/"><code>ManifoldsBase.jl</code></a>. This can be accessed here using <code>exp(base_manifold(G), p, X)</code></li><li>the exponential map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric <code>exp(G, g, X)</code>, which we use as a default within this package</li><li>the (matrix/Lie group) exponential function <code>exp(G, g)</code> which agrees with the previous one for <code>g</code> being the identity there.</li></ul></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L548-L576">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.inverse_retract-Tuple{AbstractLieGroup, Any, Any, BaseManifoldInverseRetraction}" href="#ManifoldsBase.inverse_retract-Tuple{AbstractLieGroup, Any, Any, BaseManifoldInverseRetraction}"><code>ManifoldsBase.inverse_retract</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inverse_retract(G::AbstractLieGroup, g, h, m::BaseManifoldInverseRetraction)</code></pre><p>Compute the inverse retraction of <code>g</code> and <code>h</code> on the <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <code>G</code> by using an inverse retraction on the underlying manifold and pulling the result back to the Lie algebra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L692-L697">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.is_point-Tuple{AbstractLieGroup, Any}" href="#ManifoldsBase.is_point-Tuple{AbstractLieGroup, Any}"><code>ManifoldsBase.is_point</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_point(G::AbstractLieGroup, g; kwargs...)</code></pre><p>Check whether <code>g</code> is a valid point on the Lie Group <code>G</code>. This falls back to checking whether <code>g</code> is a valid point on the <a href="../actions/#ManifoldsBase.base_manifold-Tuple{GroupAction}"><code>base_manifold</code></a><code>G</code>. unless <code>g</code> is an <a href="../operations/#LieGroups.Identity"><code>Identity</code></a>. Then, it is checked whether it is the identity element corresponding to <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L764-L771">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.log!-Tuple{AbstractLieGroup, Any, Any, Any}" href="#ManifoldsBase.log!-Tuple{AbstractLieGroup, Any, Any, Any}"><code>ManifoldsBase.log!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">log(G::AbstractLieGroup, g, h)
log!(G::AbstractLieGroup, X, g, h)</code></pre><p>Compute the Lie group logarithmic map <span>$\log_g: \mathcal G ‚Üí \mathfrak g$</span>, where <span>$\mathfrak g$</span> denotes the <a href="../algebra/#LieGroups.LieAlgebra"><code>LieAlgebra</code></a> of <span>$\mathcal G$</span>. It is given by</p><p class="math-container">\[\log_g h = \log_{\mathcal G}(g^{-1}‚àòh)\]</p><p>where <span>$\log_{\mathcal G}$</span> denotes the <a href="#Base.log-Tuple{AbstractLieGroup, Any}">Lie group logarithmic function</a> The computation can be performed in-place of <code>X</code>.</p><div class="admonition is-info" id="Naming-convention-4ae1f24b6f1ae628"><header class="admonition-header">Naming convention<a class="admonition-anchor" href="#Naming-convention-4ae1f24b6f1ae628" title="Permalink"></a></header><div class="admonition-body"><p>There are at least two different objects usually called ‚Äúlogarithm‚Äù that need to be distinguished</p><ul><li>the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.log-Tuple%7BAbstractManifold%2C%20Any%2C%20Any%7D">(Riemannian) logarithmic map</a> <code>log(M, p, X)</code> from <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/"><code>ManifoldsBase.jl</code></a></li><li>the exponential map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric <code>exp(G, g, X)</code>, which we use as a default within this package</li><li>the (matrix/Lie group) exponential function <code>exp(G, g)</code> which agrees with the previous one for <code>g</code> being the identity there.</li></ul></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L943-L964">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.log!-Tuple{AbstractLieGroup, Any, Any}" href="#ManifoldsBase.log!-Tuple{AbstractLieGroup, Any, Any}"><code>ManifoldsBase.log!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">log(G::AbstractLieGroup, g, h)
log(G::AbstractLieGroup, g)
log(G::AbstractLieGroup, g::Identity, T)
log!(G::AbstractLieGroup, X::T, g)</code></pre><p>Compute the (Lie group) logarithmic function <span>$\log_{\mathcal G}: \mathcal G ‚Üí \mathfrak g$</span>, which is the inverse of the <a href="#Base.exp-Tuple{AbstractLieGroup, Any}">Lie group exponential function</a>. For the allocating variant, you can specify the type <code>T</code>, when the point argument is the identity and hence does not provide the representation used. The computation can be performed in-place of <code>X::T</code>, which then determines the type.</p><div class="admonition is-info" id="Naming-convention-74cfd1606a59e1b8"><header class="admonition-header">Naming convention<a class="admonition-anchor" href="#Naming-convention-74cfd1606a59e1b8" title="Permalink"></a></header><div class="admonition-body"><p>There are at least two different objects usually called ‚Äúlogarithm‚Äù that need to be distinguished</p><ul><li>the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#Base.log-Tuple%7BAbstractManifold%2C%20Any%2C%20Any%7D">(Riemannian) logarithm</a> map <code>log(M, p, q)</code> from <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/"><code>ManifoldsBase.jl</code></a>. This can be accessed here using <code>log(base_manifold(G), p, q)</code>.</li><li>the logarithmic map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric <code>log(G, g, h)</code>, which we use as a default within this package</li><li>the (matrix/Lie group) logarithm function <code>log(G, h)</code> which agrees with the previous one for <code>g</code> being the identity there.</li></ul></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L985-L1002">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.retract-Tuple{LieGroup, Any, Any, BaseManifoldRetraction}" href="#ManifoldsBase.retract-Tuple{LieGroup, Any, Any, BaseManifoldRetraction}"><code>ManifoldsBase.retract</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">retract(G::AbstractLieGroup, g, h, m::BaseManifoldRetraction)</code></pre><p>Compute the retraction of <code>g</code> and <code>X</code> on the <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <code>G</code> by pushing <code>X</code> forward to the tangent space at <code>g</code> and using a retraction on the underlying manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L1144-L1149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.vector_transport_to-Tuple{AbstractLieGroup, Any, Any, Any, BaseManifoldVectorTransportMethod}" href="#ManifoldsBase.vector_transport_to-Tuple{AbstractLieGroup, Any, Any, Any, BaseManifoldVectorTransportMethod}"><code>ManifoldsBase.vector_transport_to</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vector_transport_to(G::AbstractLieGroup, g, X, h, m::BaseManifoldVectorTransportMethod)</code></pre><p>Compute the vector transport of a Lie algebra <code>X</code> from  <code>g</code> to <code>h</code> using a vector transport on the underlying manifold. This is done by pushing <code>X</code> forward to the tangent space at <code>g</code>, then performing the vector transport on the base manifold, and finally pulling the resulting tangent vector back to the Lie algebra.</p><p>This method merely exists for experimental reasons, since the parallel transport on Lie groups, where all tangent vectors are represented in the Lie algebra is the identity. Hence any of the methods performed here are more costly than plain parallel transport.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L1199-L1210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Random.rand!-Tuple{AbstractLieGroup, Any}" href="#Random.rand!-Tuple{AbstractLieGroup, Any}"><code>Random.rand!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand(::AbstractLieGroup; vector_at=nothing, œÉ::Real=1.0, kwargs...)
rand(::AbstractLieGroup, PT::Type; vector_at=nothing, œÉ::Real=1.0, kwargs...)
rand!(::LieAlgebra, T::Type; œÉ::Real=1.0, kwargs...)
rand!(::AbstractLieGroup, gX::PT; vector_at=nothing, œÉ::Real=1.0, kwargs...)
rand!(::LieAlgebra, X::T; œÉ::Real=1.0, kwargs...)</code></pre><p>Compute a random point or tangent vector on a Lie group.</p><p>For points this just means to generate a random point on the underlying manifold itself.</p><p>For tangent vectors, an element in the Lie Algebra is generated, see also <a href="../algebra/#Base.rand-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O&lt;:AbstractGroupOperation, G&lt;:(AbstractLieGroup{var&quot;#s25&quot;, O, M} where {var&quot;#s25&quot;, M&lt;:ManifoldsBase.AbstractManifold{var&quot;#s25&quot;}})}}"><code>rand(::LieAlgebra; kwargs...)</code></a></p><p>For both cases, you can provide the type <span>$T$</span> for the tangent vector and/or point <span>$PT$</span>, if you want to generate a random point in a certain representation. For the in-place variants the type is inferred from <code>pX</code> and <code>X</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L1128-L1146">source</a></section></article><h2 id="Internal-functions-and-macros"><a class="docs-heading-anchor" href="#Internal-functions-and-macros">Internal functions and macros</a><a id="Internal-functions-and-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-functions-and-macros" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.CommonUnitarySubAlgebra" href="#LieGroups.CommonUnitarySubAlgebra"><code>LieGroups.CommonUnitarySubAlgebra</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CommonUnitarySubAlgebra{ùîΩ,T}</code></pre><p>A constant that allows to refer to several sub Algebras of <span>$\mathfrak u(n)$</span> for implementations where</p><ul><li>certain sub algebras real/complex share a common implementation, e.g. for the same sizes <code>T</code> usually via <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types/#ManifoldsBase.TypeParameter"><code>TypeParameter</code></a></li><li>certain functions are the same for all sizes <code>T</code> as long as the field <code>ùîΩ</code> is the same</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/groups/unitary_group.jl#L129-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.@default_lie_group_fallbacks" href="#LieGroups.@default_lie_group_fallbacks"><code>LieGroups.@default_lie_group_fallbacks</code></a> ‚Äî <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">default_lie_group_fallbacks(TG, TF, TP, TV, pfield::Symbol, Xfield::Symbol, groupOp)</code></pre><p>Introduce default fallbacks for all basic functions on Lie groups, for Lie group of type <code>TG</code> with group operation <code>Op</code>, points of type <code>TP</code>, tangent vectors of type <code>TV</code>, with forwarding to fields <code>pfield</code> and <code>Xfield</code> for point and tangent vector functions, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/interface.jl#L1289-L1296">source</a></section></article><h2 id="A-validation-Lie-group"><a class="docs-heading-anchor" href="#A-validation-Lie-group">A validation Lie group</a><a id="A-validation-Lie-group-1"></a><a class="docs-heading-anchor-permalink" href="#A-validation-Lie-group" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.ValidationLieGroup" href="#LieGroups.ValidationLieGroup"><code>LieGroups.ValidationLieGroup</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ValidationLieGroup{L&lt;:AbstractLieGroup} &lt;: AbstractLieGroup</code></pre><p>A Lie group to add tests to input parameters and output values of functions defined for <a href="../../#LieGroups.LieGroups"><code>LieGroups</code></a>.</p><p>Using the <code>ignore_contexts</code> keyword allows to specify a single <code>Symbol</code> or a vector of <code>Symbols</code> Of which contexts to ignore.</p><p>Current contexts are</p><ul><li><code>:All</code>: disable all checks</li><li><code>:Point</code>: checks for points</li><li><code>:Algebra</code>: checks related to the <a href="../algebra/#LieGroups.LieAlgebra"><code>LieAlgebra</code></a></li><li><code>:Output</code>: checks for output</li><li><code>:Input</code>: checks for input variables</li></ul><p><strong>Fields</strong></p><ul><li><code>lie_group::L</code> the <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> to be decorated</li><li><code>mode::Symbol</code>: The mode to be used for error handling, either <code>:error</code> or <code>:warn</code></li><li><code>ignore_contexts::AbstractVector{Symbol}</code>: store contexts to be ignored of validation.</li><li><code>ignore_functions::Dict{&lt;:Function,&lt;:Union{Symbol,&lt;:AbstractVector{Symbol}}</code>: store contexts to be ignored with in a function or its mutating variant.</li></ul><p>where all but the first field are analogous to the setups of the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/manifolds/#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>. We refer to those docs for more examples on their meaning.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ValidationLieGroup(L::AbstractLieGroup, check_manifold=true; kwargs...)</code></pre><p>Generate the Validation Lie Group for the given <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <code>L</code>. If <code>check_manifold</code> is set to <code>true</code> the inner manifold is additionally wrapped in a <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/manifolds/#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>. All suitable keywords are passed to the constructor of the validation manifold as well.</p><p><strong>Keyword arguments</strong></p><ul><li><code>error::Symbol=:error</code>: specify how errors in the validation should be reported. this is passed to <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/segre/#ManifoldsBase.is_point-Union%7BTuple%7BV%7D%2C%20Tuple%7BSegre%7B%E2%84%9D%2C%20V%7D%2C%20Any%7D%7D%20where%20V"><code>is_point</code></a> and <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/manifolds/#ManifoldsBase.is_vector"><code>is_vector</code></a> as the <code>error</code> keyword argument. Available values are <code>:error</code>, <code>:warn</code>, <code>:info</code>, and <code>:none</code>. Every other value is treated as <code>:none</code>.</li><li><code>ignore_contexts = Vector{Symbol}()</code> a vector to indicate which validation contexts should not be performed.</li><li><code>ignore_functions=Dict{Function,Union{Symbol,Vector{Symbol}}}()</code> a dictionary to disable certain contexts within functions. The key here is the non-mutating function variant (if it exists). The contexts are the same as in <code>ignore_contexts</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/groups/validation_group.jl#L1-L45">source</a></section></article><h2 id="A-metric-Lie-group-to-change-the-metric-on-a-Lie-Algebra"><a class="docs-heading-anchor" href="#A-metric-Lie-group-to-change-the-metric-on-a-Lie-Algebra">A metric Lie group to change the metric on a Lie Algebra</a><a id="A-metric-Lie-group-to-change-the-metric-on-a-Lie-Algebra-1"></a><a class="docs-heading-anchor-permalink" href="#A-metric-Lie-group-to-change-the-metric-on-a-Lie-Algebra" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups.MetricLieGroup" href="#LieGroups.MetricLieGroup"><code>LieGroups.MetricLieGroup</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MetricLieGroup{
    ùîΩ, O &lt;: AbstractGroupOperation, M &lt;: ManifoldsBase.AbstractManifold{ùîΩ},
    L &lt;: LieGroup{ùîΩ, O, M}, G &lt;: AbstractMetric
} &lt;: AbstractLieGroup{ùîΩ, O, M}}</code></pre><p>Equip an <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <span>$\mathcal G$</span> explicitly with an <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/manifolds/#ManifoldsBase.AbstractMetric"><code>AbstractMetric</code></a> <code>‚ü®‚ãÖ,‚ãÖ‚ü©</code>.</p><p>By default every <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> <span>$\mathcal G$</span> is assumed to implicitly implement all functions on their <a href="../algebra/#LieGroups.LieAlgebra"><code>LieAlgebra</code></a> with respect to a metric, that corresponds to a certain ‚Äúdefault metric‚Äù, either because it is a widely recognized metric or because the first implementation within <code>LieGroups.jl</code> was done with respect to this metric.</p><p>This default is usually indicated by checking that <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/manifolds/#Manifolds"><code>metric(L)</code></a> returns <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/metric/#Manifolds.DefaultMetric"><code>DefaultMetric</code></a>.</p><p>This decorator type allows to explicitly equip the Lie group with a different metric. Note that for any functions unrelated to the metric, this new Lie group will simply forward to the Lie group that is internally stored. This for example includes group operations like [<code>compose</code>], <code>inv</code>, or <code>identity_element</code>, or functions that are already otherwise passed on to the inner manifold like <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions/#ManifoldsBase.manifold_dimension-Tuple%7BAbstractManifold%7D"><code>manifold_dimension</code></a>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">MetricLieGroup(G::AbstractLieGroup, metric::AbstractMetric)</code></pre><p>Generate the <a href="#LieGroups.AbstractLieGroup"><code>AbstractLieGroup</code></a> equipped explicitly with the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/manifolds/#ManifoldsBase.AbstractMetric"><code>AbstractMetric</code></a> <code>metric</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/groups/metric_group.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Manifolds.metric" href="#Manifolds.metric"><code>Manifolds.metric</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">metric(G::MetricLieGroup)</code></pre><p>Get the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/manifolds/#ManifoldsBase.AbstractMetric"><code>AbstractMetric</code></a> associated with the <a href="#LieGroups.MetricLieGroup"><code>MetricLieGroup</code></a> <span>$\mathcal G$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/groups/metric_group.jl#L39-L43">source</a></section></article><h3 id="Internal-functions"><a class="docs-heading-anchor" href="#Internal-functions">Internal functions</a><a id="Internal-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups._vLc" href="#LieGroups._vLc"><code>LieGroups._vLc</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_vLc(M::ValidationLieGroup, f::Function, context::Symbol)
_vLc(M::ValidationLieGroup, f::Function, context::NTuple{N,Symbol}) where {N}
_vLc(M::ValidationLieGroup, ::Nothing, context::NTuple{N,Symbol}) where {N}</code></pre><p>Return whether a check should be performed within <code>f</code> and the <code>context</code>(<code>s</code>) provided, if the second argument is <code>:Nothing</code>, only the context is checked</p><p>This function returns false and hence indicates not to check, when</p><ul><li>(one of the) <code>context</code>(<code>s</code>) is in the ignore list for <code>f</code> within <code>ignore_functions</code></li><li>(one of the) <code>context</code>(<code>s</code>) is in the <code>ignore_contexts</code> list</li></ul><p>Otherwise the test is active.</p><p>!!! Note    This function is internal and used very often, so it has a very short name;     <code>_vLc</code> stands for &quot;<code>ValidationLieGroup</code> check&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/groups/validation_group.jl#L105-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LieGroups._msg" href="#LieGroups._msg"><code>LieGroups._msg</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_msg(G::ValidationLieGroup, str; error=:None, within::Union{Nothing,&lt;:Function} = nothing,
context::Union{NTuple{N,Symbol} where N} = NTuple{0,Symbol}())</code></pre><p>issue a message <code>str</code> according to the mode <code>mode</code> (as <code>@error</code>, <code>@warn</code>, <code>@info</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/LieGroups.jl/blob/a26ba8d0aec36666608436272e1ad3d7c3908e62/src/groups/validation_group.jl#L153-L158">source</a></section></article><h2 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[Gil08]</dt><dd><div>M.¬†B.¬†Giles. <a href="https://doi.org/10.1007/978-3-540-68942-3_4"><em>Collected Matrix Derivative Results for Forward and Reverse Mode Algorithmic Differentiation</em></a>. In: <em>Advances in Automatic Differentiation</em>, <em>Lecture Notes in Computational Science and Engineering</em>, edited by C.¬†H.¬†Bischof, H.¬†M.¬†B√ºcker, P.¬†Hovland, U.¬†Naumann and J.¬†Utke (Springer, Berlin, Heidelberg, 2008); pp.¬†35‚Äì44.</div></dd><dt>[HN12]</dt><dd><div>J.¬†Hilgert and K.-H.¬†Neeb. <a href="https://doi.org/10.1007/978-0-387-84794-8"><em>Structure and Geometry of Lie Groups</em></a> (Springer Monographs in Mathematics, 2012).</div></dd><dt>[SDA21]</dt><dd><div>J.¬†Sol√†, J.¬†Deray and D.¬†Atchuthan. <a href="http://arxiv.org/abs/1812.01537"><em>A micro Lie theory for state estimation in robotics</em></a> (Dec 2021), <a href="https://arxiv.org/abs/1812.01537">arXiv:1812.01537 [cs.RO]</a>, arXiv: 1812.01537.</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../groups/unitary_group/">¬´ Unitary group</a><a class="docs-footer-nextpage" href="../algebra/">Lie algebra ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Friday 31 October 2025 17:40">Friday 31 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
