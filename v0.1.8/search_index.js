var documenterSearchIndex = {"docs":
[{"location":"tutorials/transition/#Transition-from-GroupManifolds-in-Manifolds.jl","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds in Manifolds.jl","text":"","category":"section"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"One predecessor of LieGroups.jl are the GroupManifolds in Manifolds.jl. While this package provides the same features, one reason for a new package is, that a “restart” offers the opportunity to put the main focus for the functions in this package really on Lie groups.","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"This tutorial provides an overview of the necessary changes to your code if you based it on the predecessor.","category":"page"},{"location":"tutorials/transition/#Table-of-function-names-and-its-successors","page":"Transition from GroupManifolds","title":"Table of function names and its successors","text":"","category":"section"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"The following table lists all functions related to GroupManifolds and their new names or replacements here in LieGroups.jl. In this code G always refers to the GroupManifold in the first column and the LieGroup in the second. Lie group elements (points) are always g,h, Lie algebra elements (vectors) always X, Y.","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"New functions and types in this package are only mentioned, if they are worth a comment and if something changed.","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"The list lists first types, then functions. Within both blocks, the order is alphabetical","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"Manifolds.jl LieGroups.jl Comment\nAdditionOperation AdditionGroupOperation \nColumnwiseMultiplicationAction ColumnwiseGroupAction(LeftMultiplicationGroupAction) within a GroupAction(action, group, manifold)\nColumnwiseSpecialEuclideanAction ColumnwiseGroupAction(LeftMultiplicationGroupAction) within a GroupAction(action, group, manifold), where the groupis a SpecialEuclideanGroup\nComplexPlanarRotation LeftMultiplicationGroupAction a slightly more general type for all actions that are implemented by (matrix) multiplication\nGroupActionSide AbstractActionActsOnType Switching to a new, hopefully more descriptive naming.\nLeftBackwardAction AbstractRightGroupActionType and ActionActsOnRight This tuple form has been discontinued.\nLeftForwardAction AbstractLeftGroupActionType and ActionActsOnLeft This tuple form has been discontinued.\nLeftSide ActionActsOnLeft \n LieAlgebra(G) new alias to emphasize its manifold- and vector structure as well as for a few dispatch methods.\nGroupManifold(M, op) LieGroup(M, op) \nPowerGroup(M) PowerLieGroup(G,n) The main change is, that the constructor now requires a Lie group to build the power Lie group; This also allows for G^n. The other two former constructors for nested and nested-replacing are no longer necessary. PowerLieGroup behaves exactly the same as PowerManifold.\nProductGroup(M) ProductLieGroup(G, H) The main change is, that the constructor now requires two Lie groups to build their product. This also allows for the short hand G×H to generate this product.\nQuaternionRotation LeftMultiplicationGroupAction a slightly more general type for all actions that are implemented by (matrix) multiplication\nRightBackwardAction AbstractRightGroupActionType and ActionActsOnRight This tuple form has been discontinued.\nRightForwardAction AbstractRightGroupActionType and ActionActsOnLeft This tuple form has been discontinued.\nRightSide ActionActsOnRight \nRotationAction LeftMultiplicationGroupAction a slightly more general type for all actions that are implemented by (matrix) multiplication\nRotationTranslationActionOnVector LeftMultiplicationGroupAction e.g. in a GroupAction with SpecialEuclideanGroup and Euclidean(n).\nRowwiseMultiplicationAction RowwiseGroupAction(LeftMultiplicationGroupAction) \nSemidirectProductGroup(G, H, a) LeftSemidirectProductLieGroup(G, H, a) While this staid the same, there is now also the default_left_action(G,H). When this agrees with a you can use the short hand G⋉H to generate this semidirect product. Analogously there now also exists the RightSemidirectProductLieGroup(G,H) withdefault_left_action(G,H) that allows for the short cut G⋊H\nSpecialEuclidean(n) SpecialEuclideanGroup(n; variant=:right) \nSpecialEuclideanInGeneralLinear(n) SpecialEuclideanGroup(n; variant=:right) now supports both ArrayPartition and matrix representations. Point and tangent vectors can be converted between them using convert, which replaces old project and embed on SpecialEuclideanInGeneralLinear, see SpecialEuclideanMatrixPoint, SpecialEuclideanMatrixTangentVector, SpecialEuclideanProductPoint and SpecialEuclideanProductTangentVector.\nTranslationAction AdditionGroupAction this slightly more general name allows to reuse the action in other contexts easier\nVeeOrthogonalBasis DefaultLieAlgebraOrthogonalBasis \nadjoint_action adjoint now implemented with a default, when you provide diff_conjugate!.\nadjoint_matrix(G, p, b) jacobian_conjugate(G, p, e, b) e is either the Identity(G) or its identity_element(G)\napply_diff diff_apply modifiers (diff) come first, consistent with ManifoldsDiff.jl\napply_diff_group diff_group_apply modifiers (diff/group) come first, consistent with ManifoldsDiff.jl\n conjugate, diff_conjugate a new function to model c_g mathcal G  mathcal G given by c_g(h) = ghg^-1\ndifferential_exp_argument_lie_approx - Scheduled for update and renaming. Though available in ManifoldDiff.jl for GroupManifolds, that will move to differential_exp_argument_approx instead, since exp_lie changed to now just exp.\nexp(G, g, X) exp(base_manifold(G), g, X) the previous defaults whenever not agreeing with the Riemannian one can now be accessed on the internal manifold\nexp_inv(G, g, X) exp(G, g, X) the exponential map invariant to the group operation is the default on Lie groups here\nexp_lie(G, X) exp(G, X) the (matrix/Lie group) exponential\nget_coordinates(G, p, X) get_coordinates(LieAlgebra(G), X) hat/vee moved to using the new LieAlgebra. The old format should still work.\nget_vector(G, p, c) get_vector(LieAlgebra(G), c[, T]) moved to using the new LieAlgebra. The old format should still work. T indicates the type of tangent vector.\nhat(G, p, c) hat(LieAlgebra(G), p, c[, T]) hat/vee moved to using the new LieAlgebra. The old format should still work. T indicates the type of tangent vector.\ninner(G, g, X, Y) inner(LieAlgebra(G), X, Y) the inner product on the Lie Algebra. The old variant still calls the new one.\ninverse_translate(G, g, h, c) inv_left_compose(G, g, h), inv_right_compose(G, g, h) compute g^-1h and gh^-1, resp.\ninverse_translate_diff(G, g, h, X, LeftForwardAction()) - discontinued, use diff_left_compose(G, inv(G,g), h)\ninverse_translate_diff(G, g, h, X, RightBackwardAction()) - discontinued, use diff_left_compose(G, h, inv(G,g))\njacobian_exp_argument(G, g, X, b) jacobian_exp(G, g, X, b) the Jacobian of the exponential map w.r.t. an AbstractBasis of the LieAlgebra. The old name is resevered for the Riemannian exponential map.\nlog(G, g, h) log(base_manifold(G), g, h) you can now access the previous defaults on the internal manifold whenever they do not agree with the invariant one\nlog_inv(G, g, h) log(G, g, h) the logarithmic map invariant to the group operation is the default on Lie groups here\nlog_lie(G, g) log(G, g) the (matrix/Lie group) logarithm\nnorm(G, p, X) norm(LieAlgebra(G), X) the norm product on the Lie Algebra. The old variant still calls the new one.\nswitch_direction(A) inv(A) switches from an action to its inverse action (formerly the direction forward/backward, sometimes even left/right, do not confuse with the side left/right).\nswitch_side(A) - discontinued\ntranslate(G, g, h) compose(G, g, h) unified to compose\ntranslate_diff(G, g, X, c) diff_left_compose(G, g, h, X), diff_right_compose(G, g, h, X) for compose gh the functions now specify whether the derivative is taken w.r.t. to the left (g) or right (h) argument\nvee(G, p, X) vee(LieAlgebra(G), X) hat/vee moved to using the new LieAlgebra. The old format should still work.","category":"page"},{"location":"tutorials/transition/#Further-notable-changes","page":"Transition from GroupManifolds","title":"Further notable changes","text":"","category":"section"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"In general the default for tangent vectors is now to represent them in the LieAlgebra, which obtains its own name now, though defined as a constant of a certain tangent space.\nIn accordance with point 1., the GeneralLinearGroup (formerly GeneralLinear) switched to using its Lie algebra to represent tangent vectors.\nFormerly, both a power manifold of Lie groups as a manifold as well as a Lie group of a power manifold as a Lie group were possible. This is unified to just defining G^n as the Lie group on the power manifold with the element-wise group operation.\nFormerly, product manifolds were stored as a ProductManifold of Lie groups and an indicator for the group operation, that the direct product should be used. This is switched to internally only store a ProductManifold as well as a (new) ProductGroupOperation that specifies one group operation for every factor.\nThe last two points achieve one unified modelling aspect of Lie groups: they are now always a manifold M together with a group operation op, but a Lie group does not store another Lie group (or product of them) internally with one common type they share, a LieGroup.\nFormerly, identity_element(group[, gT]) to provide a materialized version of the Identity point on a Lie group accepted either a concrete point g on the Lie group or the Type T of g. This is now unified for example with zero_vector and only accepts a Type as second argument.\nThere are two usual representations of the SpecialEuclideanGroup, one with the rotation matrix on the left and the translation vector on the right and vice versa. The default is now to have the rotation matrix on the left, while formerly it was on the right. To be precise, SpecialEuclideanGroup(3) is now equivalent to SpecialOrthogonalGroup(3) ⋉ TranslationGroup(3). To get the previous default use SpecialEuclideanGroup(; variant=:right) which is the same as writing TranslationGroup(3) ⋊ SpecialOrthogonalGroup(3).","category":"page"},{"location":"references/#Literature","page":"References","title":"Literature","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"This is all literature mentioned / referenced in the LieGroups.jl documentation. You can find a small reference section at the end of every documentation page that contains the corresponding references as well.","category":"page"},{"location":"references/","page":"References","title":"References","text":"D. Andrica and R.-A. Rohan. Computing the Rodrigues coefficients of the exponential map of the Lie groups of matrices. Balkan Journal of Geometry and Its Applications 18, 1–10 (2013).\n\n\n\nT. Bendokat and R. Zimmermann. The real symplectic Stiefel and Grassmann manifolds: metrics, geodesics and applications, arXiv Preprint, 2108.12447 (2021), arXiv:2108.12447.\n\n\n\nE. Biny and S. Pods. The Geometry of Heisenberg Groups: With Applications in Signal Theory, Optics, Quantization, and Field Quantization (American Mathematical Society, 2008).\n\n\n\nG. S. Chirikjian. Stochastic Models, Information Theory, and Lie Groups, Volume 2. 1 Edition, Vol. 2 of Applied and Numerical Harmonic Analysis (Birkhäuser Boston, MA, 2012).\n\n\n\nJ. Gallier and D. Xu. Computing exponentials of skew-symmetric matrices and logarithms of orthogonal matrices. International Journal of Robotics and Automation 17, 1–11 (2002).\n\n\n\nM. B. Giles. Collected Matrix Derivative Results for Forward and Reverse Mode Algorithmic Differentiation. In: Advances in Automatic Differentiation, Lecture Notes in Computational Science and Engineering, edited by C. H. Bischof, H. M. Bücker, P. Hovland, U. Naumann and J. Utke (Springer, Berlin, Heidelberg, 2008); pp. 35–44.\n\n\n\nJ. Hilgert and K.-H. Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\nJ. Kelly. All About the Galilean Group SGal(3) (Jun 2025), arXiv:2312.07555 [cs.RO].\n\n\n\nD. Latifi and M. Toomanian. On the existence of bi-invariant Finsler metrics on Lie groups. Mathematical Sciences 7, 37 (2013).\n\n\n\nJ. Solà, J. Deray and D. Atchuthan. A micro Lie theory for state estimation in robotics (Dec 2021), arXiv:1812.01537 [cs.RO], arXiv: 1812.01537.\n\n\n\n","category":"page"},{"location":"groups/circle_group/#The-circle-group","page":"Circle Group","title":"The circle group","text":"","category":"section"},{"location":"groups/circle_group/#LieGroups.CircleGroup-Tuple{Union{ManifoldsBase.AbstractNumbers, Manifolds.Circle, Manifolds.Euclidean, Manifolds.Sphere}}","page":"Circle Group","title":"LieGroups.CircleGroup","text":"CircleGroup\n\nThe circle group 𝕊^1 is the unit circle together with composing points on the circle by adding angles. The circle itself is a one dimensional Riemannian manifold. Hence the Lie algebra is the real line.\n\nThe elements of the circle group can be represented in three different ways.\n\nAs complex numbers\n\nElements of the circle group can be represented as complex numbers of absolute value one, that is\n\n𝕊¹ = bigl z  ℂ big z = 1bigr  = bigl a + bmathrmi  ℂ big a^2+b^2 = 1bigr \n\nwhere mathrmi denotes the imaginary unit. It is equipped with the group operation of complex multiplication AbelianMultiplicationGroupOperation. That operation is given by\n\n(a + bmathrmi)  (c + dmathrmi) = (ac - bd) + (ad + bc)mathrmi\n\nfor complex numbers a + bmathrmi c + dmathrmi  ℂ.\n\nAs angles in -ππ)\n\nElements of the circle group can be represented by the angle on the unit circle that they correspond to. In that case the elements are represented by real numbers x  -ππ) and the circle group is identified with a quotient space of the real numbers\n\n 𝕊¹ = ℝ  2πℤ = bigl x  ℝ  2πℤ big x  -ππ)bigr \n\nIt is equipped with the group operation of adding angles mathrmmod  2π via AdditionGroupOperation.\n\nAs part of the 2D plane ℝ^2\n\nElements of the circle group can be represented as two dimensional real valued vectors x  ℝ of length 1. In that case the circle group is identified with the unit circle in ℝ^2, that is the one dimensional Sphere\n\n𝕊^1 = bigl (x y)  ℝ^2 big x^2 + y^2 = 1bigr \n\nIt is equipped with the group operation of adding the angles of two points on the unit circle which corresponds to complex multiplication\n\n(x_1 y_1)  (x_2 y_2) = ( x_1x_2 - y_1y_2 x_1y_2 + x_2y_1)\n\nfor real valued vectors (x_1 y_1)^mathrmT (x_2 y_2)^mathrmT  ℝ^2 via AbelianMultiplicationGroupOperation.\n\nConstructors\n\nCircleGroup(Circle(ℂ))\nCircleGroup(ℂ)\nCircleGroup()\n\nGenerate the circle group represented as complex numbers.\n\nCircleGroup(Circle(ℝ))\nCircleGroup(ℝ)\n\nGenerate the circle group represented as real valued angles x  -π π).\n\nCircleGroup(Sphere(1))\nCircleGroup(ℝ^2)\n\nGenerate the circle group represented as two dimensional real valued vectors of unit norm.\n\nThe default representation is by complex numbers and can be constructed with CircleGroup().\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#circle-group-real","page":"Circle Group","title":"Representation on the real line","text":"","category":"section"},{"location":"groups/circle_group/#Base.exp-Tuple{LieGroup{ℝ, AdditionGroupOperation, <:Manifolds.Circle{ℝ}}, Number}","page":"Circle Group","title":"Base.exp","text":"exp(::LieGroup{ℝ, AdditionGroupOperation, Circle{ℝ}}, X)\nexp!(::LieGroup{ℝ, AdditionGroupOperation, Circle{ℝ}}, g, X)\n\nCompute the Lie group exponential of a vector X of the LieAlgebra of the circle group, represented as angles in -π π). In that case, the Lie algebra is the real line and the Lie group exponential of a vector X  ℝ is its equivalence class\n\n    exp(X) = X  bigl x  ℝ  2πℤ big x  -ππ)bigr \n\nThis can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#Base.log-Tuple{LieGroup{ℝ, AdditionGroupOperation, <:Manifolds.Circle{ℝ}}, Number}","page":"Circle Group","title":"Base.log","text":"log(::LieGroup{ℝ, AdditionGroupOperation, Circle{ℝ}}, g)\nlog!(::LieGroup{ℝ, AdditionGroupOperation, Circle{ℝ}}, X, g)\n\nCompute the Lie group logarithm on the CircleGroup, represented as angles in -ππ). The LieAlgebra is the real line and log is given by the identity map.\n\nFormally log promotes an equivalence class X to a representative Xℝ.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.conjugate!-Tuple{LieGroup{ℝ, AdditionGroupOperation, <:Manifolds.Circle{ℝ}}, Any, Any, Any}","page":"Circle Group","title":"LieGroups.conjugate!","text":"conjugate(CircleGroup, g, h)\nconjugate!(CircleGroup, k, g, h)\n\nCompute the conjugation map c_g mathcal G  mathcal G given by c_g(h) = ghg^-1 = h. It simplifies to the identity since the group operation on the circle group is abelian.\n\nThis can be computed in-place of k if k is mutable.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.conjugate-Tuple{LieGroup{ℝ, AdditionGroupOperation, <:Manifolds.Circle{ℝ}}, Any, Any}","page":"Circle Group","title":"LieGroups.conjugate","text":"conjugate(CircleGroup, g, h)\nconjugate!(CircleGroup, k, g, h)\n\nCompute the conjugation map c_g mathcal G  mathcal G given by c_g(h) = ghg^-1 = h. It simplifies to the identity since the group operation on the circle group is abelian.\n\nThis can be computed in-place of k if k is mutable.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.diff_conjugate-Tuple{LieGroup{ℝ, AdditionGroupOperation, <:Manifolds.Circle{ℝ}}, Any, Any, Number}","page":"Circle Group","title":"LieGroups.diff_conjugate","text":"diff_conjugate(G::LieGroup{ℝ, AdditionGroupOperation, Circle{ℝ}}, g, h, X)\ndiff_conjugate!(G::LieGroup{ℝ, AdditionGroupOperation, Circle{ℝ}}, Y, g, h, X)\n\nCompute the differential of the conjugation map c_g(h) = ghg^-1=h. On the circle group represented as part of the real line, this simplifies to D(c_g(h))X = X.\n\nThis can be computed in-place of Y if Y is mutable.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.diff_inv!-Tuple{LieGroup{ℝ, AdditionGroupOperation, <:Manifolds.Circle{ℝ}}, Any, Any, Any}","page":"Circle Group","title":"LieGroups.diff_inv!","text":"diff_inv(G::LieGroup{ℝ, AdditionGroupOperation, Circle{ℝ}}, g, X)\ndiff_inv!(G::LieGroup{ℝ, AdditionGroupOperation, Circle{ℝ}}, Y, g, X)\n\nCompute the the differential mathrmdι_mathcal G(g)X of the inversion ι_mathcal G(g) = g^-1 = -g at X  𝔤 in the LieAlgebra 𝔤 of the real CircleGroup G =mathcal G.\n\nmathrmdι_mathcal G(g)X = -X\n\nThis can be computed in-place of Y if Y is mutable.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.diff_inv-Tuple{LieGroup{ℝ, AdditionGroupOperation, <:Manifolds.Circle{ℝ}}, Any, Any}","page":"Circle Group","title":"LieGroups.diff_inv","text":"diff_inv(G::LieGroup{ℝ, AdditionGroupOperation, Circle{ℝ}}, g, X)\ndiff_inv!(G::LieGroup{ℝ, AdditionGroupOperation, Circle{ℝ}}, Y, g, X)\n\nCompute the the differential mathrmdι_mathcal G(g)X of the inversion ι_mathcal G(g) = g^-1 = -g at X  𝔤 in the LieAlgebra 𝔤 of the real CircleGroup G =mathcal G.\n\nmathrmdι_mathcal G(g)X = -X\n\nThis can be computed in-place of Y if Y is mutable.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.sym_rem-Union{Tuple{N}, Tuple{N, Any}} where N<:Number","page":"Circle Group","title":"LieGroups.sym_rem","text":"sym_rem(x,[T=π])\n\nCompute symmetric remainder of x with respect to the interall 2*T, i.e. (x+T)%2T, where the default for T is π.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#ManifoldsBase.exp!-Tuple{LieGroup{ℝ, AdditionGroupOperation, <:Manifolds.Circle{ℝ}}, Any, Any}","page":"Circle Group","title":"ManifoldsBase.exp!","text":"exp(::LieGroup{ℝ, AdditionGroupOperation, Circle{ℝ}}, X)\nexp!(::LieGroup{ℝ, AdditionGroupOperation, Circle{ℝ}}, g, X)\n\nCompute the Lie group exponential of a vector X of the LieAlgebra of the circle group, represented as angles in -π π). In that case, the Lie algebra is the real line and the Lie group exponential of a vector X  ℝ is its equivalence class\n\n    exp(X) = X  bigl x  ℝ  2πℤ big x  -ππ)bigr \n\nThis can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#ManifoldsBase.log!-Tuple{LieGroup{ℝ, AdditionGroupOperation, <:Manifolds.Circle{ℝ}}, Any, Any}","page":"Circle Group","title":"ManifoldsBase.log!","text":"log(::LieGroup{ℝ, AdditionGroupOperation, Circle{ℝ}}, g)\nlog!(::LieGroup{ℝ, AdditionGroupOperation, Circle{ℝ}}, X, g)\n\nCompute the Lie group logarithm on the CircleGroup, represented as angles in -ππ). The LieAlgebra is the real line and log is given by the identity map.\n\nFormally log promotes an equivalence class X to a representative Xℝ.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#circle-group-complex","page":"Circle Group","title":"Representation on the complex plane","text":"","category":"section"},{"location":"groups/circle_group/#Base.exp-Tuple{LieGroup{ℂ, AbelianMultiplicationGroupOperation, <:Manifolds.Circle{ℂ}}, Number}","page":"Circle Group","title":"Base.exp","text":"exp(::LieGroup{ℂ, AbelianMultiplicationGroupOperation, Circle{ℂ}}, X)\nexp!(::LieGroup{ℂ, AbelianMultiplicationGroupOperation, Circle{ℂ}}, g, X)\n\nComputes the Lie group exponential on the complex CircleGroup, which coincides with the ordinary complex exponential.\n\nThe Lie algebra is precisely the imaginary axis of the complex plane.\n\nThis can be computed in-place of g.\n\nexp (mathrmit) = cos(t) + mathrmisin(t)\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#Base.log-Tuple{LieGroup{ℂ, AbelianMultiplicationGroupOperation, <:Manifolds.Circle{ℂ}}, Any}","page":"Circle Group","title":"Base.log","text":"log(::CircleGroup{ℂ, AbelianMultiplicationGroupOperation, Circle{ℂ}}, g)\nlog!(::CircleGroup{ℂ, AbelianMultiplicationGroupOperation, Circle{ℂ}}, X, g)\n\nCompute the Lie group logarithm on the complex CircleGroup, which coincides with the ordinary complex logarithm.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.diff_left_compose-Tuple{LieGroup{ℂ, AbelianMultiplicationGroupOperation, <:Manifolds.Circle{ℂ}}, Number, Any, Number}","page":"Circle Group","title":"LieGroups.diff_left_compose","text":"diff_left_compose(::LieGroup{ℂ, AbelianMultiplicationGroupOperation, Circle{ℂ}}, g, h, X)\ndiff_left_compose(::LieGroup{ℂ, AbelianMultiplicationGroupOperation, Circle{ℂ}}, Y, g, h, X)\n\nCompute the differential of the group operation gh with respeect to the lefy argument g.\n\nThe formula reads\n\n   mathrmd ρ_h(g) = X\n\nsince the group operation is abelian. This can be computed in-place of Y if Y is mutable.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.diff_right_compose-Tuple{LieGroup{ℂ, AbelianMultiplicationGroupOperation, <:Manifolds.Circle{ℂ}}, Number, Any, Number}","page":"Circle Group","title":"LieGroups.diff_right_compose","text":"diff_right_compose(::LieGroup{ℂ, AbelianMultiplicationGroupOperation, Circle{ℂ}}, g, h, X)\ndiff_right_compose(::LieGroup{ℂ, AbelianMultiplicationGroupOperation, Circle{ℂ}}, Y, g, h, X)\n\nCompute the differential of the group operation gh, on an AbstractLieGroup G with respect to its second (right) argument h.\n\nAnother interpretation is to consider a function where we do a fixed multiplication from the left with g. i..e. the left group multiplication function λ_g(h) = gh.\n\nIt simplifies for the AbelianMultiplicationGroupOperation to mathrmdλ_g(h)X = X. This can be computed in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#ManifoldsBase.exp!-Tuple{LieGroup{ℂ, AbelianMultiplicationGroupOperation, <:Manifolds.Circle{ℂ}}, Any, Any}","page":"Circle Group","title":"ManifoldsBase.exp!","text":"exp(::LieGroup{ℂ, AbelianMultiplicationGroupOperation, Circle{ℂ}}, X)\nexp!(::LieGroup{ℂ, AbelianMultiplicationGroupOperation, Circle{ℂ}}, g, X)\n\nComputes the Lie group exponential on the complex CircleGroup, which coincides with the ordinary complex exponential.\n\nThe Lie algebra is precisely the imaginary axis of the complex plane.\n\nThis can be computed in-place of g.\n\nexp (mathrmit) = cos(t) + mathrmisin(t)\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#ManifoldsBase.log!-Tuple{LieGroup{ℂ, AbelianMultiplicationGroupOperation, <:Manifolds.Circle{ℂ}}, Any, Any}","page":"Circle Group","title":"ManifoldsBase.log!","text":"log(::CircleGroup{ℂ, AbelianMultiplicationGroupOperation, Circle{ℂ}}, g)\nlog!(::CircleGroup{ℂ, AbelianMultiplicationGroupOperation, Circle{ℂ}}, X, g)\n\nCompute the Lie group logarithm on the complex CircleGroup, which coincides with the ordinary complex logarithm.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#circle-group-plane","page":"Circle Group","title":"Representation on the 2D-plane","text":"","category":"section"},{"location":"groups/circle_group/#Base.exp-Tuple{LieGroup{ℝ, AbelianMultiplicationGroupOperation, <:Manifolds.Sphere{ℝ, ManifoldsBase.TypeParameter{Tuple{1}}}}, Any}","page":"Circle Group","title":"Base.exp","text":"exp(::LieGroup{ℝ, AbelianMultiplicationGroupOperation, Sphere}, X)\nexp!(::LieGroup{ℝ, AbelianMultiplicationGroupOperation, Sphere}, g, X)\n\nCompute the Lie group exponential on the CircleGroup, represented as two dimensional vectors in the real plane. It coincides with the ordinary complex exponential after canonical identification of the real plane with the complex plane.\n\nThis can be computed in-place of g.\n\nexp beginpmatrix 0 tendpmatrix = beginpmatrix cos(t) sin(t)endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#Base.log-Tuple{LieGroup{ℝ, AbelianMultiplicationGroupOperation, <:Manifolds.Sphere{ℝ, ManifoldsBase.TypeParameter{Tuple{1}}}}, Any}","page":"Circle Group","title":"Base.log","text":"log(::LieGroup{ℝ, AbelianMultiplicationGroupOperation, Sphere}, g)\nlog!(::LieGroup{ℝ, AbelianMultiplicationGroupOperation, Sphere}, X, g)\n\nCompute the Lie group logarithm on the CircleGroup, represented as two dimensional vectors in the real plane. It coincides with the ordinary complex logarithm after canonical identification of the real plane with the complex plane.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.diff_left_compose!-Tuple{LieGroup{ℝ, AbelianMultiplicationGroupOperation, <:Manifolds.Sphere{ℝ, ManifoldsBase.TypeParameter{Tuple{1}}}}, Vararg{Any, 4}}","page":"Circle Group","title":"LieGroups.diff_left_compose!","text":"diff_left_compose(G::LieGroup{ℝ, AbelianMultiplicationGroupOperation, Sphere}, g, h, X)\ndiff_left_compose!(G::LieGroup{ℝ, AbelianMultiplicationGroupOperation, Sphere}, Y, g, h, X)\n\nCompute the differential of the group operation gh with respect to the left argument g.\n\nHere it simplifies for AbelianMultiplicationGroupOperation to mathrmdρ_h(g)X = X.\n\nThis can be computed in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.diff_left_compose-Tuple{LieGroup{ℝ, AbelianMultiplicationGroupOperation, <:Manifolds.Sphere{ℝ, ManifoldsBase.TypeParameter{Tuple{1}}}}, Any, Any, Any}","page":"Circle Group","title":"LieGroups.diff_left_compose","text":"diff_left_compose(G::LieGroup{ℝ, AbelianMultiplicationGroupOperation, Sphere}, g, h, X)\ndiff_left_compose!(G::LieGroup{ℝ, AbelianMultiplicationGroupOperation, Sphere}, Y, g, h, X)\n\nCompute the differential of the group operation gh with respect to the left argument g.\n\nHere it simplifies for AbelianMultiplicationGroupOperation to mathrmdρ_h(g)X = X.\n\nThis can be computed in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.diff_right_compose!-Tuple{LieGroup{ℝ, AbelianMultiplicationGroupOperation, <:Manifolds.Sphere{ℝ, ManifoldsBase.TypeParameter{Tuple{1}}}}, Vararg{Any, 4}}","page":"Circle Group","title":"LieGroups.diff_right_compose!","text":"diff_right_compose(G::LieGroup{ℝ, AbelianMultiplicationGroupOperation, Sphere}, g, h, X)\ndiff_right_compose!(G::LieGroup{ℝ, AbelianMultiplicationGroupOperation, Sphere}, Y, g, h, X)\n\nCompute the differential of the group operation gh, on an AbstractLieGroup G with respect to its second (right) argument h.\n\nAnother interpretation is to consider a function where we do a fixed multiplication from the left with g. i..e. the left group multiplication function λ_g(h) = gh.\n\nIt simplifies for the AbelianMultiplicationGroupOperation to mathrmdλ_g(h)X = X,\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#ManifoldsBase.exp!-Tuple{LieGroup{ℝ, AbelianMultiplicationGroupOperation, <:Manifolds.Sphere{ℝ, ManifoldsBase.TypeParameter{Tuple{1}}}}, Any, Any}","page":"Circle Group","title":"ManifoldsBase.exp!","text":"exp(::LieGroup{ℝ, AbelianMultiplicationGroupOperation, Sphere}, X)\nexp!(::LieGroup{ℝ, AbelianMultiplicationGroupOperation, Sphere}, g, X)\n\nCompute the Lie group exponential on the CircleGroup, represented as two dimensional vectors in the real plane. It coincides with the ordinary complex exponential after canonical identification of the real plane with the complex plane.\n\nThis can be computed in-place of g.\n\nexp beginpmatrix 0 tendpmatrix = beginpmatrix cos(t) sin(t)endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#ManifoldsBase.log!-Tuple{LieGroup{ℝ, AbelianMultiplicationGroupOperation, <:Manifolds.Sphere{ℝ, ManifoldsBase.TypeParameter{Tuple{1}}}}, Any, Any}","page":"Circle Group","title":"ManifoldsBase.log!","text":"log(::LieGroup{ℝ, AbelianMultiplicationGroupOperation, Sphere}, g)\nlog!(::LieGroup{ℝ, AbelianMultiplicationGroupOperation, Sphere}, X, g)\n\nCompute the Lie group logarithm on the CircleGroup, represented as two dimensional vectors in the real plane. It coincides with the ordinary complex logarithm after canonical identification of the real plane with the complex plane.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"contributing/#Contributing-to-LieGroups.jl","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"First, thanks for taking the time to contribute. We appreciate and welcome any contribution.","category":"page"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"The following is a set of guidelines to LieGroups.jl.","category":"page"},{"location":"contributing/#Table-of-contents","page":"Contributing to LieGroups.jl","title":"Table of contents","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Contributing to LieGroups.jl     - Table of Contents\nHow to just ask a question\nHow to file an issue\nHow to contribute\nCode style","category":"page"},{"location":"contributing/#How-to-just-ask-a-question","page":"Contributing to LieGroups.jl","title":"How to just ask a question","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"You can most easily reach the developers in the Julia Slack channel #manifolds. You can apply for the Julia Slack workspace here if you haven't joined yet. You can also ask your question on discourse.julialang.org.","category":"page"},{"location":"contributing/#How-to-file-an-issue","page":"Contributing to LieGroups.jl","title":"How to file an issue","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"If you found a bug or want to propose a feature, please open an issue in within the GitHub repository.","category":"page"},{"location":"contributing/#How-to-contribute","page":"Contributing to LieGroups.jl","title":"How to contribute","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Currently most details are still work-in-progress. Feel free to contribute ideas, features you would like to see, Lie groups you want to have or would like to contribute, or any other idea for LieGroups.jl. For these, use either the discussions or issues in the GitHub repository","category":"page"},{"location":"contributing/#Code-style","page":"Contributing to LieGroups.jl","title":"Code style","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Please follow the documentation guidelines from the Julia documentation and use Runic.jl for code formatting.","category":"page"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Please consider a few internal conventions:","category":"page"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Include the mathematical formulae for any implemented function if a closed form exists.\nDefine a Lie group, a Lie group action, or a Lie algebra in its own file. Include all related functions in the same file\nan alphabetical order of functions in every file is preferable.\nThe preceding implies that the mutating variant of a function follows the non-mutating variant.\nDocument both the allocating and the mutating variants of a function. To avoid duplication, attach one doc string defined before both functions and attach it to both.\nThere should be no dangling = signs.\nAdd a newline between things of different types (struct/method/const).\nAdd a newline between methods for different functions (including allocating/mutating variants).\nPrefer to have no newline between methods for the same function; when reasonable, merge the documentation strings.\nAll import/using/include should be in the main module file.\nAvoid using import and use the explicit full name, like Base.exp, when implementing functions, that extend functions of other packages.\nif possible provide both mathematical formulae and literature references using DocumenterCitations.jl and BibTeX where possible\nAlways document all input variables and keyword arguments","category":"page"},{"location":"groups/special_euclidean_group/#The-special-Euclidean-group","page":"Special Euclidean group","title":"The special Euclidean group","text":"","category":"section"},{"location":"groups/special_euclidean_group/#LieGroups.SpecialEuclideanGroup","page":"Special Euclidean group","title":"LieGroups.SpecialEuclideanGroup","text":"SpecialEuclideanGroup{T}\n\nThe special Euclidean group mathrmSE(n) = mathrmSO(n)  mathcal T(n) is the Lie group consisting of the LeftSemidirectProductGroupOperation of the SpecialOrthogonalGroup and the TranslationGroup together with the GroupOperationAction{LeftGroupOperationAction}.\n\nTo be precise, the group operation is defined on mathrmSO(n)  mathcal T(n) as follows:\n\n(r_1 t_1)  (r_2 t_2) = (r_1r_2 t_1 + r_1t_2)\n\nwhere r_1r_2  mathrmSO(n) and t_1t_2  mathcal T(n)\n\nAnalogously you can write this on elements of mathrmSO(n)  mathcal T(n) as\n\n(t_1 r_1)  (t_2 r_2) = (t_1 + r_1s_2 r_1r_2)\n\nBoth these cases can be represented in a single matrix in affine form\n\ng = beginpmatrix r  t mathbf0_n^mathrmT  1endpmatrix\nqquad r  mathrmSO(n) t  mathcal T(n)\n\nwhere mathbf0_n  ℝ^n denotes the vector containing zeros.\n\nWe refer also in general to elements on mathrmSE(n) as g and their rotation and translation components as r and t, respectively.\n\nNote further that in the notation above and in matrix form the default is the ActionActsOnRight action.\n\nConstructor\n\nSpecialEuclideanGroup(n::Int; variant=:left, kwargs...)\nSpecialOrthogonalGroup(n; kwargs...) ⋉ TranslationGroup(n; kwargs...)\nTranslationGroup(n; kwargs...) ⋊ SpecialOrthogonalGroup(n; kwargs...)\n\nGenerate special Euclidean group mathrmSE(n) = mathrmSO(n)  mathcal T(n), where the first constructor is equivalent to the second.\n\nAll keyword arguments in kwargs... are passed on to Rotations as well.\n\nThe default representation for mathrmSE(n) is the affine form. Alternatively you can use the ArrayPartition from RecursiveArrayTools.jl to work on (rt). or for mathcal T(n)  mathrmSO(n) using the ArrayPartitions (tr); which corresponds to setting variant=:right in the first constructor.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_euclidean_group/#Representation-of-points-and-tangent-vectors","page":"Special Euclidean group","title":"Representation of points and tangent vectors","text":"","category":"section"},{"location":"groups/special_euclidean_group/#LieGroups.SpecialEuclideanMatrixPoint","page":"Special Euclidean group","title":"LieGroups.SpecialEuclideanMatrixPoint","text":"SpecialEuclideanMatrixPoint <: AbstractLieGroupPoint\n\nrepresent a point on some AbstractLieGroup by an affine matrix.\n\nbeginpmatrix M  v mathbf0_n^mathrmT  1endpmatrix  ℝ^(n+1)(n+1)\nqquad M  ℝ^nn v  mathcal T(n)\n\nwhere mathbf0_n  ℝ^n denotes the vector containing zeros.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_euclidean_group/#LieGroups.SpecialEuclideanMatrixTangentVector","page":"Special Euclidean group","title":"LieGroups.SpecialEuclideanMatrixTangentVector","text":"SpecialEuclideanMatrixTangentVector <: AbstractLieAlgebraTangentVector\n\nrepresent a tangent vector on some AbstractLieGroup by a matrix of the form\n\nbeginpmatrix M  v mathbf0_n^mathrmT  0endpmatrix  ℝ^(n+1)(n+1)\nqquad M  ℝ^nn v  mathcal T(n)\n\nwhere mathbf0_n  ℝ^n denotes the vector containing zeros.\n\nWhile this tangent vector itself is not an affine matrix itself, it can be used for the Lie algebra of the affine group\n\n\n\n\n\n","category":"type"},{"location":"groups/special_euclidean_group/#LieGroups.SpecialEuclideanProductPoint","page":"Special Euclidean group","title":"LieGroups.SpecialEuclideanProductPoint","text":"SpecialEuclideanProductPoint <: AbstractLieGroupPoint\n\nRepresent a point on a Lie group (explicitly) as a point that consists of components\n\n\n\n\n\n","category":"type"},{"location":"groups/special_euclidean_group/#LieGroups.SpecialEuclideanProductTangentVector","page":"Special Euclidean group","title":"LieGroups.SpecialEuclideanProductTangentVector","text":"SpecialEuclideanProductTangentVector <: AbstractLieAlgebraTangentVector\n\nRepresent a point on a Lie algebra (explicitly) as a tangent vector that consists of components.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_euclidean_group/#Specific-functions","page":"Special Euclidean group","title":"Specific functions","text":"","category":"section"},{"location":"groups/special_euclidean_group/#Base.exp-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{AdditionGroupOperation, MatrixMultiplicationGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{2}}}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{2}}}}}}}, Any}","page":"Special Euclidean group","title":"Base.exp","text":"exp(G::SpecialEuclidean, X)\nexp!(G::SpecialEuclidean, g, X)\n\nCompute the Lie group exponential function on the SpecialEuclideanGroup G=mathrmSE(2) using a TypeParameter{Tuple{2}} for dispatch.\n\nThe Lie algebra vector X = (Y v)  mathfrak se(2) consists of a rotation component Y  mathfrak so(2) and a translation component v  mathfrak t(2), so we can use vee on mathrmSO(2) to obtain the angle of rotation α (or alternatively using sqrt2α = lVert Y rVert_)\n\nFor α  0 define\n\nU_α = fracsinααI_2 + frac1-cosαα^2Y\n\nand U_0 = I_2, where I_2 is the identity matrix.\n\nThen the result g=(Rt) is given by\n\nR = exp_mathrmSO(2)Y  mathrmSO(2)\nquad\ntext and \nquad\nt = U_αv  mathcal T(2)\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.exp-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{AdditionGroupOperation, MatrixMultiplicationGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}}}}}, Any}","page":"Special Euclidean group","title":"Base.exp","text":"exp(G::SpecialEuclidean, X)\nexp!(G::SpecialEuclidean, g, X)\n\nCompute the Lie group exponential function on the SpecialEuclideanGroup G=mathrmSE(3) using a TypeParameter{Tuple{3}} for dispatch.\n\nSince X = (Y v)  mathfrak se(3) consists of a rotation component Y  mathfrak se(3) and a translation component v  mathfrak t(3), we can use vee on mathrmSO(3) computing the coefficients norm to obtain the angle of rotation α (or alternatively using sqrt2α = lVert Y rVert_).\n\nFor α  0 define\n\nU_α = I_3 + frac1-cosαα^2Y + fracα-sinαα^3Y^2\n\nand U_0 = I_3, where I_2 is the identity matrix.\n\nThen the result g=(Rt) is given by\n\nR = exp_mathrmSO(3)Y  mathrmSO(3)\nquad\ntext and \nquad\nt = U_αv  mathcal T(3)\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.getindex-Tuple{Union{Identity, SpecialEuclideanMatrixPoint, SpecialEuclideanProductPoint, AbstractMatrix}, Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{AdditionGroupOperation, MatrixMultiplicationGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, T}, Manifolds.Rotations{T}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{T}, Manifolds.Euclidean{ℝ, T}}}}} where T, Union{Int64, Symbol}}","page":"Special Euclidean group","title":"Base.getindex","text":"g[G::SpecialEuclideanGroup,s]\ngetindex(g, G::SpecialEuclideanGroup, s)\nX[𝔤,s]\ngetindex(g, 𝔤, s)\n\nAccess sub-parts of a SpecialEuclideanGroup G or its Lie algebra 𝔤. where s can be an index :Rotation, :Translation to access the single parts. Use : to access all submanifold components as a unified tuple.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.getindex-Tuple{Union{SpecialEuclideanMatrixTangentVector, SpecialEuclideanProductTangentVector, AbstractMatrix}, ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, <:SpecialEuclideanGroup{T} where T, Identity{var\"#s261\"}} where var\"#s261\"<:(Union{var\"#s129\", var\"#s128\"} where {var\"#s129\"<:LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, var\"#s128\"<:RightSemidirectProductGroupOperation{AdditionGroupOperation, MatrixMultiplicationGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}}), Colon}","page":"Special Euclidean group","title":"Base.getindex","text":"g[G::SpecialEuclideanGroup,s]\ngetindex(g, G::SpecialEuclideanGroup, s)\nX[𝔤,s]\ngetindex(g, 𝔤, s)\n\nAccess sub-parts of a SpecialEuclideanGroup G or its Lie algebra 𝔤. where s can be an index :Rotation, :Translation to access the single parts. Use : to access all submanifold components as a unified tuple.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.getindex-Tuple{Union{SpecialEuclideanMatrixTangentVector, SpecialEuclideanProductTangentVector, AbstractMatrix}, ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, <:SpecialEuclideanGroup{T} where T, Identity{var\"#s261\"}} where var\"#s261\"<:(Union{var\"#s129\", var\"#s128\"} where {var\"#s129\"<:LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, var\"#s128\"<:RightSemidirectProductGroupOperation{AdditionGroupOperation, MatrixMultiplicationGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}}), Union{Int64, Symbol}}","page":"Special Euclidean group","title":"Base.getindex","text":"g[G::SpecialEuclideanGroup,s]\ngetindex(g, G::SpecialEuclideanGroup, s)\nX[𝔤,s]\ngetindex(g, 𝔤, s)\n\nAccess sub-parts of a SpecialEuclideanGroup G or its Lie algebra 𝔤. where s can be an index :Rotation, :Translation to access the single parts. Use : to access all submanifold components as a unified tuple.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.inv-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{AdditionGroupOperation, MatrixMultiplicationGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, T}, Manifolds.Rotations{T}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{T}, Manifolds.Euclidean{ℝ, T}}}}} where T, Any}","page":"Special Euclidean group","title":"Base.inv","text":"inv(G::SpecialEuclideanGroup, g)\ninv(G::SpecialEuclideanGroup, h, g)\n\nCompute the inverse element of a g  mathrmSE(n) from the SpecialEuclideanGroup(n).\n\nIn affine form, g = beginpmatrix r  t mathbf0_n^mathrmT  1endpmatrix, where mathbf0_n  ℝ^n denotes the vector containing zeros.\n\nThe inverse reads\n\ng^-1 = beginpmatrix r^mathrmT  -r^mathrmTt mathbf0_n^mathrmT  1endpmatrix\n\nThis computation can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.log-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{AdditionGroupOperation, MatrixMultiplicationGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{2}}}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{2}}}}}}}, Any}","page":"Special Euclidean group","title":"Base.log","text":"log(G::SpecialEuclidean, g)\nlog!(G::SpecialEuclidean, X, g)\n\nCompute the Lie group logarithm function on the SpecialEuclideanGroup G=mathrmSE(2), and G uses a TypeParameter{Tuple{2}} for dispatch.\n\nSince g=(Rt)  mathrmSE(2) consists of a rotation component R  mathrmSO(2) and a translation component t  mathcal T(2), we first compute Y = log_mathrmSO(2)R. Then we can use vee on mathrmSO(2) to obtain the angle of rotation α (or alternatively using sqrt2α = lVert Y rVert_)\n\nFor α  0 define\n\nV_α = fracα2 beginpmatrix fracsinα1-cosα  1 -1  fracsinα1-cosαendpmatrix\n\nand V_0 = I_2, where I_2 is the identity matrix. Note that this is the inverse of U_α as given in the group exponential\n\nThen the result X = (Y v)  mathfrak se(2) is given by Y  mathfrak so(2) as computed above and\n\nv = V_αr  mathcal T(2)\n\nwhere v is computed in-place without setting up V_α\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.log-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{AdditionGroupOperation, MatrixMultiplicationGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}}}}}, Any}","page":"Special Euclidean group","title":"Base.log","text":"log(G::SpecialEuclidean, g)\nlog!(G::SpecialEuclidean, X, g)\n\nCompute the Lie group logarithm function on the SpecialEuclideanGroup G=mathrmSE(3), where e is the Identity on mathrmSE(3) G uses a TypeParameter{Tuple{3}} for dispatch.\n\nSince g=(Rt)  mathrmSE(3) consists of a rotation component R  mathrmSO(3) and a translation component t  mathcal T(2), we first compute Y = log_mathrmSO(3)R. Then we can use vee on mathrmSO(3) to obtain the angle of rotation α (or alternatively using sqrt2α = lVert Y rVert_)\n\nFor α  0 define\n\nV_α = I_3 - frac12Y + β Y^2 quadtext where  β = frac1α^2 - frac1 + cos(α)2αsin(α)\n\nand V_0 = I_3, where I_3 is the identity matrix. Note that this is the inverse of U_α as given in the group exponential\n\nThen the result X = (Y v)  mathfrak se(3) is given by Y  mathfrak so(3) as computed above and v = V_α t  mathfrak t(3).\n\nThis result can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups._inv!-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{AdditionGroupOperation, MatrixMultiplicationGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, T}, Manifolds.Rotations{T}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{T}, Manifolds.Euclidean{ℝ, T}}}}} where T, AbstractMatrix, AbstractMatrix}","page":"Special Euclidean group","title":"LieGroups._inv!","text":"inv(G::SpecialEuclideanGroup, g)\ninv(G::SpecialEuclideanGroup, h, g)\n\nCompute the inverse element of a g  mathrmSE(n) from the SpecialEuclideanGroup(n).\n\nIn affine form, g = beginpmatrix r  t mathbf0_n^mathrmT  1endpmatrix, where mathbf0_n  ℝ^n denotes the vector containing zeros.\n\nThe inverse reads\n\ng^-1 = beginpmatrix r^mathrmT  -r^mathrmTt mathbf0_n^mathrmT  1endpmatrix\n\nThis computation can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.apply!-Tuple{GroupAction{LeftMultiplicationGroupAction, <:SpecialEuclideanGroup{T} where T, <:Manifolds.Euclidean}, Any, Any, Any}","page":"Special Euclidean group","title":"LieGroups.apply!","text":"apply(::GroupAction{LeftMultiplicationGroupAction, <:SpecialEuclideanGroup, <:Euclidean}, g, p)\napply!(::GroupAction{LeftMultiplicationGroupAction, <:SpecialEuclideanGroup, <:Euclidean}, q, g, p)\n\nGiven the Lie group SpecialEuclideanGroup  and the Euclidean manifold ℝ^n, this action performs both the rotation and translation on a vector p  ℝ^n, that is, for g = (R t)  mathrmSE(n), the action is given by\n\nq = σ_g(p) = g  p = Rp + t\n\nwhere the name of the action, LeftMultiplicationGroupAction, indicates that the group element g acts on the left of the vector p, and directly yields a multiplication if interpreted in homogeneous coordinates.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.apply-Tuple{GroupAction{LeftMultiplicationGroupAction, <:SpecialEuclideanGroup{T} where T, <:Manifolds.Euclidean}, Any, Any}","page":"Special Euclidean group","title":"LieGroups.apply","text":"apply(::GroupAction{LeftMultiplicationGroupAction, <:SpecialEuclideanGroup, <:Euclidean}, g, p)\napply!(::GroupAction{LeftMultiplicationGroupAction, <:SpecialEuclideanGroup, <:Euclidean}, q, g, p)\n\nGiven the Lie group SpecialEuclideanGroup  and the Euclidean manifold ℝ^n, this action performs both the rotation and translation on a vector p  ℝ^n, that is, for g = (R t)  mathrmSE(n), the action is given by\n\nq = σ_g(p) = g  p = Rp + t\n\nwhere the name of the action, LeftMultiplicationGroupAction, indicates that the group element g acts on the left of the vector p, and directly yields a multiplication if interpreted in homogeneous coordinates.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.default_left_action-Tuple{SpecialOrthogonalGroup, TranslationGroup}","page":"Special Euclidean group","title":"LieGroups.default_left_action","text":"default_left_action(::SpecialOrthogonalGroup, ::TranslationGroup)\n\nReturn the default AbstractGroupActionType for the special Euclidean group mathrmSO(n)  mathcal T(n), which is the LeftMultiplicationGroupAction\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.default_right_action-Tuple{TranslationGroup, SpecialOrthogonalGroup}","page":"Special Euclidean group","title":"LieGroups.default_right_action","text":"default_right_action(::TranslationGroup, ::SpecialOrthogonalGroup)\n\nReturn the default AbstractGroupActionType for the special Euclidean group mathcal T(n)  mathrmSO(n), which is the LeftMultiplicationGroupAction\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.diff_apply!-Tuple{GroupAction{LeftMultiplicationGroupAction, <:SpecialEuclideanGroup{T} where T, <:Manifolds.Euclidean}, Vararg{Any, 4}}","page":"Special Euclidean group","title":"LieGroups.diff_apply!","text":"diff_apply(::GroupAction{LeftMultiplicationGroupAction,SpecialEuclideanGroup,Euclidean}, g, p, X)\ndiff_apply!(::GroupAction{LeftMultiplicationGroupAction,SpecialEuclideanGroup,Euclidean}, Y, g, p, X)\n\nGiven the Lie group SpecialEuclideanGroup  and the Euclidean manifold ℝ^n, the differential of the group action this action performs both the rotation and translation on a vector p  ℝ^n, that is, for g = (R t)  mathrmSE(n), the differential is given by\n\nY = Dσ_g(p)X = RX\n\nwhere the name of the action, LeftMultiplicationGroupAction, indicates that the group element g acts on the left of the vector p, and directly yields a multiplication if interpreted in homogeneous coordinates.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.diff_apply-Tuple{GroupAction{LeftMultiplicationGroupAction, <:SpecialEuclideanGroup{T} where T, <:Manifolds.Euclidean}, Any, Any, Any}","page":"Special Euclidean group","title":"LieGroups.diff_apply","text":"diff_apply(::GroupAction{LeftMultiplicationGroupAction,SpecialEuclideanGroup,Euclidean}, g, p, X)\ndiff_apply!(::GroupAction{LeftMultiplicationGroupAction,SpecialEuclideanGroup,Euclidean}, Y, g, p, X)\n\nGiven the Lie group SpecialEuclideanGroup  and the Euclidean manifold ℝ^n, the differential of the group action this action performs both the rotation and translation on a vector p  ℝ^n, that is, for g = (R t)  mathrmSE(n), the differential is given by\n\nY = Dσ_g(p)X = RX\n\nwhere the name of the action, LeftMultiplicationGroupAction, indicates that the group element g acts on the left of the vector p, and directly yields a multiplication if interpreted in homogeneous coordinates.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.diff_left_compose-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{AdditionGroupOperation, MatrixMultiplicationGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, T}, Manifolds.Rotations{T}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{T}, Manifolds.Euclidean{ℝ, T}}}}} where T, Any, Any, Any}","page":"Special Euclidean group","title":"LieGroups.diff_left_compose","text":"diff_left_compose(G::SpecialEuclideanGroup, g, h, X)\n\nCompute the differential of left composition by h on SpecialEuclideanGroup for tangent vector X at g.\n\nLet\n\nh=beginpmatrix R  t4pt 0  1endpmatrixqquad\nX=beginpmatrix X_mathrmR  X_mathrmt4pt 0  0endpmatrix\n\nwhere Rin SO(n), tinmathbbR^n, X_mathrmR is the skew-symmetric rotation block and X_mathrmt the translation column. Then the differential is the adjoint action by h^-1:\n\nmathrmDλ_h(X)=h^-1Xh=\nbeginpmatrix\nR^top X_mathrmR R  R^topbigl(X_mathrmRt + X_mathrmtbigr)4pt\n0  0\nendpmatrix\n\nComponent-wise:\n\nY_mathrmR = R^top X_mathrmR Rqquad Y_mathrmt = R^topbigl(X_mathrmRt + X_mathrmtbigr)\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.diff_right_compose-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{AdditionGroupOperation, MatrixMultiplicationGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, T}, Manifolds.Rotations{T}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{T}, Manifolds.Euclidean{ℝ, T}}}}} where T, Any, Any, Any}","page":"Special Euclidean group","title":"LieGroups.diff_right_compose","text":"diff_right_compose(G::SpecialEuclideanGroup, g, h, X)\n\nCompute the differential of right composition by h on SpecialEuclideanGroup for tangent vector X at g, which is equal to X.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.init_constants!-Tuple{ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, <:SpecialEuclideanGroup{T} where T, Identity{var\"#s261\"}} where var\"#s261\"<:(Union{var\"#s129\", var\"#s128\"} where {var\"#s129\"<:LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, var\"#s128\"<:RightSemidirectProductGroupOperation{AdditionGroupOperation, MatrixMultiplicationGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}}), AbstractMatrix}","page":"Special Euclidean group","title":"LieGroups.init_constants!","text":"init_constants!(G::SpecialEuclidean, g)\ninit_Constants!(𝔰𝔢::LieAlgebra{ℝ, SpecialEuclideanGroupOperation, SpecialEuclidean}, X)\n\nInitialize the constant elements of g or X.\n\nThe matrix representation of gmathrmSE(n) has a last row, that contains zeros, besides the diagonal element, which is g_n+1n+1 = 1.\n\nThe matrix representation of Xmathfrak se(n) has a last row that contains zeros.\n\nthis function sets these entries accordingly.\n\nPer default for other representations, this function does not change entries for them.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.init_constants!-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{AdditionGroupOperation, MatrixMultiplicationGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, T}, Manifolds.Rotations{T}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{T}, Manifolds.Euclidean{ℝ, T}}}}} where T, AbstractMatrix}","page":"Special Euclidean group","title":"LieGroups.init_constants!","text":"init_constants!(G::SpecialEuclidean, g)\ninit_Constants!(𝔰𝔢::LieAlgebra{ℝ, SpecialEuclideanGroupOperation, SpecialEuclidean}, X)\n\nInitialize the constant elements of g or X.\n\nThe matrix representation of gmathrmSE(n) has a last row, that contains zeros, besides the diagonal element, which is g_n+1n+1 = 1.\n\nThe matrix representation of Xmathfrak se(n) has a last row that contains zeros.\n\nthis function sets these entries accordingly.\n\nPer default for other representations, this function does not change entries for them.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.lie_bracket!-Tuple{ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, <:SpecialEuclideanGroup{T} where T, Identity{var\"#s258\"}} where var\"#s258\"<:(Union{var\"#s129\", var\"#s128\"} where {var\"#s129\"<:LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, var\"#s128\"<:RightSemidirectProductGroupOperation{AdditionGroupOperation, MatrixMultiplicationGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}}), Union{SpecialEuclideanMatrixTangentVector, AbstractMatrix}, Union{SpecialEuclideanMatrixTangentVector, AbstractMatrix}, Union{SpecialEuclideanMatrixTangentVector, AbstractMatrix}}","page":"Special Euclidean group","title":"LieGroups.lie_bracket!","text":"lie_bracket(𝔰𝔢::LieAlgebra{ℝ, SpecialEuclideanGroupOperation, SpecialEuclideanGroup}, X, Y)\nlie_bracket!(𝔰𝔢::LieAlgebra{ℝ, SpecialEuclideanGroupOperation, SpecialEuclideanGroup}, Z, X, Y)\n\nCalculate the Lie bracket between elements X and Y of the Lie algebra of the SpecialEuclideanGroup. For the matrix representation, cf. SpecialEuclideanMatrixTangentVector or a <:AbstractMatrix, the formula reads\n\nX Y = XY-YX\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.lie_bracket-Tuple{ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, <:SpecialEuclideanGroup{T} where T, Identity{var\"#s263\"}} where var\"#s263\"<:(Union{var\"#s129\", var\"#s128\"} where {var\"#s129\"<:LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, var\"#s128\"<:RightSemidirectProductGroupOperation{AdditionGroupOperation, MatrixMultiplicationGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}}), Union{SpecialEuclideanMatrixTangentVector, AbstractMatrix}, Union{SpecialEuclideanMatrixTangentVector, AbstractMatrix}}","page":"Special Euclidean group","title":"LieGroups.lie_bracket","text":"lie_bracket(𝔰𝔢::LieAlgebra{ℝ, SpecialEuclideanGroupOperation, SpecialEuclideanGroup}, X, Y)\nlie_bracket!(𝔰𝔢::LieAlgebra{ℝ, SpecialEuclideanGroupOperation, SpecialEuclideanGroup}, Z, X, Y)\n\nCalculate the Lie bracket between elements X and Y of the Lie algebra of the SpecialEuclideanGroup. For the matrix representation, cf. SpecialEuclideanMatrixTangentVector or a <:AbstractMatrix, the formula reads\n\nX Y = XY-YX\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#ManifoldsBase.exp!-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{AdditionGroupOperation, MatrixMultiplicationGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}}}}}, AbstractMatrix, AbstractMatrix}","page":"Special Euclidean group","title":"ManifoldsBase.exp!","text":"exp(G::SpecialEuclidean, X)\nexp!(G::SpecialEuclidean, g, X)\n\nCompute the Lie group exponential function on the SpecialEuclideanGroup G=mathrmSE(3) using a TypeParameter{Tuple{3}} for dispatch.\n\nSince X = (Y v)  mathfrak se(3) consists of a rotation component Y  mathfrak se(3) and a translation component v  mathfrak t(3), we can use vee on mathrmSO(3) computing the coefficients norm to obtain the angle of rotation α (or alternatively using sqrt2α = lVert Y rVert_).\n\nFor α  0 define\n\nU_α = I_3 + frac1-cosαα^2Y + fracα-sinαα^3Y^2\n\nand U_0 = I_3, where I_2 is the identity matrix.\n\nThen the result g=(Rt) is given by\n\nR = exp_mathrmSO(3)Y  mathrmSO(3)\nquad\ntext and \nquad\nt = U_αv  mathcal T(3)\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#ManifoldsBase.exp!-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{AdditionGroupOperation, MatrixMultiplicationGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, var\"#s262\"}, Manifolds.Rotations{var\"#s262\"}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{var\"#s262\"}, Manifolds.Euclidean{ℝ, var\"#s262\"}}}}} where var\"#s262\"<:ManifoldsBase.TypeParameter{Tuple{2}}, AbstractMatrix, AbstractMatrix}","page":"Special Euclidean group","title":"ManifoldsBase.exp!","text":"exp(G::SpecialEuclidean, X)\nexp!(G::SpecialEuclidean, g, X)\n\nCompute the Lie group exponential function on the SpecialEuclideanGroup G=mathrmSE(2) using a TypeParameter{Tuple{2}} for dispatch.\n\nThe Lie algebra vector X = (Y v)  mathfrak se(2) consists of a rotation component Y  mathfrak so(2) and a translation component v  mathfrak t(2), so we can use vee on mathrmSO(2) to obtain the angle of rotation α (or alternatively using sqrt2α = lVert Y rVert_)\n\nFor α  0 define\n\nU_α = fracsinααI_2 + frac1-cosαα^2Y\n\nand U_0 = I_2, where I_2 is the identity matrix.\n\nThen the result g=(Rt) is given by\n\nR = exp_mathrmSO(2)Y  mathrmSO(2)\nquad\ntext and \nquad\nt = U_αv  mathcal T(2)\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#ManifoldsBase.log!-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{AdditionGroupOperation, MatrixMultiplicationGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{2}}}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{2}}}}}}}, AbstractMatrix, AbstractMatrix}","page":"Special Euclidean group","title":"ManifoldsBase.log!","text":"log(G::SpecialEuclidean, g)\nlog!(G::SpecialEuclidean, X, g)\n\nCompute the Lie group logarithm function on the SpecialEuclideanGroup G=mathrmSE(2), and G uses a TypeParameter{Tuple{2}} for dispatch.\n\nSince g=(Rt)  mathrmSE(2) consists of a rotation component R  mathrmSO(2) and a translation component t  mathcal T(2), we first compute Y = log_mathrmSO(2)R. Then we can use vee on mathrmSO(2) to obtain the angle of rotation α (or alternatively using sqrt2α = lVert Y rVert_)\n\nFor α  0 define\n\nV_α = fracα2 beginpmatrix fracsinα1-cosα  1 -1  fracsinα1-cosαendpmatrix\n\nand V_0 = I_2, where I_2 is the identity matrix. Note that this is the inverse of U_α as given in the group exponential\n\nThen the result X = (Y v)  mathfrak se(2) is given by Y  mathfrak so(2) as computed above and\n\nv = V_αr  mathcal T(2)\n\nwhere v is computed in-place without setting up V_α\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#ManifoldsBase.log!-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{AdditionGroupOperation, MatrixMultiplicationGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}}}}}, AbstractMatrix, AbstractMatrix}","page":"Special Euclidean group","title":"ManifoldsBase.log!","text":"log(G::SpecialEuclidean, g)\nlog!(G::SpecialEuclidean, X, g)\n\nCompute the Lie group logarithm function on the SpecialEuclideanGroup G=mathrmSE(3), where e is the Identity on mathrmSE(3) G uses a TypeParameter{Tuple{3}} for dispatch.\n\nSince g=(Rt)  mathrmSE(3) consists of a rotation component R  mathrmSO(3) and a translation component t  mathcal T(2), we first compute Y = log_mathrmSO(3)R. Then we can use vee on mathrmSO(3) to obtain the angle of rotation α (or alternatively using sqrt2α = lVert Y rVert_)\n\nFor α  0 define\n\nV_α = I_3 - frac12Y + β Y^2 quadtext where  β = frac1α^2 - frac1 + cos(α)2αsin(α)\n\nand V_0 = I_3, where I_3 is the identity matrix. Note that this is the inverse of U_α as given in the group exponential\n\nThen the result X = (Y v)  mathfrak se(3) is given by Y  mathfrak so(3) as computed above and v = V_α t  mathfrak t(3).\n\nThis result can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/getstarted/#Get-Started-with-LieGroups.jl","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"","category":"section"},{"location":"tutorials/getstarted/#Introduction","page":"🚀 Get Started with LieGroups.jl","title":"Introduction","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"This tutorial introduces both a few basics of Lie groups as well as how to use LieGroups.jl. The Lie groups we consider are the rotations in the plane, or special orthogonal group as well as rigid body motions, or in other words the special euclidean group.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"In a nutshell a Lie group 𝒢 is a manifold ℳ that also is a group with a group operation.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"A manifold can informally be described as a set that “locally looks like a Euclidean space” and has some way to measure angles at every point. Formally, this yields an inner product that depends (smoothly) on the point one is at. For Lie groups this will be a bit easier.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"A group means that on the set there also exists an operation, within this package usually denoted by  𝒢  𝒢  𝒢, LieGroups.jl uses the manifolds defined in Manifolds.jl. For more details on that, see also the introductory tutorial there. A Lie group is usually written as a tuple (ℳ) with the manifold and the group operation thereon.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"For more theoretical background, see for example [HN12], especially their Chapter 9.","category":"page"},{"location":"tutorials/getstarted/#Rotations-on-the-plane-ℝ2-and-in-ℝ3.","page":"🚀 Get Started with LieGroups.jl","title":"Rotations on the plane ℝ^2 and in ℝ^3.","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"This first part considers rotations in the plane. These can be represented by rotation matrices","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"R_α = beginpmatrix cos(α) -sin(α) sin(α)  cos(α) endpmatrixqquad α  ℝ","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"where we already represent all possible rotations when restricting α to 02π. Adding two matrices R_α + R_β does not yield a valid rotation matrix again, but we can have these matrices in mind as being “locally like the real line”, since changing the rotation angle slightly yields rotation matrices that are “close by” in the sense that they perform nearly the same rotation when applied to a point x  ℝ^2 by computing R_αx. Matrix multiplication R_β = R_α_1 R_α_2 does yield a new rotation and also fulfills all other properties to yield a group operation. Using trigonometric identities we observe that R_β = R_α_1+α_2. Since the angle of rotation is 2π-periodic, we also see here, that e.g. for small angles around 0, this behaves like the real line, but globally it differs, since R_α = R_α+2π","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"The set of rotation matrices is hence a Lie group and called the special orthogonal group mathrmSO(2). In LieGroups.jl we initialise this as","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"using LieGroups, LinearAlgebra, RecursiveArrayTools, Rotations\nSO2 = SpecialOrthogonalGroup(2)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"SpecialOrthogonalGroup(2)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"Elements g h  mathrmSO(2) we generate as","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"g = [1.0 0.0; 0.0 1.0]\nh = 1/sqrt(2) .* [1.0 -1.0; 1.0 1.0]","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"2×2 Matrix{Float64}:\n 0.707107  -0.707107\n 0.707107   0.707107","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"A first thing to do is to use is_point to verify they are valid.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"(is_point(SO2, g), is_point(SO2, h))","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"(true, true)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"The already mentioned group operation as the matrix multiplication, there is also a generic function available, compose as well as its in-place variant compose!. The following two yield the same matrix","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"[ compose(SO2, g, h), g*h ]","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"2-element Vector{Matrix{Float64}}:\n [0.7071067811865475 -0.7071067811865475; 0.7071067811865475 0.7071067811865475]\n [0.7071067811865475 -0.7071067811865475; 0.7071067811865475 0.7071067811865475]","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"Furthermore a lot of of functions are “passed down” tp the manifold, which is stored within the LieGroup. For example the dimension of the manifold, or the number of degrees of freedom can be accessed via the manifold_dimension","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"manifold_dimension(SO2)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"1","category":"page"},{"location":"tutorials/getstarted/#The-Lie-algebra,-and-the-Lie-group-exponential-function.","page":"🚀 Get Started with LieGroups.jl","title":"The Lie algebra, and the Lie group exponential function.","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"For the following investigations, we consider the special orthogonal group mathrmSO(3), that is rotations in a 3-dimensional space. Besides one special rotation in the following code for completeness, a prominent, at first glace maybe a bit “dull” point on this Lie group is the identity matrix e.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"SO3 = SpecialOrthogonalGroup(3)\ng = RotZ(π/3)*RotY(π/4)\ne = Matrix{Float64}(I,3,3)\ng","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"3×3 RotZY{Float64} with indices SOneTo(3)×SOneTo(3)(1.0472, 0.785398):\n  0.353553  -0.866025  0.353553\n  0.612372   0.5       0.612372\n -0.707107   0.0       0.707107","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"The element g can be seen as a rotation by π3 in the x-y-plane combined with a rotation by π4 in the x-z plane.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"The tangent space T_e𝒢 plays a special role and is called the LieAlgebra 𝔤.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"Similar to the Riemannian exponential map The exponential function exp_𝒢 𝔤  𝒢 maps Lie algebra tangent vectors X  T_e𝒢 to a point on the Lie group. This is implemented in exp(G::LieGroup, X). Its inverse is the Lie group logarithmic function log(G::LieGroup, g).","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"X = log(SO3,g)\nis_point(LieAlgebra(SO3), X)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"true","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"exp(SO3,X)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"3×3 StaticArraysCore.MMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.353553  -0.866025     0.353553\n  0.612372   0.5          0.612372\n -0.707107  -5.55112e-17  0.707107","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"The term “exponential” has at least three different meanings throughout Lie groups and Riemannian manifolds. To be precise, we call the just introduced one “exponential function”, since it often agrees with the matrix exponential.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"Taking a closed look at X we see","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"X","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"3×3 StaticArraysCore.MMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.0       -0.990825  0.710856\n  0.990825   0.0       0.410413\n -0.710856  -0.410413  0.0","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"an example that all elements from the Lie algebra are skew symmetric matrices. This allows for one way to see that we have three degrees of freedom, cf","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"manifold_dimension(SO3)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"3","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"As the Lie algebra was introduced via a tangent space, we also know that it is a vector space. To “turn” the X into a vector with three elements, we need a basis of the tangent space to decompose X into and “read off” its components. While in general this can be done using the bases of a tangent space from ManifoldsBase.jl, a very specific one is vee(::LieAlgebra, X)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"c = vee(LieAlgebra(SO3), X)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"3-element Vector{Float64}:\n -0.41041311978624273\n  0.7108563755626242\n  0.990824919963801","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"and its inverse, hat(G::LieAlgebra, c)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"X_ = hat(LieAlgebra(SO3),c)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"3×3 Matrix{Float64}:\n  0.0       -0.990825  0.710856\n  0.990825   0.0       0.410413\n -0.710856  -0.410413  0.0","category":"page"},{"location":"tutorials/getstarted/#Representing-tangent-vectors","page":"🚀 Get Started with LieGroups.jl","title":"Representing tangent vectors","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"Consider the function of left group composition λ_g(h) = gh. Its differential (or push forward) Dλ_g(e) maps from T_e𝒢 to T_g𝒢 and is a linear bijection between both spaces. Its adjoint differential (or pullback) D^*λ_g(e) maps back from T_g𝒢 to T_e𝒢.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"This allows to introduce an inner product on all tangent spaces, that smoothly varies with the base point, we obtain the left-invariant metric","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"XY_g = D^*λ_g(e)XD^*λ_g(e)_e","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"since it is invariant if you use the differential of the left composition to identify tangent vectors. We can even “spare” the pullbacks in this definition, when representing tangent vector alsways by their correspnding representants in the Lie algebra. This is the default in LieGroups.jl.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"Alternatively one can start with the right composition and its differential to arrive an right-invariant vector fields and a right-invariant metric.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"The left-invariant metric is in general not right-invariant, except for compact Lie groups and their direct products with translations, see for example [LT13] for an even more general proof.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"With respect to this metric on the manifold the exponential and logarithmic maps are given by","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"exp_g(X) = g  exp_𝒢(X)\nquadtextwith its inversequad\nlog_g(h) = log_𝒢(g^-1h)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"With respect to these geodesics and the representation in the Lie algebra, parallel transport simplifies to the identity. To still access the Riemannian exponential map with respect to the metric (compatible to the Levi-Civita connection) on the underlying Riemannian manifold, use exp(base_manifold(G), g, X).","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"As an example, we compute","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"h = exp(SO3, g, X)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"3×3 StaticArraysCore.MMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n -0.65533    -0.739199  -0.15533\n  0.0896799  -0.28033    0.955705\n -0.75        0.612372   0.25","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"and its inverse is returning X as well.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"log(SO3, g, h)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"3×3 StaticArraysCore.MMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.0       -0.990825  0.710856\n  0.990825   0.0       0.410413\n -0.710856  -0.410413  0.0","category":"page"},{"location":"tutorials/getstarted/#The-Special-Euclidean-group-\\mathrm{SE}(3)-of-rigid-body-motions","page":"🚀 Get Started with LieGroups.jl","title":"The Special Euclidean group mathrmSE(3) of rigid body motions","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"There are two further ingredients this tutorial needs to get towards rigid body motions.","category":"page"},{"location":"tutorials/getstarted/#Group-actions","page":"🚀 Get Started with LieGroups.jl","title":"Group actions","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"For a group like mathrmSO(3) an action describes how points g  𝒢 can act on points from a Riemannian manifold p  ℳ – in short an action of a certain AbstractGroupActionType ”combines“ p and g into a new element q = σ_g(p). In the example of 𝒢=mathrmSO(3) and ℳ=ℝ^3 the action is (just) the application of the rotation or the matrix-vector multiplication σ_g(p)=gp. A special case is, when ℳ itself is also a Lie group. In the example this is the case, since together with vector addition p+q we get the TranslationGroup T(3) = (ℝ^3 +) Depending on how the concatenation of two types, the AbstractLeftGroupActionType like the one here and a AbstractRightGroupActionType.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"T3 = TranslationGroup(3)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"TranslationGroup(3; field=ℝ)","category":"page"},{"location":"tutorials/getstarted/#Products-and-semidirect-products-of-Lie-groups","page":"🚀 Get Started with LieGroups.jl","title":"Products and semidirect products of Lie groups","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"Similar to product manifolds (direct) product Lie groups are formed the same way. For two Lie groups 𝒢 = 𝒢_1  𝒢_2 is the product of the two manifolds together with the component wise application of the group operations: the first group operation (of 𝒢_1) to the first component and that of 𝒢_2 to the second.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"Instead of the component wise or “not interacting” variant of the (direct) product Lie groups, for the semidirect product Lie groups 𝒢 = 𝒢_1  𝒢_2 we also require an action of how 𝒢_1 acts on 𝒢_2. Semidirect here means that the first component of 𝒢 is the same as for the direct product, but before applying the second group operation on 𝒢_2 one of the elements is “acted upon” from an element of 𝒢_1. The group operation reads for (g_1g_2) (h_1h_2)  𝒢","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"(g_1g_2)  (h_1h_2) = (g_1  h_1 σ_h_1(g_2)  h_2)","category":"page"},{"location":"tutorials/getstarted/#Rigid-body-motions","page":"🚀 Get Started with LieGroups.jl","title":"Rigid body motions","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"We obtain the special Euclidean group mathrmSE(3) = mathrmSO(3)  T(3) where the group action is the one discussed as an example before.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"SE3 = SpecialEuclideanGroup(3)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"SpecialEuclideanGroup(3)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"which we could also generate with SO3 and T3 from before as","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"SO3 ⋉ T3","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"SpecialEuclideanGroup(3)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"This call employs the default_left_action(SO3,T3) to determine the action for the semidirect product Lie group. This is defined whenever for two Lie groups, their (left) action is clear, because there exists a reasonable default. Otherwise the full form","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"LeftSemidirectProductLieGroup(SO3, T3, LeftGroupOperationAction())","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"LeftSemidirectProductLieGroup(SpecialOrthogonalGroup(3), TranslationGroup(3; field=ℝ), LieGroups.LeftGroupOperationAction())","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"is necessary. Here, the first Left for the semidirect product refers to the fact that the left group acts on the right one before the right group operation is performed. LeftGroupOperationAction refers to that the group operation – left multiplication with a matrix – is applied here.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"For this case, any point mathrmSE(3) is a tuple of a rotation matrix and a vector. We model this using RecursiveArrayTools.jl, namely its ArrayPartition. For example with the rotation matrix g from before we have","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"g1 = ArrayPartition(g, [1.0, 0.0, 2.0])","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"([0.35355339059327384 -0.8660254037844386 0.3535533905932738; 0.6123724356957946 0.5000000000000001 0.6123724356957945; -0.7071067811865475 0.0 0.7071067811865476], [1.0, 0.0, 2.0])","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"and for a pure translation we can reuse e as in","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"h1 = ArrayPartition(e, [0.0, 3.0, 0.0])","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0], [0.0, 3.0, 0.0])","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"and we can summarize a few operations from before: both are valid points on SE3","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"(is_point(SE3, g1), is_point(SE3, h1))","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"(true, true)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"we can perform the group operation","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"gh1 = compose(SE3, g1, h1)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"([0.35355339059327384 -0.8660254037844386 0.3535533905932738; 0.6123724356957946 0.5000000000000001 0.6123724356957945; -0.7071067811865475 0.0 0.7071067811865476], [-1.598076211353316, 1.5000000000000004, 2.0])","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"apply the Lie group exponential","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"Y = log(SE3, gh1)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"([0.0 -0.9908249199638008 0.7108563755626242; 0.9908249199638008 0.0 0.41041311978624273; -0.7108563755626242 -0.41041311978624273 0.0], [-1.4693272604812524, 1.8941219089183496, 1.7705711589135078])","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"and look at the manifold dimension, it is the sum of dimensions of its components","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"manifold_dimension(SE3)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"6","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"The coordinates of Y are","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"vee(LieAlgebra(SE3), Y)","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"6-element Vector{Float64}:\n -0.41041311978624273\n  0.7108563755626242\n  0.9908249199638008\n -1.4693272604812524\n  1.8941219089183496\n  1.7705711589135078","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"which actually is component wise again, the first 3 values refer to the rotation part, the second three to the translation part.","category":"page"},{"location":"tutorials/getstarted/#Technical-details","page":"🚀 Get Started with LieGroups.jl","title":"Technical details","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"This tutorial is cached. It was last run on the following package versions.","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"Status `~/work/LieGroups.jl/LieGroups.jl/tutorials/Project.toml`\n  [6774de46] LieGroups v0.1.6 `..`\n  [1cead3c2] Manifolds v0.11.1\n  [731186ca] RecursiveArrayTools v3.39.0\n  [6038ab10] Rotations v1.7.1","category":"page"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"This tutorial was last rendered October 27, 2025, 10:50:39.","category":"page"},{"location":"tutorials/getstarted/#Literature","page":"🚀 Get Started with LieGroups.jl","title":"Literature","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"J. Hilgert and K.-H. Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\nD. Latifi and M. Toomanian. On the existence of bi-invariant Finsler metrics on Lie groups. Mathematical Sciences 7, 37 (2013).\n\n\n\n","category":"page"},{"location":"interface/operations/#An-interface-for-Lie-group-operations","page":"Group operation","title":"An interface for Lie group operations","text":"","category":"section"},{"location":"interface/operations/#LieGroups.AbstractGroupOperation","page":"Group operation","title":"LieGroups.AbstractGroupOperation","text":"AbstractGroupOperation\n\nRepresent a type of group operation for a AbstractLieGroup mathcal G, that is a smooth binary operation   mathcal G  mathcal G  mathcal G on elements of a Lie group mathcal G.\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#LieGroups.Identity","page":"Group operation","title":"LieGroups.Identity","text":"Identity{O<:AbstractGroupOperation}\n\nRepresent the group identity element e  mathcal G on an AbstractLieGroup mathcal G with AbstractGroupOperation of type O.\n\nSimilar to the philosophy that points are agnostic of their group at hand, the identity does not store the group mathcal G it belongs to. However it depends on the type of the AbstractGroupOperation used.\n\nSee also identity_element on how to obtain the corresponding AbstractManifoldPoint or array representation.\n\nConstructors\n\nIdentity(::AbstractLieGroup{𝔽,O}) where {𝔽,O<:AbstractGroupOperation}\nIdentity(o::AbstractGroupOperation)\nIdentity(::Type{AbstractGroupOperation})\n\ncreate the identity of the corresponding subtype O<:AbstractGroupOperation\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"You can combine some specific group operations with one of several manifolds to form a Lie group. You can still define the corresponding functions generically for all groups with this group operation regardless of the manifold. The following sections collect these.","category":"page"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"an AdditionGroupOperation\nan AbelianMultiplicationGroupOperation and\na MatrixMultiplicationGroupOperation","category":"page"},{"location":"interface/operations/#addition-operation-sec","page":"Group operation","title":"Additive group operation","text":"","category":"section"},{"location":"interface/operations/#LieGroups.AdditionGroupOperation","page":"Group operation","title":"LieGroups.AdditionGroupOperation","text":"AdditionGroupOperation <: AbstractGroupOperation\n\nA group operation that is realised introducing defaults that fall back to + and - being overloaded, for example _compose(G::LieGroup{𝔽,AdditionGroupOperation}, a, b) = a + b\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#Base.exp-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any}} where 𝔽","page":"Group operation","title":"Base.exp","text":"exp(G::LieGroup{𝔽,AdditionGroupOperation}, X)\nexp!(G::LieGroup{𝔽,AdditionGroupOperation}, g, X)\n\nCompute the Lie group exponential on a LieGroup with an AdditionGroupOperation. This can be computed in-place of g.\n\nSince e is just the zero-element with respect to the corresponding +, the formula reads g=0+X=X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.inv-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any}} where 𝔽","page":"Group operation","title":"Base.inv","text":"inv(G::LieGroup{𝔽,AdditionGroupOperation}, g)\ninv!(G::LieGroup{𝔽,AdditionGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for the AdditionGroupOperation simplifies to -g. This can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.log-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any}} where 𝔽","page":"Group operation","title":"Base.log","text":"log(G::LieGroup{𝔽,AdditionGroupOperation}, g)\nlog!(G::LieGroup{𝔽,AdditionGroupOperation}, X, g)\n\nCompute the Lie group logarithm on a LieGroup with an AdditionGroupOperation. This can be computed in-place of X.\n\nSince e is just the zero-element with respect to the corresponding +, the formula reads X=g-0=g.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.compose!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.compose!","text":"compose(G::LieGroup{𝔽,AdditionGroupOperation}, g, h)\ncompose!(G::LieGroup{𝔽,AdditionGroupOperation}, k, g, h)\n\nCompute the group operation composition of g and h with respect to the AdditionGroupOperation on G, which falls back to calling g+h, where + is assumed to be overloaded accordingly.\n\nThis can be computed in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.compose-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.compose","text":"compose(G::LieGroup{𝔽,AdditionGroupOperation}, g, h)\ncompose!(G::LieGroup{𝔽,AdditionGroupOperation}, k, g, h)\n\nCompute the group operation composition of g and h with respect to the AdditionGroupOperation on G, which falls back to calling g+h, where + is assumed to be overloaded accordingly.\n\nThis can be computed in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Vararg{Any, 4}}} where 𝔽","page":"Group operation","title":"LieGroups.diff_conjugate!","text":"diff_conjugate(G::LieGroup{𝔽,AdditionGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{𝔽,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1 = g+h-g = h, which simplifies for AdditionGroupOperation to mathrmd(c_g(h))X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.diff_conjugate","text":"diff_conjugate(G::LieGroup{𝔽,AdditionGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{𝔽,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1 = g+h-g = h, which simplifies for AdditionGroupOperation to mathrmd(c_g(h))X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.diff_inv!","text":"diff_inv(G::LieGroup{𝔽,AdditionGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{𝔽,AdditionGroupOperation}, Y, g, X)\n\nCompute the differential of the inverse operation ι_mathcal G(g) = g^-1 = -g, which simplifies for AdditionGroupOperation to mathrmdι_mathcal G(g)X = -X\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.diff_inv","text":"diff_inv(G::LieGroup{𝔽,AdditionGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{𝔽,AdditionGroupOperation}, Y, g, X)\n\nCompute the differential of the inverse operation ι_mathcal G(g) = g^-1 = -g, which simplifies for AdditionGroupOperation to mathrmdι_mathcal G(g)X = -X\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Vararg{Any, 4}}} where 𝔽","page":"Group operation","title":"LieGroups.diff_left_compose!","text":"diff_left_compose(G::LieGroup{𝔽,AdditionGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{𝔽,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the the group operation g+h with respect to the left argument g. Here it simplifies for AdditionGroupOperation to mathrmdρ_h(g)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.diff_left_compose","text":"diff_left_compose(G::LieGroup{𝔽,AdditionGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{𝔽,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the the group operation g+h with respect to the left argument g. Here it simplifies for AdditionGroupOperation to mathrmdρ_h(g)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Vararg{Any, 4}}} where 𝔽","page":"Group operation","title":"LieGroups.diff_right_compose!","text":"diff_right_compose(G::LieGroup{𝔽,AdditionGroupOperation}, g, h, X)\ndiff_right_compose!(G::LieGroup{𝔽,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the group operation gh, on an AbstractLieGroup G with respect to its second (right) argument h.\n\nAnother interpretation is to consider a function where we do a fixed multiplication from the left with g. i.e. the left group multiplication function λ_g(h) = gh (where the left refers to the fixed argument g.).\n\nFor the AdditionGroupOperation it reads mathrmdλ_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.diff_right_compose","text":"diff_right_compose(G::LieGroup{𝔽,AdditionGroupOperation}, g, h, X)\ndiff_right_compose!(G::LieGroup{𝔽,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the group operation gh, on an AbstractLieGroup G with respect to its second (right) argument h.\n\nAnother interpretation is to consider a function where we do a fixed multiplication from the left with g. i.e. the left group multiplication function λ_g(h) = gh (where the left refers to the fixed argument g.).\n\nFor the AdditionGroupOperation it reads mathrmdλ_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.identity_element!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any}} where 𝔽","page":"Group operation","title":"LieGroups.identity_element!","text":"identity_element(G::LieGroup{𝔽,AdditionGroupOperation})\nidentity_element!(G::LieGroup{𝔽,AdditionGroupOperation}, e)\n\nReturn the a point representation of the Identity, which for the AdditionGroupOperation is the zero element or array.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.identity_element-Union{Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}}, Tuple{𝔽}} where 𝔽","page":"Group operation","title":"LieGroups.identity_element","text":"identity_element(G::LieGroup{𝔽,AdditionGroupOperation})\nidentity_element!(G::LieGroup{𝔽,AdditionGroupOperation}, e)\n\nReturn the a point representation of the Identity, which for the AdditionGroupOperation is the zero element or array.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket!-Union{Tuple{O}, Tuple{𝔽}, Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, <:LieGroup{𝔽, O, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Identity{O}}, Any, Any, Any}} where {𝔽, O<:AdditionGroupOperation}","page":"Group operation","title":"LieGroups.lie_bracket!","text":"lie_bracket!(𝔤::LieAlgebra{𝔽,AdditionGroupOperation}, X, Y)\nlie_bracket!(𝔤::LieAlgebra{𝔽,AdditionGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the AdditionGroupOperation simplifies to the corresponding zero_vector. The computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket-Union{Tuple{𝔽}, Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{AdditionGroupOperation}} where G<:(AbstractLieGroup{var\"#s25\", AdditionGroupOperation, M} where {var\"#s25\", M<:ManifoldsBase.AbstractManifold{var\"#s25\"}}), Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.lie_bracket","text":"lie_bracket!(𝔤::LieAlgebra{𝔽,AdditionGroupOperation}, X, Y)\nlie_bracket!(𝔤::LieAlgebra{𝔽,AdditionGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the AdditionGroupOperation simplifies to the corresponding zero_vector. The computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Manifolds.inv!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any}} where 𝔽","page":"Group operation","title":"Manifolds.inv!","text":"inv(G::LieGroup{𝔽,AdditionGroupOperation}, g)\ninv!(G::LieGroup{𝔽,AdditionGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for the AdditionGroupOperation simplifies to -g. This can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.exp!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any}} where 𝔽","page":"Group operation","title":"ManifoldsBase.exp!","text":"exp(G::LieGroup{𝔽,AdditionGroupOperation}, X)\nexp!(G::LieGroup{𝔽,AdditionGroupOperation}, g, X)\n\nCompute the Lie group exponential on a LieGroup with an AdditionGroupOperation. This can be computed in-place of g.\n\nSince e is just the zero-element with respect to the corresponding +, the formula reads g=0+X=X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.log!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any}} where 𝔽","page":"Group operation","title":"ManifoldsBase.log!","text":"log(G::LieGroup{𝔽,AdditionGroupOperation}, g)\nlog!(G::LieGroup{𝔽,AdditionGroupOperation}, X, g)\n\nCompute the Lie group logarithm on a LieGroup with an AdditionGroupOperation. This can be computed in-place of X.\n\nSince e is just the zero-element with respect to the corresponding +, the formula reads X=g-0=g.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#multiplication-operation-sec","page":"Group operation","title":"Multiplication group operation","text":"","category":"section"},{"location":"interface/operations/#LieGroups.AbstractMultiplicationGroupOperation","page":"Group operation","title":"LieGroups.AbstractMultiplicationGroupOperation","text":"AbstractMultiplicationGroupOperation <: AbstractGroupOperation\n\nA group operation that is realised introducing defaults that fall back to * being overloaded, for example _compose(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, a, b) = a * b\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#LieGroups.MatrixMultiplicationGroupOperation","page":"Group operation","title":"LieGroups.MatrixMultiplicationGroupOperation","text":"MatrixMultiplicationGroupOperation <: AbstractMultiplicationGroupOperation\n\nA group operation that is realised by a matrix multiplication.\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#Base.exp-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s25\", M} where {var\"#s25\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any}} where 𝔽","page":"Group operation","title":"Base.exp","text":"exp(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, X)\nexp!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g, X)\n\nCompute the Lie group exponential on a LieGroup with an AbstractMultiplicationGroupOperation, which simplifies to the matrix exponential.\n\nThis can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.inv-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s25\", M} where {var\"#s25\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any}} where 𝔽","page":"Group operation","title":"Base.inv","text":"inv(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g)\ninv!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for an AbstractMultiplicationGroupOperation simplifies to the multiplicative inverse g^-1. This can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.log-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s25\", M} where {var\"#s25\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any}} where 𝔽","page":"Group operation","title":"Base.log","text":"log(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g)\nlog!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, X, g)\n\nCompute the Lie group logarithm on a LieGroup with a concrete instance of AbstractMultiplicationGroupOperation, which simplifies to the (matrix) logarithm.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.compose!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s25\", M} where {var\"#s25\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.compose!","text":"compose(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g, h)\ncompose!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, k, g, h)\n\nCompute the group operation composition of g and h with respect to an AbstractMultiplicationGroupOperation on an LieGroup G, which falls back to calling g*h, where * is assumed to be overloaded accordingly.\n\nThis can be computed in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.compose-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s25\", M} where {var\"#s25\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.compose","text":"compose(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g, h)\ncompose!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, k, g, h)\n\nCompute the group operation composition of g and h with respect to an AbstractMultiplicationGroupOperation on an LieGroup G, which falls back to calling g*h, where * is assumed to be overloaded accordingly.\n\nThis can be computed in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s24\", M} where {var\"#s24\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Vararg{Any, 4}}} where 𝔽","page":"Group operation","title":"LieGroups.diff_conjugate!","text":"diff_conjugate(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1 = ghg^-1, which simplifies for an AbstractMultiplicationGroupOperationto mathrmd(c_g(h))X = gXg^-1.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s25\", M} where {var\"#s25\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.diff_conjugate","text":"diff_conjugate(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1 = ghg^-1, which simplifies for an AbstractMultiplicationGroupOperationto mathrmd(c_g(h))X = gXg^-1.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s24\", M} where {var\"#s24\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.diff_inv!","text":"diff_inv(G::LieGroup{𝔽, <:AbstractMultiplicationGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{𝔽, <:AbstractMultiplicationGroupOperation}, Y, g, X)\n\nCompute the value of differential mathrmdι_mathcal G(g)X of matrix inversion ι_mathcal G(g) = g^-1 at X  𝔤 in the LieAlgebra 𝔤 of the LieGroup G.\n\nThe (classical) differential mathrmDι_mathcal G(g) T_gmathcal G  T_g^-1mathcal G reads\n\n  mathrmDι_mathcal G(g)W = -g^-1Wg^-1 = -Xg^-1 = -g^-1(gXg^-1) = -g^-1mathrmAd(g)X = V  T_g^-1mathcal G\n\nsee e.g. [Gil08]. To bring this back to the Lie algebra, we Write V = g^-1Y  T_g^-1mathcal G for some Y  𝔤 and obtain\n\n  mathrmd ι_mathcal G(g)X = -mathrmAd(g)X  𝔤\n\nwhere we use mathrmd to denote the differential in the Lie algebra.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s24\", M} where {var\"#s24\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any, Number}} where 𝔽","page":"Group operation","title":"LieGroups.diff_inv","text":"diff_inv(G::LieGroup{𝔽, <:AbstractMultiplicationGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{𝔽, <:AbstractMultiplicationGroupOperation}, Y, g, X)\n\nCompute the value of differential mathrmdι_mathcal G(g)X of matrix inversion ι_mathcal G(g) = g^-1 at X  𝔤 in the LieAlgebra 𝔤 of the LieGroup G.\n\nThe (classical) differential mathrmDι_mathcal G(g) T_gmathcal G  T_g^-1mathcal G reads\n\n  mathrmDι_mathcal G(g)W = -g^-1Wg^-1 = -Xg^-1 = -g^-1(gXg^-1) = -g^-1mathrmAd(g)X = V  T_g^-1mathcal G\n\nsee e.g. [Gil08]. To bring this back to the Lie algebra, we Write V = g^-1Y  T_g^-1mathcal G for some Y  𝔤 and obtain\n\n  mathrmd ι_mathcal G(g)X = -mathrmAd(g)X  𝔤\n\nwhere we use mathrmd to denote the differential in the Lie algebra.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s24\", M} where {var\"#s24\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Vararg{Any, 4}}} where 𝔽","page":"Group operation","title":"LieGroups.diff_left_compose!","text":"diff_left_compose(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the group operation gh, on an AbstractLieGroup G with respect to its first (left) argument g.\n\nAnother interpretation is to consider a function where we do a fixed multiplication from the right with h. i..e. the right group multiplication function ρ_h(g) = gh.\n\nThe differential simplifies for an AbstractMultiplicationGroupOperation to\n\nmathrmd ρ_h(g)X = h^-1Xh = mathrmAd(h^-1)X  𝔤\n\nwhere mathrmAd denotes the adjoint.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s25\", M} where {var\"#s25\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.diff_left_compose","text":"diff_left_compose(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the group operation gh, on an AbstractLieGroup G with respect to its first (left) argument g.\n\nAnother interpretation is to consider a function where we do a fixed multiplication from the right with h. i..e. the right group multiplication function ρ_h(g) = gh.\n\nThe differential simplifies for an AbstractMultiplicationGroupOperation to\n\nmathrmd ρ_h(g)X = h^-1Xh = mathrmAd(h^-1)X  𝔤\n\nwhere mathrmAd denotes the adjoint.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s24\", M} where {var\"#s24\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Vararg{Any, 4}}} where 𝔽","page":"Group operation","title":"LieGroups.diff_right_compose!","text":"diff_right_compose(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_right_compose!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the group operation gh, on an AbstractLieGroup G with respect to its second (right) argument h.\n\nAnother interpretation is to consider a function where we do a fixed multiplication from the left with g. i..e. the left group multiplication function λ_g(h) = gh.\n\nIt reads for an AbstractMultiplicationGroupOperation mathrmdλ_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s25\", M} where {var\"#s25\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.diff_right_compose","text":"diff_right_compose(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_right_compose!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the group operation gh, on an AbstractLieGroup G with respect to its second (right) argument h.\n\nAnother interpretation is to consider a function where we do a fixed multiplication from the left with g. i..e. the left group multiplication function λ_g(h) = gh.\n\nIt reads for an AbstractMultiplicationGroupOperation mathrmdλ_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.identity_element!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s25\", M} where {var\"#s25\"<:MatrixMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any}} where 𝔽","page":"Group operation","title":"LieGroups.identity_element!","text":"identity_element(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation})\nidentity_element!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, e)\n\nReturn the a point representation of the Identity, which for an AbstractMultiplicationGroupOperation is the one-element or identity array.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.identity_element-Union{Tuple{LieGroup{𝔽, var\"#s25\", M} where {var\"#s25\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}}, Tuple{𝔽}} where 𝔽","page":"Group operation","title":"LieGroups.identity_element","text":"identity_element(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation})\nidentity_element!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, e)\n\nReturn the a point representation of the Identity, which for an AbstractMultiplicationGroupOperation is the one-element or identity array.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket!-Union{Tuple{O}, Tuple{𝔽}, Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, <:LieGroup{𝔽, O, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Identity{O}}, Any, Any, Any}} where {𝔽, O<:MatrixMultiplicationGroupOperation}","page":"Group operation","title":"LieGroups.lie_bracket!","text":"lie_bracket(::LieAlgebra{𝔽,MatrixMultiplicationGroupOperation}, X, Y)\nlie_bracket!(::LieAlgebra{𝔽,MatrixMultiplicationGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the MatrixMultiplicationGroupOperation yields the commutator bracket\n\nX Y = XY-YX\n\nThe computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket-Union{Tuple{𝔽}, Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{MatrixMultiplicationGroupOperation}} where G<:(AbstractLieGroup{var\"#s25\", MatrixMultiplicationGroupOperation, M} where {var\"#s25\", M<:ManifoldsBase.AbstractManifold{var\"#s25\"}}), Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.lie_bracket","text":"lie_bracket(::LieAlgebra{𝔽,MatrixMultiplicationGroupOperation}, X, Y)\nlie_bracket!(::LieAlgebra{𝔽,MatrixMultiplicationGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the MatrixMultiplicationGroupOperation yields the commutator bracket\n\nX Y = XY-YX\n\nThe computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Manifolds.inv!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s25\", M} where {var\"#s25\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any, Any}} where 𝔽","page":"Group operation","title":"Manifolds.inv!","text":"inv(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g)\ninv!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for an AbstractMultiplicationGroupOperation simplifies to the multiplicative inverse g^-1. This can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.exp!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s24\", M} where {var\"#s24\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any, Any}} where 𝔽","page":"Group operation","title":"ManifoldsBase.exp!","text":"exp(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, X)\nexp!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g, X)\n\nCompute the Lie group exponential on a LieGroup with an AbstractMultiplicationGroupOperation, which simplifies to the matrix exponential.\n\nThis can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.log!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s24\", M} where {var\"#s24\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any, Any}} where 𝔽","page":"Group operation","title":"ManifoldsBase.log!","text":"log(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g)\nlog!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, X, g)\n\nCompute the Lie group logarithm on a LieGroup with a concrete instance of AbstractMultiplicationGroupOperation, which simplifies to the (matrix) logarithm.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#multiplication-operationabelian-sec","page":"Group operation","title":"Abelian multiplication group operation","text":"","category":"section"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"Since the commutativity of some Lie groups leads to a significant simplification of computations on those groups, the abelian multiplication group operation optimizes these cases. Additionally, it provides an interface for the abelian Lie groups. Some of these can are represented by isbits-types, which don't have mutating variants of the functions.","category":"page"},{"location":"interface/operations/#LieGroups.AbelianMultiplicationGroupOperation","page":"Group operation","title":"LieGroups.AbelianMultiplicationGroupOperation","text":"AbelianMultiplicationGroupOperation <: AbstractMultiplicationGroupOperation\n\nA group operation that is realised by an abelian multiplication.\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#Base.exp-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AbelianMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, AbstractArray{<:Any, 0}}} where 𝔽","page":"Group operation","title":"Base.exp","text":"exp(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, X)\nexp(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, g, X)\nexp!(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, h, X)\nexp!(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, h, g, X)\n\nCompute the Lie group exponential on a LieGroup at a point g or the Identity with an AbelianMultiplicationGroupOperation.\n\nDue to differences in the representation of some abelian Lie groups, this method wraps a concrete implementation of a specific abelian LieGroup with inputs of type AbstractArray{<:Any,0} and supports in-place computation.\n\nThis can be computed in-place of h if h is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.inv-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s82\", M} where {var\"#s82\"<:AbelianMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Number}} where 𝔽","page":"Group operation","title":"Base.inv","text":"inv(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g)\ninv!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for the AbelianMultiplicationGroupOperation simplifies for a scalar input to the ordinary scalar inverse g^-1.\n\nDue to differences in the representation of some abelian Lie groups, this method wraps a concrete implementation of a specific abelian LieGroup with inputs of type AbstractArray{<:Any,0} and supports in-place computation.\n\nThis can be computed in-place of h if h is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.log-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AbelianMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any}} where 𝔽","page":"Group operation","title":"Base.log","text":"log(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, h)\nlog(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, g, h)\nlog!(G::LieGroup{𝔽,<:AbeliantMultiplicationGroupOperation}, X, g)\nlog!(G::LieGroup{𝔽,<:AbeliantMultiplicationGroupOperation}, X, g, h)\n\nCompute the Lie group logarithm on a LieGroup at a point g or the Identity with a concrete instance of AbelianMultiplicationGroupOperation.\n\nDue to differences in the representation of some abelian Lie groups, this method wraps a concrete implementation of a specific abelian LieGroup with inputs of type AbstractArray{<:Any,0} and supports in-place computation.\n\nThis can be computed in-place of X if X is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s12\", M} where {var\"#s12\"<:AbelianMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, AbstractArray{<:Any, 0}, AbstractArray{<:Any, 0}, AbstractArray{<:Any, 0}, AbstractArray{<:Any, 0}}} where 𝔽","page":"Group operation","title":"LieGroups.diff_conjugate!","text":"diff_conjugate(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1 = ghg^-1, which simplifies for an AbelianMultiplicationGroupOperation to mathrmd(c_g(h))X = X.\n\nThis can be computed in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s24\", M} where {var\"#s24\"<:AbelianMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any, Any, Number}} where 𝔽","page":"Group operation","title":"LieGroups.diff_conjugate","text":"diff_conjugate(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1 = ghg^-1, which simplifies for an AbelianMultiplicationGroupOperation to mathrmd(c_g(h))X = X.\n\nThis can be computed in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s82\", M} where {var\"#s82\"<:AbelianMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.diff_inv!","text":"diff_inv(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, Y, g, X)\n\nCompute the value of the differential mathrmdι_mathcal G(g)X of the inversion ι_mathcal G(g) = g^-1 at X  𝔤 in the LieAlgebra 𝔤 of the LieGroup G.\n\nIn the Abelian case, the computation simplifies to\n\nmathrmdι_mathcal G(g)X = -gXg^-1 = -X\n\nThis can be computed in-place of Y if Y is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s82\", M} where {var\"#s82\"<:AbelianMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Vararg{Any, 4}}} where 𝔽","page":"Group operation","title":"LieGroups.diff_left_compose!","text":"diff_left_compose(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the group operation gh, on an AbstractLieGroup G with respect to its first (left) argument g.\n\nAnother interpretation is to consider a function where we do a fixed multiplication from the right with h. i..e. the right group multiplication function ρ_h(g) = gh.\n\nThe differential simplifies for an AbelianMultiplicationGroupOperation to the identity, i.e. mathrmdρ_h(g)X = X.\n\nThis can be computed in-place of Y if Y is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s24\", M} where {var\"#s24\"<:AbelianMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, AbstractArray{<:Any, 0}, Any, AbstractArray{<:Any, 0}}} where 𝔽","page":"Group operation","title":"LieGroups.diff_left_compose","text":"diff_left_compose(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the group operation gh, on an AbstractLieGroup G with respect to its first (left) argument g.\n\nAnother interpretation is to consider a function where we do a fixed multiplication from the right with h. i..e. the right group multiplication function ρ_h(g) = gh.\n\nThe differential simplifies for an AbelianMultiplicationGroupOperation to the identity, i.e. mathrmdρ_h(g)X = X.\n\nThis can be computed in-place of Y if Y is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s82\", M} where {var\"#s82\"<:AbelianMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Vararg{Any, 4}}} where 𝔽","page":"Group operation","title":"LieGroups.diff_right_compose!","text":"diff_right_compose(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, g, h, X)\ndiff_right_compose!(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the group operation gh, on an AbstractLieGroup G with respect to its second (right) argument h.\n\nAnother interpretation is to consider a function where we do a fixed multiplication from the left with g. i..e. the left group multiplication function λ_g(h) = gh.\n\nThe differential simplifies for an AbelianMultiplicationGroupOperation to the identity, i.e. mathrmdλ_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s24\", M} where {var\"#s24\"<:AbelianMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, AbstractArray{<:Any, 0}, Any, AbstractArray{<:Any, 0}}} where 𝔽","page":"Group operation","title":"LieGroups.diff_right_compose","text":"diff_right_compose(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, g, h, X)\ndiff_right_compose!(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the group operation gh, on an AbstractLieGroup G with respect to its second (right) argument h.\n\nAnother interpretation is to consider a function where we do a fixed multiplication from the left with g. i..e. the left group multiplication function λ_g(h) = gh.\n\nThe differential simplifies for an AbelianMultiplicationGroupOperation to the identity, i.e. mathrmdλ_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.identity_element!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AbelianMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any}} where 𝔽","page":"Group operation","title":"LieGroups.identity_element!","text":"identity_element(G::LieGroup{𝔽,AbelianMultiplicationGroupOperation})\nidentity_element!(G::LieGroup{𝔽,AbelianMultiplicationGroupOperation}, e)\n\nReturn the point representation of the Identity, which for an AbelianMultiplicationGroupOperation is the one-element.\n\nThis can be computed in e if e is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.identity_element-Union{Tuple{T}, Tuple{𝔽}, Tuple{LieGroup{𝔽, AbelianMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Type{T}}} where {𝔽, T<:Union{Number, AbstractArray{0, <:Number}}}","page":"Group operation","title":"LieGroups.identity_element","text":"identity_element(G::LieGroup{𝔽,AbelianMultiplicationGroupOperation})\nidentity_element!(G::LieGroup{𝔽,AbelianMultiplicationGroupOperation}, e)\n\nReturn the point representation of the Identity, which for an AbelianMultiplicationGroupOperation is the one-element.\n\nThis can be computed in e if e is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket!-Union{Tuple{O}, Tuple{𝔾}, Tuple{𝔽}, Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, <:LieGroup{𝔾, O, M} where M<:ManifoldsBase.AbstractManifold{𝔾}, Identity{O}}, Any, Any, Any}} where {𝔽, 𝔾, O<:AbelianMultiplicationGroupOperation}","page":"Group operation","title":"LieGroups.lie_bracket!","text":"lie_bracket(::LieAlgebra{𝔽,AbelianMultiplicationGroupOperation}, X, Y)\nlie_bracket!(::LieAlgebra{𝔽,AbelianMultiplicationGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the AbelianMultiplicationGroupOperation yields the zero vector of the LieAlgebra due to commutativity.\n\nX Y = XY-YX = 0\n\nThe computation can be done in-place of Z if Z is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket-Union{Tuple{O}, Tuple{𝔾}, Tuple{𝔽}, Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, <:LieGroup{𝔾, O, M} where M<:ManifoldsBase.AbstractManifold{𝔾}, Identity{O}}, Number, Number}} where {𝔽, 𝔾, O<:AbelianMultiplicationGroupOperation}","page":"Group operation","title":"LieGroups.lie_bracket","text":"lie_bracket(::LieAlgebra{𝔽,AbelianMultiplicationGroupOperation}, X, Y)\nlie_bracket!(::LieAlgebra{𝔽,AbelianMultiplicationGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the AbelianMultiplicationGroupOperation yields the zero vector of the LieAlgebra due to commutativity.\n\nX Y = XY-YX = 0\n\nThe computation can be done in-place of Z if Z is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Manifolds.inv!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s83\", M} where {var\"#s83\"<:AbelianMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any, Any}} where 𝔽","page":"Group operation","title":"Manifolds.inv!","text":"inv(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g)\ninv!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for the AbelianMultiplicationGroupOperation simplifies for a scalar input to the ordinary scalar inverse g^-1.\n\nDue to differences in the representation of some abelian Lie groups, this method wraps a concrete implementation of a specific abelian LieGroup with inputs of type AbstractArray{<:Any,0} and supports in-place computation.\n\nThis can be computed in-place of h if h is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.exp!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AbelianMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any}} where 𝔽","page":"Group operation","title":"ManifoldsBase.exp!","text":"exp(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, X)\nexp(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, g, X)\nexp!(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, h, X)\nexp!(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, h, g, X)\n\nCompute the Lie group exponential on a LieGroup at a point g or the Identity with an AbelianMultiplicationGroupOperation.\n\nDue to differences in the representation of some abelian Lie groups, this method wraps a concrete implementation of a specific abelian LieGroup with inputs of type AbstractArray{<:Any,0} and supports in-place computation.\n\nThis can be computed in-place of h if h is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.log!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AbelianMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any}} where 𝔽","page":"Group operation","title":"ManifoldsBase.log!","text":"log(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, h)\nlog(G::LieGroup{𝔽,<:AbelianMultiplicationGroupOperation}, g, h)\nlog!(G::LieGroup{𝔽,<:AbeliantMultiplicationGroupOperation}, X, g)\nlog!(G::LieGroup{𝔽,<:AbeliantMultiplicationGroupOperation}, X, g, h)\n\nCompute the Lie group logarithm on a LieGroup at a point g or the Identity with a concrete instance of AbelianMultiplicationGroupOperation.\n\nDue to differences in the representation of some abelian Lie groups, this method wraps a concrete implementation of a specific abelian LieGroup with inputs of type AbstractArray{<:Any,0} and supports in-place computation.\n\nThis can be computed in-place of X if X is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Literature","page":"Group operation","title":"Literature","text":"","category":"section"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"M. B. Giles. Collected Matrix Derivative Results for Forward and Reverse Mode Algorithmic Differentiation. In: Advances in Automatic Differentiation, Lecture Notes in Computational Science and Engineering, edited by C. H. Bischof, H. M. Bücker, P. Hovland, U. Naumann and J. Utke (Springer, Berlin, Heidelberg, 2008); pp. 35–44.\n\n\n\n","category":"page"},{"location":"about/#About-LieGroups.jl","page":"About","title":"About LieGroups.jl","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"The package LieGroups.jl in its current form started in 2024 as a “spin-off” from Manifolds.jl, where a type GroupManifolds was a predecessor of the main LieGroup type of this package. That approach started around 2021 by Seth Axen. At about the same, Yueh-Hua Tu started a package LieGroups.jl, which was continued then here with a full rewrite in order to base all Lie groups on a manifold from Manifolds.jl.","category":"page"},{"location":"about/","page":"About","title":"About","text":"The current main developers are Ronny Bergmann and Mateusz Baran.","category":"page"},{"location":"about/#Contributors","page":"About","title":"Contributors","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"Thanks to the following contributors to LieGroups.jl:","category":"page"},{"location":"about/","page":"About","title":"About","text":"Paula Conrad and Leonard Schreiter implemented the Circle group as part of their student assistant project.\nOlivier Verdier helped in the design and some mathematical explanations\nJohannes Terblanche implemented the SpecialGalileanGroup.","category":"page"},{"location":"about/","page":"About","title":"About","text":"as well as contributors providing small extensions, finding small bugs and mistakes and fixing them by opening PRs. Thanks to all of you.","category":"page"},{"location":"about/","page":"About","title":"About","text":"If you want to contribute a manifold or algorithm or have any questions, visit the GitHub repository to clone/fork the repository or open an issue.","category":"page"},{"location":"about/#Work-using-LieGroups.jl","page":"About","title":"Work using LieGroups.jl","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"If LieGroups.jl is useful within another package or in your project, we would like to list that here. Please open an issue. It would be great to collect anything and anyone using LieGroups.jl in this list.","category":"page"},{"location":"interface/actions/#An-Interface-for-Lie-group-actions","page":"Group action","title":"An Interface for Lie group actions","text":"","category":"section"},{"location":"interface/actions/#LieGroups.AbstractActionActsOnType","page":"Group action","title":"LieGroups.AbstractActionActsOnType","text":"AbstractActionActsOnType\n\nAn abstract type representing what an action acts on, Most notably these are the ActionActsOnLeft and ActionActsOnRight, see their documentations for more details.\n\nFor its practical use see the SemidirectProductGroupOperation.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.AbstractGroupActionType","page":"Group action","title":"LieGroups.AbstractGroupActionType","text":"AbstractGroupActionType\n\nAn abstract supertype for group action types, which are used within a GroupAction.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.AbstractLeftGroupActionType","page":"Group action","title":"LieGroups.AbstractLeftGroupActionType","text":"AbstractLeftGroupActionType <: AbstractGroupActionType\n\nA type representing a (smooth) group action σ mathcal G  mathcal M  mathcal M of a AbstractLieGroup mathcal G acting (from the left) on an AbstractManifold mathcal M. with the following properties\n\nσ(mathrme p) = p holds for all p  mathcal M\nσ(g σ(h p)) = σ(gh p) holds for all gh  mathcal G, p  mathcal M\n\nwhere  denotes the group operation of the AbstractLieGroup mathcal G. See also [HN12, Definition 9.1.11].\n\nThe type of action can be seen a bit better when writing the action as a family σ_g(p): we obtain from the second property as\n\n  σ_g(σ_h(p)) = σ_gh(p)\n\nand see that g appears on the left.\n\nWhen writing about general group actions, the symbol α is often used. The order of arguments then follows the same as the one of the left action. Most often we use the index notation α_g(p). The definition of functions also follows this notation, i.e. we use e.g. apply(A, g, p)\n\nOne notable example of a left action is the inverse of an action of AbstractRightGroupActionType τ, which is given by σ_g = (τ_g)^-1 = τ_g^-1. We obtain\n\nσ_g(σ_h(p))\n= τ_g^-1(τ_h^-1(p))\n= τ_h^-1g^-1(p)\n= τ_(gh)^-1(p)\nσ_gh(p)\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.AbstractRightGroupActionType","page":"Group action","title":"LieGroups.AbstractRightGroupActionType","text":"AbstractRightGroupActionType <: AbstractGroupActionType\n\nA type representing a (smooth) group action τ mathcal M  mathcal G  mathcal M of a AbstractLieGroup mathcal G acting (from the right) on an AbstractManifold mathcal M. with the following properties\n\nτ(p mathrme) = p holds for all p  mathcal M\nτ(τ(p g) h) = τ(τ(p g) h) holds for all gh  mathcal G, p  mathcal M\n\nwhere  denotes the group operation of the AbstractLieGroup mathcal G. See also [HN12, Remark 9.1.12].\n\nThe type of action can be seen a bit better when writing the action as a family τ_g(p): we obtain from the second property as\n\n  τ_g(τ_h(p)) = τ_hg(p)\n\nand see that g appears on the right.\n\nWhen writing about general group actions, the symbol α is often used. In that case the order of arguments follows either the one from the left action, but most often we use the index notation. The definition of functions also follows this notation, i.e. we use e.g. apply(A, g, p)\n\nOne notable example of a right action is the inverse of an action of AbstractLeftGroupActionType σ, which is given by τ_g = (σ_g)^-1 = σ_g^-1. We obtain\n\nτ_g(τ_h(p))\n= σ_g^-1(σ_h^-1(p))\n= σ_g^-1h^-1(p)\n= σ_(hg)^-1(p)\nτ_hg(p)\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.ActionActsOnLeft","page":"Group action","title":"LieGroups.ActionActsOnLeft","text":"ActionActsOnLeft <: AbstractActionActsOnType\n\nAn AbstractActionActsOnType representing that an action acts on the left.\n\nThis is meant in the following way: Given a GroupAction α mathcal G  mathcal H  mathcal H where a Lie group mathcal G acts on another Lie group mathcal H with an arbitrary action.\n\nThen, e.g. within the definition of the LeftSemidirectProductGroupOperation or RightSemidirectProductGroupOperation, we have two choices where the group action α acts on, namely: Let g  mathcal G and h_1h_2  mathcal H be given, then this type represents the variant\n\nα_g(h_1)  h_2\n\nwhere  denotes the group operation on mathcal H. The Left in the name of this type refers to the fact that the action is applied to the left element h_1.\n\nNote that this is independent of both the type of action (left or right) and whether the semidirect product is a left or a right semidirect one.\n\nFor its practical use see the SemidirectProductGroupOperation.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.ActionActsOnRight","page":"Group action","title":"LieGroups.ActionActsOnRight","text":"ActionActsOnRight <: AbstractActionActsOnType\n\nAn AbstractActionActsOnType representing that an action acts on the right.\n\nThis is meant in the following way: Given a GroupAction α mathcal G  mathcal H  mathcal H where a Lie group mathcal G acts on another Lie group mathcal H with an arbitrary action.\n\nThen, e.g. within the definition of the LeftSemidirectProductGroupOperation or RightSemidirectProductGroupOperation, we have two choices where the group action α acts on, namely: Let g  mathcal G and h_1h_2  mathcal H be given, then this type represents the variant\n\nh_1  α_g(h_2)\n\nwhere  denotes the group operation on mathcal H. The Right in the name of this type refers to the fact that the action is applied to the right element h_2.\n\nNote that this is independent of both the type of action (left or right) and whether the semidirect product is a left or a right semidirect one.\n\nFor its practical use see the SemidirectProductGroupOperation.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.GroupAction","page":"Group action","title":"LieGroups.GroupAction","text":"GroupAction{T<:GroupActionType, L<:LieGroup, M<:AbstractManifold}\n\nSpecify a group action of AbstractGroupActionType T of a AbstractLieGroup G acting on an AbstractManifold M.\n\nLet mathcal M be a AbstractManifold and mathcal G be a AbstractLieGroup with group operation .\n\nA (smooth) action of the group mathcal G on the manifold mathcal M is a map\n\nα mathcal G  mathcal M  mathcal M\n\nwith the properties\n\nIdentity. α(mathrme p) = p holds for all p  mathcal M\n\nCompatibility. If α is a AbstractLeftGroupActionType we usually denote it by σ and the compatibility reads\n\nσ_g(σ_h(p)) = σ_gh(p) text holds for all gh  mathcal G text and p  mathcal M\n\nIf α is a AbstractRightGroupActionType we usually denote it by τ and the compatibility reads\n\nτ_g(τ_h(p)) = τ_hg(p) holds for all gh  mathcal G text for all p  mathcal M\n\nintuitively the left/right property of an action specifies on which side the “outer” group actions element g gets “appended” in the composition.\n\nFields\n\ntype::AbstractGroupActionType: The type of the group action.\ngroup::AbstractLieGroup: The group acting.\nmanifold::AbstractManifold: The manifold the group acts upon.\n\nSee [HN12, Section 9.1.3] for more details.\n\nConstructors\n\nGroupAction(\n    group::AbstractLieGroup, manifold::ManifoldsBase.AbstractManifold, type::AbstractGroupActionType\n)\n\nGenerate a group action where the type of the action and what it acts on are keyword arguments. They default to the most common choice, that the ActionActsOnRight.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#Functions-for-Lie-group-actions","page":"Group action","title":"Functions for Lie group actions","text":"","category":"section"},{"location":"interface/actions/#Base.inv-Tuple{AbstractGroupActionType}","page":"Group action","title":"Base.inv","text":"inv(::AbstractGroupActionType)\n\nreturn the inverse group operation action, that is, use the type representing the inverse operation.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Base.inv-Tuple{GroupAction}","page":"Group action","title":"Base.inv","text":" inv(A::GroupAction{T})\n\nReturn the GroupAction representing the inverse of an GroupAction of AbstractGroupActionType T. This is usually done by returning the group action with the inverse type of T.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.apply!-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"LieGroups.apply!","text":"apply(A::GroupAction{T}, g, p)\napply!(A::GroupAction{T}, q, g, p)\n\nApply the group action induced by g  mathcal G to p  mathcal M, where the kind of group action is indicated by the AbstractGroupActionType T. This can be performed in-place of q.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.apply-Tuple{GroupAction, Any, Any}","page":"Group action","title":"LieGroups.apply","text":"apply(A::GroupAction{T}, g, p)\napply!(A::GroupAction{T}, q, g, p)\n\nApply the group action induced by g  mathcal G to p  mathcal M, where the kind of group action is indicated by the AbstractGroupActionType T. This can be performed in-place of q.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.base_lie_group-Tuple{GroupAction}","page":"Group action","title":"LieGroups.base_lie_group","text":"base_lie_group(A::GroupAction)\n\nReturn the AbstractLieGroup of the GroupAction specifying the action.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.default_left_action-Tuple{AbstractLieGroup, ManifoldsBase.AbstractManifold}","page":"Group action","title":"LieGroups.default_left_action","text":"default_left_action(G::AbstractLieGroup, M::AbstractManifold)\n\nReturn the default left action for a Lie group G acting on a manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.default_right_action-Tuple{AbstractLieGroup, ManifoldsBase.AbstractManifold}","page":"Group action","title":"LieGroups.default_right_action","text":"default_right_action(G::AbstractLieGroup, M::AbstractManifold)\n\nReturn the default right action for a Lie group G acting on a manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.diff_apply!-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"LieGroups.diff_apply!","text":"diff_apply(A::GroupAction, g, p, X)\ndiff_apply!(A::GroupAction, Y, g, p, X)\n\nCompute the differential mathrmD_p α_g(p) T_pmathcal M  T_σ_g(p)mathcal M.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.diff_apply-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"LieGroups.diff_apply","text":"diff_apply(A::GroupAction, g, p, X)\ndiff_apply!(A::GroupAction, Y, g, p, X)\n\nCompute the differential mathrmD_p α_g(p) T_pmathcal M  T_σ_g(p)mathcal M.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.diff_group_apply!-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"LieGroups.diff_group_apply!","text":"diff_group_apply(A::GroupAction, g, p, X)\ndiff_group_apply!(A::GroupAction, Y, g, p, X)\n\nCompute the value of differential of action GroupAction A on vector X, where element g is acting on p, with respect to the group element.\n\nLet mathcal G be the group acting on manifold mathcal M by the action A. The action is of element g  mathcal G on a point p  mathcal M. The differential transforms vector X from the tangent space at a ∈ \\mathcal G, X  T_a mathcal G into a tangent space of the manifold mathcal M. When action on element p is written as mathrmdτ^p, with the specified left or right convention, the differential transforms vectors\n\n(mathrmdτ^p)  T_a mathcal G  T_τ_a p mathcal M\n\nSee also\n\napply, diff_apply\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.diff_group_apply-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"LieGroups.diff_group_apply","text":"diff_group_apply(A::GroupAction, g, p, X)\ndiff_group_apply!(A::GroupAction, Y, g, p, X)\n\nCompute the value of differential of action GroupAction A on vector X, where element g is acting on p, with respect to the group element.\n\nLet mathcal G be the group acting on manifold mathcal M by the action A. The action is of element g  mathcal G on a point p  mathcal M. The differential transforms vector X from the tangent space at a ∈ \\mathcal G, X  T_a mathcal G into a tangent space of the manifold mathcal M. When action on element p is written as mathrmdτ^p, with the specified left or right convention, the differential transforms vectors\n\n(mathrmdτ^p)  T_a mathcal G  T_τ_a p mathcal M\n\nSee also\n\napply, diff_apply\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{AbstractGroupActionType}","page":"Group action","title":"LieGroups.switch","text":"switch(T::AbstractGroupActionType)\n\nReturn the object representing an AbstractGroupActionType related to a group operation action that switched the side, that is it turns a left action type into its corresponding right action type.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{GroupAction}","page":"Group action","title":"LieGroups.switch","text":" switch(A::GroupAction{T})\n\nReturn the group operation action representing the similar GroupAction of AbstractGroupActionType T but acting from the other side. It switches left to right and vice versa. This is done by returning the group action with the “switched” type of T.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#ManifoldsBase.base_manifold-Tuple{GroupAction}","page":"Group action","title":"ManifoldsBase.base_manifold","text":"base_manifold(A::GroupAction)\n\nReturn the AbstractManifold the group action acts upon.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Generic-Lie-group-actions","page":"Group action","title":"Generic Lie group actions","text":"","category":"section"},{"location":"interface/actions/#LieGroups.AdditionGroupAction","page":"Group action","title":"LieGroups.AdditionGroupAction","text":"AdditionGroupAction <: AbstractLeftGroupActionType\n\nSpecify that in a GroupAction with Lie group mathcal G and manifold mathcal M, where the group action is given by addition\n\nGiven an element g  mathcal G and a point p  mathcal M, the family of actions σ_g mathcal M  mathcal M is given by\n\nσ_g(p) = g + p\n\nwhere + denotes the vector or matrix addition.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.InverseLeftGroupOperationAction","page":"Group action","title":"LieGroups.InverseLeftGroupOperationAction","text":"InverseLeftGroupOperationAction <: AbstractRightGroupActionType\n\nA type for the AbstractLeftGroupActionType when acting on the group itself given by the inverse of a LeftGroupOperationAction σ_h as\n\nτ_h(g) coloneqq σ_h^-1(g) = σ(h^-1g) = h^-1g\n\nNote that while in naming it is the inverse of the left action, it's properties yield that is is an AbstractRightGroupActionType, since\n\nτ_g(τ_h(p))\n= σ_g^-1(σ_h^-1(p))\n= σ_g^-1h^-1(p)\n= σ_(hg)^-1(p)\nτ_hg(p)\n\nfor its inverse (σ_h)^-1 see InverseLeftGroupOperationAction.\n\nnote: Note\nSome literature also calls this by itself the right group operation action.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.InverseRightGroupOperationAction","page":"Group action","title":"LieGroups.InverseRightGroupOperationAction","text":"InverseRightGroupOperationAction <: AbstractLeftGroupActionType\n\nA type for the AbstractLeftGroupActionType when acting on the group itself given by the inverse of a RightGroupOperationAction σ_h as\n\nτ_h(g) coloneqq σ_h^-1(g) = σ(h^-1g) = gh^-1\n\nNote that while in naming it is the inverse of the right action, it's properties yield that is is an AbstractLeftGroupActionType, since\n\nσ_g(σ_h(p))\n= τ_g^-1(τ_h^-1(p))\n= τ_h^-1g^-1(p)\n= τ_(gh)^-1(p)\nσ_gh(p)\n\nfor its inverse (σ_h)^-1 see InverseLeftGroupOperationAction.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.LeftGroupOperationAction","page":"Group action","title":"LieGroups.LeftGroupOperationAction","text":"LeftGroupOperationAction <: AbstractLeftGroupActionType\n\nA type for the AbstractLeftGroupActionType when acting on the group itself from the left, that is\n\nσ_h(g) = σ(hg) = hg\n\nfor its inverse (σ_h)^-1 see InverseLeftGroupOperationAction.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.RightGroupOperationAction","page":"Group action","title":"LieGroups.RightGroupOperationAction","text":"RightGroupOperationAction <: AbstractRightGroupActionType\n\nA type for the AbstractRightGroupActionType when acting on the group itself from the right.\n\nσ_h(g) = σ(hg) = gh\n\nfor its inverse (σ_h)^-1 see InverseRightGroupOperationAction.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#Base.inv-Tuple{InverseLeftGroupOperationAction}","page":"Group action","title":"Base.inv","text":"inv(::InverseLeftGroupOperationAction)\n\nReturn the inverse of the InverseLeftGroupOperationAction, that is the LeftGroupOperationAction.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Base.inv-Tuple{InverseRightGroupOperationAction}","page":"Group action","title":"Base.inv","text":"inv(::InverseRightGroupOperationAction)\n\nReturn the inverse of the InverseRightGroupOperationAction, that is the RightGroupOperationAction.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Base.inv-Tuple{LeftGroupOperationAction}","page":"Group action","title":"Base.inv","text":"inv(::LeftGroupOperationAction)\n\nReturn the inverse of the LeftGroupOperationAction, that is the InverseLeftGroupOperationAction.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Base.inv-Tuple{RightGroupOperationAction}","page":"Group action","title":"Base.inv","text":"inv(::RightGroupOperationAction)\n\nReturn the inverse of the RightGroupOperationAction, that is the InverseRightGroupOperationAction.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.GroupOperationAction","page":"Group action","title":"LieGroups.GroupOperationAction","text":"GroupOperationAction(group::LieGroup, action=LeftGroupOperationAction(), on=ActionActsOnLeft())\n\nReturn a GroupAction for an AbstractGroupActionType action representing the group operation as an action of the group on itself.\n\n\n\n\n\n","category":"function"},{"location":"interface/actions/#LieGroups.switch-Tuple{InverseLeftGroupOperationAction}","page":"Group action","title":"LieGroups.switch","text":"switch(::InverseLeftGroupOperationAction)\n\nReturn the InverseRightGroupOperationAction, that is, turns σ_g = g^-1h into τ_g(h) = hg^-1\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{InverseRightGroupOperationAction}","page":"Group action","title":"LieGroups.switch","text":"switch(::InverseRightGroupOperationAction)\n\nReturn the InverseLeftGroupOperationAction, that is, turns τ_g = hg^-1 into σ_g(h) = g^-1h\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{LeftGroupOperationAction}","page":"Group action","title":"LieGroups.switch","text":"switch(::LeftGroupOperationAction)\n\nReturn the RightGroupOperationAction, that is, turns σ_g(h) = gh into τ_g(h) = hg\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{RightGroupOperationAction}","page":"Group action","title":"LieGroups.switch","text":"switch(::RightGroupOperationAction)\n\nReturn the LeftGroupOperationAction, that is, turns τ_g(h) = hg into τ_g = gh\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.ColumnwiseGroupAction","page":"Group action","title":"LieGroups.ColumnwiseGroupAction","text":"ColumnwiseGroupAction{A<:AbstractGroupActionType} <: AbstractGroupActionType\n\nA type for an action that applies a group action column-wise on a manifold, where a column-wise interpretation makes sense, e.g. a matrix-manifold.\n\nFields\n\naction::A: The group action to be applied column-wise.\n\nConstructor\n\nColumnwiseGroupAction(action::AbstractGroupActionType)\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.LeftMultiplicationGroupAction","page":"Group action","title":"LieGroups.LeftMultiplicationGroupAction","text":"LeftMultiplicationGroupAction <: AbstractLeftGroupActionType\n\nSpecify that in a GroupAction with Lie group mathcal G and manifold mathcal M, where the group action is given by multiplication from the left:\n\nGiven an element g  mathcal G and a point p  mathcal M, the family of actions σ_g mathcal M  mathcal M is given by\n\nσ_g(p) = g*p\n\nwhere * denotes the matrix(-vector) multiplication.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.RotationAroundAxisAction","page":"Group action","title":"LieGroups.RotationAroundAxisAction","text":"RotationAroundAxisAction(axis::AbstractVector)\n\nSpace of actions of the circle group CircleGroup on ℝ^3 around given axis.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.apply-Tuple{GroupAction{<:RotationAroundAxisAction}, Any, Any}","page":"Group action","title":"LieGroups.apply","text":"apply(A::GroupAction{<:RotationAroundAxisAction}, θ, p)\n\nRotate point p from Euclidean manifold around axis A.axis by angle θ. The formula reads\n\np_rot = (cos(θ))p + (kp) sin(θ) + k (kp) (1-cos(θ))\n\nwhere k is the vector A.type.axis and ⋅ is the dot product.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.RowwiseGroupAction","page":"Group action","title":"LieGroups.RowwiseGroupAction","text":"RowwiseGroupAction{A<:AbstractGroupActionType} <: AbstractGroupActionType\n\nA type for an action that applies a group action row-wise on a manifold, where a row-wise interpretation makes sense, e.g. a matrix-manifold.\n\nFields\n\naction::A: The group action to be applied row-wise.\n\nConstructor\n\nRowwiseGroupAction(action::AbstractGroupActionType)\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#Literature","page":"Group action","title":"Literature","text":"","category":"section"},{"location":"interface/actions/","page":"Group action","title":"Group action","text":"J. Hilgert and K.-H. Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\n","category":"page"},{"location":"news/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"All notable Changes to the Julia package LieGroups.jl will be documented in this file.","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"news/#[0.1.8](https://github.com/JuliaManifolds/LieGroups.jl/releases/tag/v0.1.8)-(2025-10-31)","page":"Changelog","title":"0.1.8 (2025-10-31)","text":"","category":"section"},{"location":"news/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"a MetricLieGroup as a meta type to be able to change the metric imposed on the Lie algebra and its effects e.g. on the coordinates, inner product and the exponential and logarithmic map.\ndiff_left_compose and diff_right_compose for the special Euclidean group.\nsubmanifold_components now works with Identity{<:ProductGroupOperation}.\nzero_vector(G, Identity(G)) returns the zero vector in default representation.","category":"page"},{"location":"news/#Fixed","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"fixed the contributing.md to mention runic as the code formatter.\ndiff_left_compose correctly allocates when g is Identity.\ninit_constants! fixed for SpecialEuclideanMatrixTangentVector and SpecialEuclideanMatrixPoint.","category":"page"},{"location":"news/#[0.1.7](https://github.com/JuliaManifolds/LieGroups.jl/releases/tag/v0.1.7)-(2025-10-28)","page":"Changelog","title":"0.1.7 (2025-10-28)","text":"","category":"section"},{"location":"news/#Added-2","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"NestedPowerRepresentation and NestedReplacingPowerRepresentation are now re-exported from ManifoldsBase.jl.\ngetindex access to parts of a point of tangent vector represented by a matrix with :Rotation and :Translation as indices. For example, when g is a point on any variant of the special euclidean group, g[G, :Translation] will return the translation part of g regardless of whether G is the left or right semidirect product even when g is a matrix.","category":"page"},{"location":"news/#Fixed-2","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Zenodo metadata.","category":"page"},{"location":"news/#[0.1.6](https://github.com/JuliaManifolds/LieGroups.jl/releases/tag/v0.1.6)-(2025-10-10)","page":"Changelog","title":"0.1.6 (2025-10-10)","text":"","category":"section"},{"location":"news/#Fixed-3","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"diff_group_apply has corrected documentation and works with g equal to Identity.","category":"page"},{"location":"news/#[0.1.5](https://github.com/JuliaManifolds/LieGroups.jl/releases/tag/v0.1.5)-(2025-10-09)","page":"Changelog","title":"0.1.5 (2025-10-09)","text":"","category":"section"},{"location":"news/#Changed","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"LieGroups.jl now requires ManifoldsBase.jl v2.0 and Manifolds.jl v0.11.","category":"page"},{"location":"news/#[0.1.4](https://github.com/JuliaManifolds/LieGroups.jl/releases/tag/v0.1.4)-(2025-10-02)","page":"Changelog","title":"0.1.4 (2025-10-02)","text":"","category":"section"},{"location":"news/#Added-3","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"mention adjoint_matrix in the transition documentation (#52)\nintroduce jacobian_exp for the Jacobian of the exponential function.\nIntroduce a AbstractActionActsOnType to distinguish, what previously was called “side”, i.e. whether an action acts on the left (ActionActsOnLeft) or right (ActionActsOnRight)\nIntroduce _inv and _inv! functions for the inverse operation to work the same way as _compose and _compose!, respectively.\nintroduce a LeftMultiplicationGroupAction to represent left multiplication actions on Lie groups. While this is a bit more of a technical name, it replaces the old ComplexPlanarRotation, QuaternionRotation, and RotationAction, since in the GroupAction this type is coupled with a group and a manifold anyway.\nfurther methods for the LeftMultiplicationGroupAction to cover the previous functionality of e.g.\nRotationTranslationActionOnVector\nAdd the Special Galilean Group (#60)","category":"page"},{"location":"news/#Fixed-4","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Fixed an issue where internally the product manifold in a SemidirectProductLieGroup was accidentally splashed\nmake × and ProductLieGroup behave the same way as × and ProductManifold do\nFixed an issue, where exp!(G, h, g, X) would return a wrong result if the input gand the output hare aliased (#63).\nFixed issues with the documentation of diff_left_compose and diff_right_compose that were inconsistent\nfixed push_forward_tangent and pull_back_tangent which on general Lie groups provided a wrong default.\nfixes an allocation bug for apply and diff_apply (#52)","category":"page"},{"location":"news/#[0.1.3](https://github.com/JuliaManifolds/LieGroups.jl/releases/tag/v0.1.3)-(2025-08-04)","page":"Changelog","title":"0.1.3 (2025-08-04)","text":"","category":"section"},{"location":"news/#Added-4","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"introduce push_forward_tangent and pull_back_tangent to combine the differential of left compose and its inverse to “move” from the Lie algebra to a certain tangent space and back, but also takes care of adapting the representation, for the case where the representation on the manifold is different from the one on the Lie group / Lie algebra.\nintroduce a BaseManifoldRetraction to be able to use retractions on the underlying manifold also as a retraction on the Lie group, cf. (#43) and (#47). This feature assumes that the representation of points and tangent vectors on Lie group and the underlying manifold are the same (so it doesn't work with special Euclidean group with homogeneous coordinates).","category":"page"},{"location":"news/#Changed-2","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Switch to using Runic.jl as code formatter","category":"page"},{"location":"news/#Fixed-5","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Fixed a typo, where within was misspelled as widthin which caused errors in a few places.\nfix default_basis for LieGroup to return a DefaultLieAlgebraOrthogonalBasis also when providing a point type. That way get_vector falls back to the manifold when called with a Lie group and a point, though this is mere a historical format and the Lie algebra approach is the recommended one.\nmention get_coordinates, get_vector, hat, and vee in the transition documentation since it moved to using the LieAlgebra instead of the Lie group and a point.\nFixed RightGroupOperationAction to be a subtype of AbstractRightGroupActionType\nAdd lie_bracket for the SpecialEuclideanGroup.\nFor the CircleGroup(ℝ), fixed compose StackOverflowError and a bug where result could be outside [-π,π), see (#62) for detail.","category":"page"},{"location":"news/#[0.1.2](https://github.com/JuliaManifolds/LieGroups.jl/releases/tag/v0.1.2)-(2025-06-24)","page":"Changelog","title":"0.1.2 (2025-06-24)","text":"","category":"section"},{"location":"news/#Added-5","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"is_flat for SpecialEuclideanGroup\ninner and norm for LieAlgebra to compute the inner product and norm on the Lie algebra.\na test suite function for identity_element.\nNew StaticArrays.jl specializations for multiple functions, including:\nexp and log on the orthogonal and special orthogonal group in 2 and 3 dimensions.\nget_coordinates and get_vector on the orthogonal and special orthogonal group in 2 and 3 dimensions, for LieAlgebraOrthogonalBasis.\nMore generic implementation of non-mutating get_vector_lie on AbstractProductGroupOperation groups.","category":"page"},{"location":"news/#Changed-3","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"identity_element on UnitaryGroup(1, ℍ) now returns by default a 1x1 Matrix instead of a number to be consistent with higher-dimensional unitary quaternionic groups. Use identity_element(UnitaryGroup(1, ℍ), QuaternionF64) to get a number corresponding to the identity.","category":"page"},{"location":"news/#Fixed-6","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"get_vector on SpecialEuclideanGroup with ArrayPartition point type.\nidentity_element and zero_vector are now all using a type as second argument and respect this type more thoroughly.\nfixes (#44) (accuracy of log on SE(2) and SE(3) for small angles).","category":"page"},{"location":"news/#[0.1.1](https://github.com/JuliaManifolds/LieGroups.jl/releases/tag/v0.1.1)-(2025-05-05)","page":"Changelog","title":"0.1.1 (2025-05-05)","text":"","category":"section"},{"location":"news/#Added-6","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"identity_element on TranslationGroup supports now StaticArrays.jl types.\nintroduce get_vector in legacy form to work on Lie groups, but they pass on to their Lie algebra.\nadapt to the new default_basis from ManifoldsBase.jl 1.1.","category":"page"},{"location":"news/#Changed-4","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"the tutorials are now rendered with quarto using the QuartoNotebookRunner.jl and are hence purely julia based.","category":"page"},{"location":"news/#Fixed-7","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"identity_element on TranslationGroup no longer accepts a number as a second argument (it accepts number type instead).","category":"page"},{"location":"news/#[0.1.0](https://github.com/JuliaManifolds/LieGroups.jl/releases/tag/v0.1.0)-(2025-04-22)","page":"Changelog","title":"0.1.0 (2025-04-22)","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Everything denoted by “formerly” refers to the previous name in Manifolds.jl. Several structs have been changed from the pre-release, so these are breaking.","category":"page"},{"location":"news/#Added-7","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"LieAlgebra\nLieGroup (formerly GroupManifold) as well as the concrete groups\nTranslationGroup\nSpecialEuclideanGroup (formerly SpecialEuclidean) including\nSpecialEuclideanMatrixPoint and SpecialEuclideanMatrixTangentVector when representing the points as affine (abstract) matrices\nSpecialEuclideanProductPoint and SpecialEuclideanProductTangentVector when representing them in a product structure, that is as an ArrayPartition from RecursiveArrayTools.\nneither of those types is necessary, besides for conversion between both. The product representation differs for the left and right semidirect product, while the affine matrix variant does not.\nSpecialOrthogonalGroup (formerly SpecialOrthogonal)\nSpecialUnitaryGroup (formerly SpecialUnitary)\nOrthogonalGroup (formerly Orthogonal)\nUnitaryGroup (formerly Unitary) also for quaternions.\nGeneralLinearGroup (formerly GeneralLinear)\nHeisenbergGroup\nLeftSemidirectProductLieGroup (formerly SemidirectProductGroup)\n⋉ (alias for LeftSemidirectProductGroupOperation when a default_left_action(G,H) is defined for the two groups)\nPowerLieGroup (formerly PowerGroup)\nPowerGroupOperation to internally avoid ambiguities. Since the constructor always expects a Lie group, this is only necessary internally\nProductLieGroup (formerly ProductGroup)\nRightSemidirectProductLieGroup\nSpecialLinearGroup (formerly SpecialLinear)\nSymplecticGroup\nCircleGroup now with even three representations: Real line (mod 2π), Complex and plane circle\n⋊ (alias for RightSemidirectProductGroupOperation when a default_right_action(G,H) is defined for the two groups)\na ValidationLieGroup verifying input and output of all interface functions, similar to the ValidationManifold which can also be used internally.\nAbstractGroupOperation as well as its concrete subtypes\nAdditionGroupOperation (formerly AdditionOperation)\nMatrixMultiplicationGroupOperation (formerly MultiplicationOperation)\nPowerGroupOperation (formerly the Lie group was stored inside a power manifold)\nProductGroupOperation (formerly the Lie groups were stored inside a product manifold)\nLeftSemidirectProductGroupOperation (this was formerly only implicitly stored in the SemidirectProductGroup)\nRightSemidirectProductGroupOperation\nAbstractGroupActionType with its 2 specific (new) abstract subtypes\nAbstractLeftGroupActionType\nAbstractRightGroupActionType\nFor the group operation actions there are now\nLeftGroupOperationAction (formerly LeftForwardAction)\nRightGroupOperationAction (formerly RightBackwardAction)\nInverseLeftGroupOperationAction (formerly RightForwardAction)\nInverseRightGroupOperationAction (formerly LeftBackwardAction)\nDefaultLieAlgebraOrthogonalBasis (replaces VeeOrthogonalBasis, which is still available in ManifoldsBase.jl)\nAbstractLieGroupPoint and AbstractLieAlgebraTangentVector as abstract types to introduce point and Lie algebra tangent vector representations\nIdentity\napplyand apply!\nbase_manifold to access the manifold within a Lie group\ncompose and compose!\nconjugate and conjugate!\ndiff_apply, diff_apply!, diff_group_apply, and diff_group_apply! (formerly apply_diff_[group][!])\ndiff_conjugate and diff_conjugate!\ndiff_left_compose, diff_left_compose!, diff_right_compose, diff_right_compose! (formerly translate_diff with different sides)\nexp(G::LieGroup, g, X) and exp!(G::LieGroup, h, g, X) (formerly exp_inv and exp_inv!)\nexp(G::LieGroup, X) and exp!(G::LieGroup, h, X) (formerly exp_lie and exp_lie!)\nhat and hat!, with slightly different signatures, since the base point is omitted.\nidentity_element and identity_element!\ninv and inv! (inv(::AbstractGroupAction) was formerly switch_direction)\ninv_left_compose, inv_left_compose! and inv_right_compose, inv_right_compose! (these functions correspond to inverse_translate with corresponding direction and side)\nis_identity\nlie_bracket and lie_bracket!\njacobian_conjugate (formerly adjoint_matrix, which is now a special case of this)\nlog(G::LieGroup, g, h) and log!(G::LieGroup, X, g, h) (formerly log_inv and log_inv!)\nlog(G::LieGroup, ::Identity, g) and log!(G::LieGroup, X, ::Identity, g) (formerly log_lie and log_lie!)\nswitch (formerly switch_side)\nvee and vee!, with slightly different signatures, since the base point is omitted.","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Compared to Manifolds.jl","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"all translate functions are not implemented here, since you can just use compose. The differentials are implemented as listed above with respect to both left and right argument of compose\nall inverse_apply functions are not implemented here, since it is recommended to use apply(inv(A), g, p) as a replacement.","category":"page"},{"location":"news/#[0.0.3](https://github.com/JuliaManifolds/LieGroups.jl/releases/tag/v0.0.3)-(–-2025-02-19)","page":"Changelog","title":"0.0.3 (– 2025-02-19)","text":"","category":"section"},{"location":"news/#Added-8","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Finishes most of the work on the interface for the LieGroup type and the new LieAlgebra type.\nFinishes a generic implementation of a SemidirectProductGroupOperation\nAll details will be detailed in the next release","category":"page"},{"location":"news/#Old-Changelog-pre-0.0.3","page":"Changelog","title":"Old Changelog pre 0.0.3","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Two previous releases where done by Yueh-Hua Tu in 2022 before he was so kind to transfer the development to the JuliaManifolds GitHub organisation.","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"All notable changes to this project will be documented in this file.","category":"page"},{"location":"news/#[0.0.2]","page":"Changelog","title":"[0.0.2]","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"fix SE{3} and add jacobian\ndefine dof and dim for Lie algebra and jacobian of inv\nadd action for SE{N}\nadd se3_location example","category":"page"},{"location":"interface/group/#An-interface-for-Lie-groups","page":"Lie group","title":"An interface for Lie groups","text":"","category":"section"},{"location":"interface/group/#LieGroups.AbstractLieGroup","page":"Lie group","title":"LieGroups.AbstractLieGroup","text":"AbstractLieGroup{𝔽, O<:AbstractGroupOperation, M<:AbstractManifold{𝔽}} <: AbstractManifold{𝔽}\n\nAn abstract type to represent Lie groups. For most cases it should suffice to “combine” an AbstractManifold with an AbstractGroupOperation, see LieGroup.\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#LieGroups.LieGroup","page":"Lie group","title":"LieGroups.LieGroup","text":"LieGroup{𝔽, O<:AbstractGroupOperation, M<:AbstractManifold{𝔽}} <:  AbstractLieGroup{𝔽, O, M}\n\nRepresent a Lie Group mathcal G.\n\nA Lie Group mathcal G is a group endowed with the structure of a manifold such that the group operations  mathcal Gmathcal G  mathcal G, see compose and the inverse operation ^-1 mathcal G  mathcal G, see inv are smooth, see for example [HN12, Definition 9.1.1].\n\nLie groups are named after the Norwegian mathematician Marius Sophus Lie (1842–1899).\n\nFields\n\nmanifold: an AbstractManifold mathcal M\nop: an AbstractGroupOperation  on that manifold\n\nConstructor\n\nLieGroup(M::AbstractManifold, op::AbstractGroupOperation)\n\nGenerate a Lie group based on a manifold M and a group operation op, where vectors by default are stored in the Lie Algebra.\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#LieGroups.AbstractLieAlgebraTangentVector","page":"Lie group","title":"LieGroups.AbstractLieAlgebraTangentVector","text":"AbstractLieAlgebraTangentVector <: ManifoldsBase.AbstractTangentVector\n\nAn abstract type for a tangent vector represented in a LieAlgebra.\n\nWhile an tangent vectors are usually kept untyped for flexibility, it might be necessary to distinguish different types of points, for example\n\nfor complicated representations that require a struct\n\n@ semantic verification\n\nwhen there exist different representations\n\nBy sub-typing the AbstractManifoldPoint, this follows the same idea as in ManifoldsBase.jl.\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#LieGroups.AbstractLieGroupPoint","page":"Lie group","title":"LieGroups.AbstractLieGroupPoint","text":"AbstractLieGroupPoint <: ManifoldsBase.AbstractManifoldPoint end\n\nAn abstract type for a point on an AbstractLieGroup. While an points and tangent vectors are usually kept untyped for flexibility, it might be necessary to distinguish different types of points, for example\n\nfor complicated representations that require a struct\nsemantic verification\nwhen there exist different representations\n\nBy sub-typing the AbstractManifoldPoint, this follows the same idea as in ManifoldsBase.jl.\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#Special-types","page":"Lie group","title":"Special types","text":"","category":"section"},{"location":"interface/group/#LieGroups.BaseManifoldInverseRetraction","page":"Lie group","title":"LieGroups.BaseManifoldInverseRetraction","text":"BaseManifoldInverseRetraction{IRM<:AbstractInverseRetractionMethod} <: AbstractInverseRetractionMethod\n\nCompute an inverse retraction by using the inverse retraction of type IRM on the base manifold of a LieGroup.\n\nConstructor\n\nBaseManifoldInverseRetraction(irm::AbstractInverseRetractionMethod)\n\nGenerate the inverse retraction with inverse retraction rm to use on the base manifold.\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#LieGroups.BaseManifoldRetraction","page":"Lie group","title":"LieGroups.BaseManifoldRetraction","text":"BaseManifoldRetraction{RM<:AbstractRetractionMethod} <: AbstractRetractionMethod\n\nCompute a retraction by using the retraction of type RM on the base manifold of a LieGroup.\n\nConstructor\n\nBaseManifoldRetraction(rm::AbstractRetractionMethod)\n\nGenerate the retraction with retraction rm to use on the base manifold.\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#LieGroups.BaseManifoldVectorTransportMethod","page":"Lie group","title":"LieGroups.BaseManifoldVectorTransportMethod","text":"BaseManifoldVectorTransportMethod{VTM<:AbstractVectorTransportMethod} <:\n    AbstractVectorTransportMethod\n\nCompute a vector transport by using the transport of type VTM on the base manifold of a LieGroup.\n\nConstructor\n\nBaseManifoldVectorTransportMethod(vtm::AbstractVectorTransportMethod)\n\nGenerate the vector transport with transport vtm to use on the base manifold.\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#Functions-on-Lie-groups","page":"Lie group","title":"Functions on Lie groups","text":"","category":"section"},{"location":"interface/group/#Base.adjoint-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"Base.adjoint","text":"adjoint(G::AbstractLieGroup, g, X)\nadjoint!(G::AbstractLieGroup, Y, g, X)\n\nCompute the adjoint mathrmAd(g) mathfrak g  mathfrak g, which is defined as the differential diff_conjugate of the conjugate c_g(h) = ghg^-1 evaluated at the Identity h=mathrme. The operation can be performed in-place of Y.\n\n  mathrmAd(g)X = mathrmd c_g(mathrme) X qquad X  mathfrak g\n\nsee [HN12, Section 9.2.3].\n\nOn matrix Lie groups the adjoint reads mathrmAd(g)X = gXg^-1.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.exp-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"Base.exp","text":"exp(G::AbstractLieGroup, g, X)\nexp!(G::AbstractLieGroup, h, g, X)\n\nCompute the Lie group exponential map for gmathcal G and Xmathfrak g, where mathfrak g denotes the LieAlgebra of mathcal G. It is given by\n\nexp_g X = gexp_mathcal G(X)\n\nwhere X can be scaled by t, the computation can be performed in-place of h, and exp_mathcal G denotes the  Lie group exponential function.\n\nIf g is the Identity the Lie group exponential function exp_mathcal G is computed directly. Implementing the Lie group exponential function introduces a default implementation with the formula above.\n\nnote: Note\nThe Lie group exponential map is usually different from the exponential map with respect to the metric of the underlying Riemannian manifold mathcal M. To access the (Riemannian) exponential map, use exp(base_manifold(G), g, X).\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.exp-Tuple{AbstractLieGroup, Any}","page":"Lie group","title":"Base.exp","text":"exp(G::AbstractLieGroup, X::T)\nexp!(G::AbstractLieGroup, g, X)\n\nCompute the (Lie group) exponential function\n\nexp_mathcal G mathfrak g  mathcal Gqquad exp_mathcal G(X) = γ_X(1)\n\nwhere γ_X is the unique solution of the initial value problem\n\nγ(0) = mathrme quad γ(s) = γ(s)X\n\nSee also [HN12, Definition 9.2.2]. On matrix Lie groups this is the same as the matrix exponential.\n\nThe computation can be performed in-place of g.\n\ninfo: Naming convention\nThere are at least two different objects usually called “exponential” that need to be distinguishedthe (Riemannian) exponential map exp(M, p, X) from ManifoldsBase.jl. This can be accessed here using exp(base_manifold(G), p, X)\nthe exponential map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric exp(G, g, X), which we use as a default within this package\nthe (matrix/Lie group) exponential function exp(G, g) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.inv-Tuple{AbstractLieGroup, Any}","page":"Lie group","title":"Base.inv","text":"inv(G::AbstractLieGroup, g)\ninv!(G::AbstractLieGroup, h, g)\n\nCompute the inverse group element g^-1 with respect to the AbstractGroupOperation  on the AbstractLieGroup mathcal G, that is, return the unique element h=g^-1 such that hg=mathrme, where mathrme denotes the Identity.\n\nThis can be done in-place of h, without side effects, that is you can do inv!(G, g, g).\n\ninfo: Info\nThis function also handles the case where g is the Identity(G). Since this would lead to ambiguities when implementing a new group operations, this function calls _inv and _inv!, respectively, which is meant for the actual computation of group operations on (non-Identity` but maybe its numerical representation) elements.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.isapprox-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"Base.isapprox","text":"isapprox(M::AbstractLieGroup, g, h; kwargs...)\n\nCheck if points g and h from AbstractLieGroup are approximately equal. this function calls the corresponding isapprox on the AbstractManifold after handling the cases where one or more of the points are the Identity. All keyword argments are passed to this function as well.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.log-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"Base.log","text":"log(G::AbstractLieGroup, g, h)\nlog!(G::AbstractLieGroup, X, g, h)\n\nCompute the Lie group logarithmic map log_g mathcal G  mathfrak g, where mathfrak g denotes the LieAlgebra of mathcal G. It is given by\n\nlog_g h = log_mathcal G(g^-1h)\n\nwhere log_mathcal G denotes the Lie group logarithmic function The computation can be performed in-place of X.\n\ninfo: Naming convention\nThere are at least two different objects usually called “logarithm” that need to be distinguishedthe (Riemannian) logarithmic map log(M, p, X) from ManifoldsBase.jl\nthe exponential map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric exp(G, g, X), which we use as a default within this package\nthe (matrix/Lie group) exponential function exp(G, g) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.log-Tuple{AbstractLieGroup, Any}","page":"Lie group","title":"Base.log","text":"log(G::AbstractLieGroup, g, h)\nlog(G::AbstractLieGroup, g)\nlog(G::AbstractLieGroup, g::Identity, T)\nlog!(G::AbstractLieGroup, X::T, g)\n\nCompute the (Lie group) logarithmic function log_mathcal G mathcal G  mathfrak g, which is the inverse of the Lie group exponential function. For the allocating variant, you can specify the type T, when the point argument is the identity and hence does not provide the representation used. The computation can be performed in-place of X::T, which then determines the type.\n\ninfo: Naming convention\nThere are at least two different objects usually called “logarithm” that need to be distinguishedthe (Riemannian) logarithm map log(M, p, q) from ManifoldsBase.jl. This can be accessed here using log(base_manifold(G), p, q).\nthe logarithmic map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric log(G, g, h), which we use as a default within this package\nthe (matrix/Lie group) logarithm function log(G, h) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.rand-Tuple{AbstractLieGroup, Type}","page":"Lie group","title":"Base.rand","text":"rand(::AbstractLieGroup; vector_at=nothing, σ::Real=1.0, kwargs...)\nrand(::AbstractLieGroup, PT::Type; vector_at=nothing, σ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, T::Type; σ::Real=1.0, kwargs...)\nrand!(::AbstractLieGroup, gX::PT; vector_at=nothing, σ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, X::T; σ::Real=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\nFor both cases, you can provide the type T for the tangent vector and/or point PT, if you want to generate a random point in a certain representation. For the in-place variants the type is inferred from pX and X, respectively.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.rand-Tuple{AbstractLieGroup}","page":"Lie group","title":"Base.rand","text":"rand(::AbstractLieGroup; vector_at=nothing, σ::Real=1.0, kwargs...)\nrand(::AbstractLieGroup, PT::Type; vector_at=nothing, σ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, T::Type; σ::Real=1.0, kwargs...)\nrand!(::AbstractLieGroup, gX::PT; vector_at=nothing, σ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, X::T; σ::Real=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\nFor both cases, you can provide the type T for the tangent vector and/or point PT, if you want to generate a random point in a certain representation. For the in-place variants the type is inferred from pX and X, respectively.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.compose!-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.compose!","text":"compose(G::AbstractLieGroup, g, h)\ncompose!(G::AbstractLieGroup, k, g, h)\n\nPerform the group operation g  h for two g h  mathcal G on the AbstractLieGroup G. This can also be done in-place of h.\n\ninfo: Info\nThis function also handles the case where g or/and h are the Identity(G). Since this would lead to ambiguities when implementing a new group operations, this function calls _compose and _compose!, respectively, which is meant for the actual computation of group operations on (non-Identity` but maybe its numerical representation) elements.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.compose-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"LieGroups.compose","text":"compose(G::AbstractLieGroup, g, h)\ncompose!(G::AbstractLieGroup, k, g, h)\n\nPerform the group operation g  h for two g h  mathcal G on the AbstractLieGroup G. This can also be done in-place of h.\n\ninfo: Info\nThis function also handles the case where g or/and h are the Identity(G). Since this would lead to ambiguities when implementing a new group operations, this function calls _compose and _compose!, respectively, which is meant for the actual computation of group operations on (non-Identity` but maybe its numerical representation) elements.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.conjugate!-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.conjugate!","text":"conjugate(G::AbstractLieGroup, g, h)\nconjugate!(G::AbstractLieGroup, k, g, h)\n\nCompute the conjugation map c_g mathcal G  mathcal G given by c_g(h) = ghg^-1. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.conjugate-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"LieGroups.conjugate","text":"conjugate(G::AbstractLieGroup, g, h)\nconjugate!(G::AbstractLieGroup, k, g, h)\n\nCompute the conjugation map c_g mathcal G  mathcal G given by c_g(h) = ghg^-1. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_conjugate!-Tuple{AbstractLieGroup, Vararg{Any, 4}}","page":"Lie group","title":"LieGroups.diff_conjugate!","text":"diff_conjugate(G::AbstractLieGroup, g, h, X)\ndiff_conjugate!(G::AbstractLieGroup, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1 on the AbstractLieGroup G. The operation can be performed in-place of Y.\n\n  mathrmd(c_g(h))X qquad X  mathfrak g\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_conjugate-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.diff_conjugate","text":"diff_conjugate(G::AbstractLieGroup, g, h, X)\ndiff_conjugate!(G::AbstractLieGroup, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1 on the AbstractLieGroup G. The operation can be performed in-place of Y.\n\n  mathrmd(c_g(h))X qquad X  mathfrak g\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_inv!-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.diff_inv!","text":"diff_inv(G::AbstractLieGroup, g, X)\ndiff_inv!(G::AbstractLieGroup, Y, g, X)\n\nCompute the differential of the function ι_mathcal G(g) = g^-1, where mathrmdι_mathcal G(g) mathfrak g  mathfrak g. This can be done in-place of Y. Note that we represent tangent vectors in the Lie algebra 𝔤.\n\nFor example on matrix manifolds this means, we use X  𝔤 and hence W = gX  T_gmathcal G. The (classical) differential mathrmDι_mathcal G(g) T_gmathcal G  T_g^-1mathcal G reads\n\n  mathrmDι_mathcal G(g)W = -g^-1Wg^-1 = -Xg^-1 = -g^-1(gXg^-1) = -g^-1mathrmAd(g)X = V  T_g^-1mathcal G\n\nsee e.g. [Gil08]. To bring this back to the Lie algebra, we Write V = g^-1Y  T_g^-1mathcal G for some Y  𝔤 and obtain\n\n  mathrmd ι_mathcal G(g)X = -mathrmAd(g)X  𝔤\n\nwhere we use mathrmd to denote the differential in the Lie algebra.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_inv-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"LieGroups.diff_inv","text":"diff_inv(G::AbstractLieGroup, g, X)\ndiff_inv!(G::AbstractLieGroup, Y, g, X)\n\nCompute the differential of the function ι_mathcal G(g) = g^-1, where mathrmdι_mathcal G(g) mathfrak g  mathfrak g. This can be done in-place of Y. Note that we represent tangent vectors in the Lie algebra 𝔤.\n\nFor example on matrix manifolds this means, we use X  𝔤 and hence W = gX  T_gmathcal G. The (classical) differential mathrmDι_mathcal G(g) T_gmathcal G  T_g^-1mathcal G reads\n\n  mathrmDι_mathcal G(g)W = -g^-1Wg^-1 = -Xg^-1 = -g^-1(gXg^-1) = -g^-1mathrmAd(g)X = V  T_g^-1mathcal G\n\nsee e.g. [Gil08]. To bring this back to the Lie algebra, we Write V = g^-1Y  T_g^-1mathcal G for some Y  𝔤 and obtain\n\n  mathrmd ι_mathcal G(g)X = -mathrmAd(g)X  𝔤\n\nwhere we use mathrmd to denote the differential in the Lie algebra.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_left_compose!-Tuple{AbstractLieGroup, Vararg{Any, 4}}","page":"Lie group","title":"LieGroups.diff_left_compose!","text":"diff_left_compose(G::AbstractLieGroup, g, h, X)\ndiff_left_compose!(G::AbstractLieGroup, Y, g, h, X)\n\nCompute the differential of the group operation gh, on an AbstractLieGroup G with respect to its first (left) argument g.\n\nAnother interpretation is to consider a function where we do a fixed multiplication from the right with h. i..e. the right group multiplication function ρ_h(g) = gh (where the right refers to the fixed argument h).\n\nIn this notation, this function computes the differential mathrmdρ_h 𝔤  𝔤.\n\nFor example on matrix Lie groups this means that for X  𝔤 we can start with W = gX  T_gmathcal G and compute the (classical) differential mathrmDρ_h(g) T_gmathcal G  T_ghmathcal G.\n\nIt reads\n\n  mathrmDρ_h(g)W = Wh = gXh = V  T_ghmathcal G\n\nTo obtain the Lie group differential mathrmdρ_h(g) we have to “pull back” V from the tangent space T_ghmathcal G to the Lie algebra 𝔤. We use the same identification, that we can write V = ghY  T_ghmathcal G. This means in practice that with V = gXh = gh(h^-1Xh) differential reads\n\nmathrmd ρ_h(g)X = h^-1Xh = mathrmAd(h^-1)X  𝔤\n\nwhere mathrmAd denotes the adjoint.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_left_compose-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.diff_left_compose","text":"diff_left_compose(G::AbstractLieGroup, g, h, X)\ndiff_left_compose!(G::AbstractLieGroup, Y, g, h, X)\n\nCompute the differential of the group operation gh, on an AbstractLieGroup G with respect to its first (left) argument g.\n\nAnother interpretation is to consider a function where we do a fixed multiplication from the right with h. i..e. the right group multiplication function ρ_h(g) = gh (where the right refers to the fixed argument h).\n\nIn this notation, this function computes the differential mathrmdρ_h 𝔤  𝔤.\n\nFor example on matrix Lie groups this means that for X  𝔤 we can start with W = gX  T_gmathcal G and compute the (classical) differential mathrmDρ_h(g) T_gmathcal G  T_ghmathcal G.\n\nIt reads\n\n  mathrmDρ_h(g)W = Wh = gXh = V  T_ghmathcal G\n\nTo obtain the Lie group differential mathrmdρ_h(g) we have to “pull back” V from the tangent space T_ghmathcal G to the Lie algebra 𝔤. We use the same identification, that we can write V = ghY  T_ghmathcal G. This means in practice that with V = gXh = gh(h^-1Xh) differential reads\n\nmathrmd ρ_h(g)X = h^-1Xh = mathrmAd(h^-1)X  𝔤\n\nwhere mathrmAd denotes the adjoint.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_right_compose!-Tuple{AbstractLieGroup, Vararg{Any, 4}}","page":"Lie group","title":"LieGroups.diff_right_compose!","text":"diff_right_compose(G::AbstractLieGroup, g, h, X)\ndiff_right_compose!(G::AbstractLieGroup, Y, g, h, X)\n\nCompute the differential of the group operation gh, on an AbstractLieGroup G with respect to its second (right) argument h.\n\nAnother interpretation is to consider a function where we do a fixed multiplication from the left with g. i..e. the left group multiplication function λ_g(h) = gh (where the left refers to the fixed argument g.).\n\nIn this notation, this function mathrmdλ_g 𝔤  𝔤.\n\nFor example on matrix Lie groups this means that for X  𝔤 we can start with W = hX  T_hmathcal G and compute the (classical) differential mathrmDλ_g(h) T_hmathcal G  T_ghmathcal G.\n\nIt reads\n\n  mathrmDλ_g(h)W = gW = ghX  T_ghmathcal G\n\nTo obtain the Lie group differential mathrmdλ_g(h) we have to multiply the result with (gh)^-1 from the left and move from W to X. Then the differential just simplifies to the identity. It reads\n\nmathrmd λ_g(h)X = X  𝔤\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_right_compose-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.diff_right_compose","text":"diff_right_compose(G::AbstractLieGroup, g, h, X)\ndiff_right_compose!(G::AbstractLieGroup, Y, g, h, X)\n\nCompute the differential of the group operation gh, on an AbstractLieGroup G with respect to its second (right) argument h.\n\nAnother interpretation is to consider a function where we do a fixed multiplication from the left with g. i..e. the left group multiplication function λ_g(h) = gh (where the left refers to the fixed argument g.).\n\nIn this notation, this function mathrmdλ_g 𝔤  𝔤.\n\nFor example on matrix Lie groups this means that for X  𝔤 we can start with W = hX  T_hmathcal G and compute the (classical) differential mathrmDλ_g(h) T_hmathcal G  T_ghmathcal G.\n\nIt reads\n\n  mathrmDλ_g(h)W = gW = ghX  T_ghmathcal G\n\nTo obtain the Lie group differential mathrmdλ_g(h) we have to multiply the result with (gh)^-1 from the left and move from W to X. Then the differential just simplifies to the identity. It reads\n\nmathrmd λ_g(h)X = X  𝔤\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.identity_element!-Tuple{AbstractLieGroup, Any}","page":"Lie group","title":"LieGroups.identity_element!","text":"identity_element(G::AbstractLieGroup)\nidentity_element(G::AbstractLieGroup, T)\nidentity_element!(G::AbstractLieGroup, e::T)\n\nReturn a point representation of the Identity on the AbstractLieGroup G. By default this representation is the default array or number representation. If there exist several representations, the type T can be used to distinguish between them, and it should be provided for both the AbstractLieGroupPoint as well as the AbstractLieAlgebraTangentVector if they differ, since maybe only one of these types might be available for the second signature.\n\nIt returns the corresponding default representation of e as a point on G. This can be performed in-place of e.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.identity_element-Tuple{AbstractLieGroup}","page":"Lie group","title":"LieGroups.identity_element","text":"identity_element(G::AbstractLieGroup)\nidentity_element(G::AbstractLieGroup, T)\nidentity_element!(G::AbstractLieGroup, e::T)\n\nReturn a point representation of the Identity on the AbstractLieGroup G. By default this representation is the default array or number representation. If there exist several representations, the type T can be used to distinguish between them, and it should be provided for both the AbstractLieGroupPoint as well as the AbstractLieAlgebraTangentVector if they differ, since maybe only one of these types might be available for the second signature.\n\nIt returns the corresponding default representation of e as a point on G. This can be performed in-place of e.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv_left_compose!-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.inv_left_compose!","text":"inv_left_compose(G::AbstractLieGroup, g, h)\ninv_left_compose!(G::AbstractLieGroup, k, g, h)\n\nCompute the inverse of the left group operation λ_g(h) = gh, on the AbstractLieGroup G, that is, compute λ_g^-1(h) = g^-1h. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv_left_compose-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"LieGroups.inv_left_compose","text":"inv_left_compose(G::AbstractLieGroup, g, h)\ninv_left_compose!(G::AbstractLieGroup, k, g, h)\n\nCompute the inverse of the left group operation λ_g(h) = gh, on the AbstractLieGroup G, that is, compute λ_g^-1(h) = g^-1h. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv_right_compose!-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.inv_right_compose!","text":"inv_right_compose(G::AbstractLieGroup, h, g)\ninv_right_compose!(G::AbstractLieGroup, k, h, g)\n\nCompute the inverse of the right group operation ρ_g(h) = hg, on the AbstractLieGroup G, that is compute ρ_g^-1(h) = hg^-1. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv_right_compose-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"LieGroups.inv_right_compose","text":"inv_right_compose(G::AbstractLieGroup, h, g)\ninv_right_compose!(G::AbstractLieGroup, k, h, g)\n\nCompute the inverse of the right group operation ρ_g(h) = hg, on the AbstractLieGroup G, that is compute ρ_g^-1(h) = hg^-1. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.is_identity-Tuple{AbstractLieGroup, Any}","page":"Lie group","title":"LieGroups.is_identity","text":"is_identity(G::AbstractLieGroup, q; kwargs...)\n\nCheck whether q is the identity on the AbstractLieGroup mathcal G. This means it is either the Identity{O} with the respect to the corresponding AbstractGroupOperation O, or (approximately) the correct point representation.\n\nSee also\n\nidentity_element, identity_element!\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.jacobian_conjugate","page":"Lie group","title":"LieGroups.jacobian_conjugate","text":"jacobian_conjugate(G::AbstractLieGroup, g, h; basis::AbstractBasis=DefaultLieAlgebraOrthogonalBasis(); X=zero_vector(LieAlgebar(G)))\njacobian_conjugate!(G::AbstractLieGroup, J, g, h; basis::AbstractBasis=DefaultLieAlgebraOrthogonalBasis(); X=zero_vector(LieAlgebar(G)))\n\nCompute the Jacobian of the conjugate c_g(h) = ghg^-1, with respect to an AbstractBasis of the LieAlgebra.\n\nA default is implemented using diff_conjugate mathrmd(c_g(h))X: the jth column of of the Jacobian matrix J are given by the coefficients of the tangent vector mathrmd(c_g(h))X_j with respect to the basis B, where X_j is the jth basis vector of B.\n\nnote: Note\nFor the case that h is the Identity and the relation of mathrmd(c_g(h))X to the adjoint mathrmAd(g), the Jacobian then sometimes called “adjoint matrix”, e.g. in [SDA21], when choosing as a basis the DefaultLieAlgebraOrthogonalBasis() that is used for hat and vee.\n\nKeyword arguments\n\nX=zero_vector(LieAlgebra(G)) pass an interims memory to store the Lie algebra tangent vector in.\n\n\n\n\n\n","category":"function"},{"location":"interface/group/#LieGroups.jacobian_conjugate!","page":"Lie group","title":"LieGroups.jacobian_conjugate!","text":"jacobian_conjugate(G::AbstractLieGroup, g, h; basis::AbstractBasis=DefaultLieAlgebraOrthogonalBasis(); X=zero_vector(LieAlgebar(G)))\njacobian_conjugate!(G::AbstractLieGroup, J, g, h; basis::AbstractBasis=DefaultLieAlgebraOrthogonalBasis(); X=zero_vector(LieAlgebar(G)))\n\nCompute the Jacobian of the conjugate c_g(h) = ghg^-1, with respect to an AbstractBasis of the LieAlgebra.\n\nA default is implemented using diff_conjugate mathrmd(c_g(h))X: the jth column of of the Jacobian matrix J are given by the coefficients of the tangent vector mathrmd(c_g(h))X_j with respect to the basis B, where X_j is the jth basis vector of B.\n\nnote: Note\nFor the case that h is the Identity and the relation of mathrmd(c_g(h))X to the adjoint mathrmAd(g), the Jacobian then sometimes called “adjoint matrix”, e.g. in [SDA21], when choosing as a basis the DefaultLieAlgebraOrthogonalBasis() that is used for hat and vee.\n\nKeyword arguments\n\nX=zero_vector(LieAlgebra(G)) pass an interims memory to store the Lie algebra tangent vector in.\n\n\n\n\n\n","category":"function"},{"location":"interface/group/#LieGroups.jacobian_exp","page":"Lie group","title":"LieGroups.jacobian_exp","text":"jacobian_exp(G::AbstractLieGroup, g, X, b)\njacobian_exp!(G::AbstractLieGroup, J, g, X, b)\n\nCompute the Jacobian of the exp exp_g(X) with respect to an AbstractBasis of the LieAlgebra.\n\n\n\n\n\n","category":"function"},{"location":"interface/group/#LieGroups.jacobian_exp!","page":"Lie group","title":"LieGroups.jacobian_exp!","text":"jacobian_exp(G::AbstractLieGroup, g, X, b)\njacobian_exp!(G::AbstractLieGroup, J, g, X, b)\n\nCompute the Jacobian of the exp exp_g(X) with respect to an AbstractBasis of the LieAlgebra.\n\n\n\n\n\n","category":"function"},{"location":"interface/group/#LieGroups.point_type-Tuple{AbstractLieGroup, Type}","page":"Lie group","title":"LieGroups.point_type","text":"point_type(G::AbstractLieGroup, tangent_vector_type::Type)\n\nChange tangent_vector_type that is a type of tangent vector type on Lie group G to its matching type for representing points.\n\nBy default both these types are assumed to be identical.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.pull_back_tangent!-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.pull_back_tangent!","text":"pull_back_tangent(G::AnstractLieGroup, g, X; kwargs...)\npull_back_tangent!(G::AbstractLiegroup, Y, g, X; kwargs...)\n\nGiven a tangent vector X on the tangent space at g interpreted as the one on the manifold, this function pulls it back to the LieAlgebra.\n\nBy default this function falls back to calling diff_left_compose, but compared to that function, this function also takes care about the change of representation.\n\nFor example if a default representation for tangent vectors on a manifold is also the Lie algebra, then this function simplifies to the identity. This is for example the case for the SpecialOrthogonalGroup and its Rotations manifold.\n\nKeyword argument\n\ne = identity_element(G, typeof(g)) – if you have a memory available to store an identity point in, you can pass that memory here.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.pull_back_tangent-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"LieGroups.pull_back_tangent","text":"pull_back_tangent(G::AnstractLieGroup, g, X; kwargs...)\npull_back_tangent!(G::AbstractLiegroup, Y, g, X; kwargs...)\n\nGiven a tangent vector X on the tangent space at g interpreted as the one on the manifold, this function pulls it back to the LieAlgebra.\n\nBy default this function falls back to calling diff_left_compose, but compared to that function, this function also takes care about the change of representation.\n\nFor example if a default representation for tangent vectors on a manifold is also the Lie algebra, then this function simplifies to the identity. This is for example the case for the SpecialOrthogonalGroup and its Rotations manifold.\n\nKeyword argument\n\ne = identity_element(G, typeof(g)) – if you have a memory available to store an identity point in, you can pass that memory here.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.push_forward_tangent!-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.push_forward_tangent!","text":"push_forward_tangent(G::AnstractLieGroup, g, X)\npush_forward_tangent!(G::AbstractLiegroup, Y, g, X)\n\nGiven a Lie algebra vector X on the LieAlgebra, this function pushes the vector forward to the tangent space at g interpreted as the one on the manifold.\n\nBy default this function falls back to calling diff_left_compose, but compared to that function, this function also takes care about the change of representation.\n\nFor example if a default representation for tangent vectors on a manifold is also the Lie algebra, then this function simplifies to the identity. This is for example the case for the SpecialOrthogonalGroup and its Rotations manifold.\n\nKeyword argument\n\ne = identity_element(G, typeof(g)) – if you have a memory available to store an identity point in, you can pass that memory here.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.push_forward_tangent-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"LieGroups.push_forward_tangent","text":"push_forward_tangent(G::AnstractLieGroup, g, X)\npush_forward_tangent!(G::AbstractLiegroup, Y, g, X)\n\nGiven a Lie algebra vector X on the LieAlgebra, this function pushes the vector forward to the tangent space at g interpreted as the one on the manifold.\n\nBy default this function falls back to calling diff_left_compose, but compared to that function, this function also takes care about the change of representation.\n\nFor example if a default representation for tangent vectors on a manifold is also the Lie algebra, then this function simplifies to the identity. This is for example the case for the SpecialOrthogonalGroup and its Rotations manifold.\n\nKeyword argument\n\ne = identity_element(G, typeof(g)) – if you have a memory available to store an identity point in, you can pass that memory here.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LinearAlgebra.adjoint!-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"LinearAlgebra.adjoint!","text":"adjoint(G::AbstractLieGroup, g, X)\nadjoint!(G::AbstractLieGroup, Y, g, X)\n\nCompute the adjoint mathrmAd(g) mathfrak g  mathfrak g, which is defined as the differential diff_conjugate of the conjugate c_g(h) = ghg^-1 evaluated at the Identity h=mathrme. The operation can be performed in-place of Y.\n\n  mathrmAd(g)X = mathrmd c_g(mathrme) X qquad X  mathfrak g\n\nsee [HN12, Section 9.2.3].\n\nOn matrix Lie groups the adjoint reads mathrmAd(g)X = gXg^-1.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Manifolds.inv!-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"Manifolds.inv!","text":"inv(G::AbstractLieGroup, g)\ninv!(G::AbstractLieGroup, h, g)\n\nCompute the inverse group element g^-1 with respect to the AbstractGroupOperation  on the AbstractLieGroup mathcal G, that is, return the unique element h=g^-1 such that hg=mathrme, where mathrme denotes the Identity.\n\nThis can be done in-place of h, without side effects, that is you can do inv!(G, g, g).\n\ninfo: Info\nThis function also handles the case where g is the Identity(G). Since this would lead to ambiguities when implementing a new group operations, this function calls _inv and _inv!, respectively, which is meant for the actual computation of group operations on (non-Identity` but maybe its numerical representation) elements.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.base_manifold-Tuple{AbstractLieGroup}","page":"Lie group","title":"ManifoldsBase.base_manifold","text":"base_manifold(G::AbstractLieGroup)\n\nReturn the manifold stored within the AbstractLieGroup G.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.exp!-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"ManifoldsBase.exp!","text":"exp(G::AbstractLieGroup, g, X)\nexp!(G::AbstractLieGroup, h, g, X)\n\nCompute the Lie group exponential map for gmathcal G and Xmathfrak g, where mathfrak g denotes the LieAlgebra of mathcal G. It is given by\n\nexp_g X = gexp_mathcal G(X)\n\nwhere X can be scaled by t, the computation can be performed in-place of h, and exp_mathcal G denotes the  Lie group exponential function.\n\nIf g is the Identity the Lie group exponential function exp_mathcal G is computed directly. Implementing the Lie group exponential function introduces a default implementation with the formula above.\n\nnote: Note\nThe Lie group exponential map is usually different from the exponential map with respect to the metric of the underlying Riemannian manifold mathcal M. To access the (Riemannian) exponential map, use exp(base_manifold(G), g, X).\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.exp!-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"ManifoldsBase.exp!","text":"exp(G::AbstractLieGroup, X::T)\nexp!(G::AbstractLieGroup, g, X)\n\nCompute the (Lie group) exponential function\n\nexp_mathcal G mathfrak g  mathcal Gqquad exp_mathcal G(X) = γ_X(1)\n\nwhere γ_X is the unique solution of the initial value problem\n\nγ(0) = mathrme quad γ(s) = γ(s)X\n\nSee also [HN12, Definition 9.2.2]. On matrix Lie groups this is the same as the matrix exponential.\n\nThe computation can be performed in-place of g.\n\ninfo: Naming convention\nThere are at least two different objects usually called “exponential” that need to be distinguishedthe (Riemannian) exponential map exp(M, p, X) from ManifoldsBase.jl. This can be accessed here using exp(base_manifold(G), p, X)\nthe exponential map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric exp(G, g, X), which we use as a default within this package\nthe (matrix/Lie group) exponential function exp(G, g) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.inverse_retract-Tuple{AbstractLieGroup, Any, Any, BaseManifoldInverseRetraction}","page":"Lie group","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(G::AbstractLieGroup, g, h, m::BaseManifoldInverseRetraction)\n\nCompute the inverse retraction of g and h on the AbstractLieGroup G by using an inverse retraction on the underlying manifold and pulling the result back to the Lie algebra.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.is_point-Tuple{AbstractLieGroup, Any}","page":"Lie group","title":"ManifoldsBase.is_point","text":"is_point(G::AbstractLieGroup, g; kwargs...)\n\nCheck whether g is a valid point on the Lie Group G. This falls back to checking whether g is a valid point on the base_manifoldG. unless g is an Identity. Then, it is checked whether it is the identity element corresponding to G.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.log!-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"ManifoldsBase.log!","text":"log(G::AbstractLieGroup, g, h)\nlog!(G::AbstractLieGroup, X, g, h)\n\nCompute the Lie group logarithmic map log_g mathcal G  mathfrak g, where mathfrak g denotes the LieAlgebra of mathcal G. It is given by\n\nlog_g h = log_mathcal G(g^-1h)\n\nwhere log_mathcal G denotes the Lie group logarithmic function The computation can be performed in-place of X.\n\ninfo: Naming convention\nThere are at least two different objects usually called “logarithm” that need to be distinguishedthe (Riemannian) logarithmic map log(M, p, X) from ManifoldsBase.jl\nthe exponential map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric exp(G, g, X), which we use as a default within this package\nthe (matrix/Lie group) exponential function exp(G, g) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.log!-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"ManifoldsBase.log!","text":"log(G::AbstractLieGroup, g, h)\nlog(G::AbstractLieGroup, g)\nlog(G::AbstractLieGroup, g::Identity, T)\nlog!(G::AbstractLieGroup, X::T, g)\n\nCompute the (Lie group) logarithmic function log_mathcal G mathcal G  mathfrak g, which is the inverse of the Lie group exponential function. For the allocating variant, you can specify the type T, when the point argument is the identity and hence does not provide the representation used. The computation can be performed in-place of X::T, which then determines the type.\n\ninfo: Naming convention\nThere are at least two different objects usually called “logarithm” that need to be distinguishedthe (Riemannian) logarithm map log(M, p, q) from ManifoldsBase.jl. This can be accessed here using log(base_manifold(G), p, q).\nthe logarithmic map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric log(G, g, h), which we use as a default within this package\nthe (matrix/Lie group) logarithm function log(G, h) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.retract-Tuple{LieGroup, Any, Any, BaseManifoldRetraction}","page":"Lie group","title":"ManifoldsBase.retract","text":"retract(G::AbstractLieGroup, g, h, m::BaseManifoldRetraction)\n\nCompute the retraction of g and X on the AbstractLieGroup G by pushing X forward to the tangent space at g and using a retraction on the underlying manifold.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.vector_transport_to-Tuple{AbstractLieGroup, Any, Any, Any, BaseManifoldVectorTransportMethod}","page":"Lie group","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(G::AbstractLieGroup, g, X, h, m::BaseManifoldVectorTransportMethod)\n\nCompute the vector transport of a Lie algebra X from  g to h using a vector transport on the underlying manifold. This is done by pushing X forward to the tangent space at g, then performing the vector transport on the base manifold, and finally pulling the resulting tangent vector back to the Lie algebra.\n\nThis method merely exists for experimental reasons, since the parallel transport on Lie groups, where all tangent vectors are represented in the Lie algebra is the identity. Hence any of the methods performed here are more costly than plain parallel transport.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Random.rand!-Tuple{AbstractLieGroup, Any}","page":"Lie group","title":"Random.rand!","text":"rand(::AbstractLieGroup; vector_at=nothing, σ::Real=1.0, kwargs...)\nrand(::AbstractLieGroup, PT::Type; vector_at=nothing, σ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, T::Type; σ::Real=1.0, kwargs...)\nrand!(::AbstractLieGroup, gX::PT; vector_at=nothing, σ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, X::T; σ::Real=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\nFor both cases, you can provide the type T for the tangent vector and/or point PT, if you want to generate a random point in a certain representation. For the in-place variants the type is inferred from pX and X, respectively.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Internal-functions-and-macros","page":"Lie group","title":"Internal functions and macros","text":"","category":"section"},{"location":"interface/group/#LieGroups.CommonUnitarySubAlgebra","page":"Lie group","title":"LieGroups.CommonUnitarySubAlgebra","text":"CommonUnitarySubAlgebra{𝔽,T}\n\nA constant that allows to refer to several sub Algebras of mathfrak u(n) for implementations where\n\ncertain sub algebras real/complex share a common implementation, e.g. for the same sizes T usually via TypeParameter\ncertain functions are the same for all sizes T as long as the field 𝔽 is the same\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#LieGroups.@default_lie_group_fallbacks","page":"Lie group","title":"LieGroups.@default_lie_group_fallbacks","text":"default_lie_group_fallbacks(TG, TF, TP, TV, pfield::Symbol, Xfield::Symbol, groupOp)\n\nIntroduce default fallbacks for all basic functions on Lie groups, for Lie group of type TG with group operation Op, points of type TP, tangent vectors of type TV, with forwarding to fields pfield and Xfield for point and tangent vector functions, respectively.\n\n\n\n\n\n","category":"macro"},{"location":"interface/group/#A-validation-Lie-group","page":"Lie group","title":"A validation Lie group","text":"","category":"section"},{"location":"interface/group/#LieGroups.ValidationLieGroup","page":"Lie group","title":"LieGroups.ValidationLieGroup","text":"ValidationLieGroup{L<:AbstractLieGroup} <: AbstractLieGroup\n\nA Lie group to add tests to input parameters and output values of functions defined for LieGroups.\n\nUsing the ignore_contexts keyword allows to specify a single Symbol or a vector of Symbols Of which contexts to ignore.\n\nCurrent contexts are\n\n:All: disable all checks\n:Point: checks for points\n:Algebra: checks related to the LieAlgebra\n:Output: checks for output\n:Input: checks for input variables\n\nFields\n\nlie_group::L the AbstractLieGroup to be decorated\nmode::Symbol: The mode to be used for error handling, either :error or :warn\nignore_contexts::AbstractVector{Symbol}: store contexts to be ignored of validation.\nignore_functions::Dict{<:Function,<:Union{Symbol,<:AbstractVector{Symbol}}: store contexts to be ignored with in a function or its mutating variant.\n\nwhere all but the first field are analogous to the setups of the ValidationManifold. We refer to those docs for more examples on their meaning.\n\nConstructor\n\nValidationLieGroup(L::AbstractLieGroup, check_manifold=true; kwargs...)\n\nGenerate the Validation Lie Group for the given AbstractLieGroup L. If check_manifold is set to true the inner manifold is additionally wrapped in a ValidationManifold. All suitable keywords are passed to the constructor of the validation manifold as well.\n\nKeyword arguments\n\nerror::Symbol=:error: specify how errors in the validation should be reported. this is passed to is_point and is_vector as the error keyword argument. Available values are :error, :warn, :info, and :none. Every other value is treated as :none.\nignore_contexts = Vector{Symbol}() a vector to indicate which validation contexts should not be performed.\nignore_functions=Dict{Function,Union{Symbol,Vector{Symbol}}}() a dictionary to disable certain contexts within functions. The key here is the non-mutating function variant (if it exists). The contexts are the same as in ignore_contexts.\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#A-metric-Lie-group-to-change-the-metric-on-a-Lie-Algebra","page":"Lie group","title":"A metric Lie group to change the metric on a Lie Algebra","text":"","category":"section"},{"location":"interface/group/#LieGroups.MetricLieGroup","page":"Lie group","title":"LieGroups.MetricLieGroup","text":"MetricLieGroup{\n    𝔽, O <: AbstractGroupOperation, M <: ManifoldsBase.AbstractManifold{𝔽},\n    L <: LieGroup{𝔽, O, M}, G <: AbstractMetric\n} <: AbstractLieGroup{𝔽, O, M}}\n\nEquip an AbstractLieGroup mathcal G explicitly with an AbstractMetric ⟨⋅,⋅⟩.\n\nBy default every AbstractLieGroup mathcal G is assumed to implicitly implement all functions on their LieAlgebra with respect to a metric, that corresponds to a certain “default metric”, either because it is a widely recognized metric or because the first implementation within LieGroups.jl was done with respect to this metric.\n\nThis default is usually indicated by checking that metric(L) returns DefaultMetric.\n\nThis decorator type allows to explicitly equip the Lie group with a different metric. Note that for any functions unrelated to the metric, this new Lie group will simply forward to the Lie group that is internally stored. This for example includes group operations like [compose], inv, or identity_element, or functions that are already otherwise passed on to the inner manifold like manifold_dimension.\n\nConstructor\n\nMetricLieGroup(G::AbstractLieGroup, metric::AbstractMetric)\n\nGenerate the AbstractLieGroup equipped explicitly with the AbstractMetric metric.\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#Manifolds.metric","page":"Lie group","title":"Manifolds.metric","text":"metric(G::MetricLieGroup)\n\nGet the AbstractMetric associated with the MetricLieGroup mathcal G.\n\n\n\n\n\n","category":"function"},{"location":"interface/group/#Internal-functions","page":"Lie group","title":"Internal functions","text":"","category":"section"},{"location":"interface/group/#LieGroups._vLc","page":"Lie group","title":"LieGroups._vLc","text":"_vLc(M::ValidationLieGroup, f::Function, context::Symbol)\n_vLc(M::ValidationLieGroup, f::Function, context::NTuple{N,Symbol}) where {N}\n_vLc(M::ValidationLieGroup, ::Nothing, context::NTuple{N,Symbol}) where {N}\n\nReturn whether a check should be performed within f and the context(s) provided, if the second argument is :Nothing, only the context is checked\n\nThis function returns false and hence indicates not to check, when\n\n(one of the) context(s) is in the ignore list for f within ignore_functions\n(one of the) context(s) is in the ignore_contexts list\n\nOtherwise the test is active.\n\n!!! Note    This function is internal and used very often, so it has a very short name;     _vLc stands for \"ValidationLieGroup check\".\n\n\n\n\n\n","category":"function"},{"location":"interface/group/#LieGroups._msg","page":"Lie group","title":"LieGroups._msg","text":"_msg(G::ValidationLieGroup, str; error=:None, within::Union{Nothing,<:Function} = nothing,\ncontext::Union{NTuple{N,Symbol} where N} = NTuple{0,Symbol}())\n\nissue a message str according to the mode mode (as @error, @warn, @info).\n\n\n\n\n\n","category":"function"},{"location":"interface/group/#Literature","page":"Lie group","title":"Literature","text":"","category":"section"},{"location":"interface/group/","page":"Lie group","title":"Lie group","text":"M. B. Giles. Collected Matrix Derivative Results for Forward and Reverse Mode Algorithmic Differentiation. In: Advances in Automatic Differentiation, Lecture Notes in Computational Science and Engineering, edited by C. H. Bischof, H. M. Bücker, P. Hovland, U. Naumann and J. Utke (Springer, Berlin, Heidelberg, 2008); pp. 35–44.\n\n\n\nJ. Hilgert and K.-H. Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\nJ. Solà, J. Deray and D. Atchuthan. A micro Lie theory for state estimation in robotics (Dec 2021), arXiv:1812.01537 [cs.RO], arXiv: 1812.01537.\n\n\n\n","category":"page"},{"location":"interface/algebra/#An-interface-for-Lie-algebras","page":"Lie algebra","title":"An interface for Lie algebras","text":"","category":"section"},{"location":"interface/algebra/#LieGroups.LieAlgebra","page":"Lie algebra","title":"LieGroups.LieAlgebra","text":"LieAlgebra{𝔽, G} <: AbstractManifold{𝔽}\n\nRepresent the Lie algebra mathfrak g, that is a 𝔽 vector space with an associated lie_bracket  mathfrak gmathfrak g  mathfrak g which fulfills\n\nXX = 0 for all X  mathfrak g\nThe Jacobi identity X YZ = XYZ = Y XZ holds for all X Y Z  mathfrak g.\n\nThe Lie algebras considered here are those related to a AbstractLieGroup mathcal G, namely the tangent space T_mathrmemathcal G at the Identity, this is internally just a const of the corresponding TangentSpace.\n\nnote: Convention for representing tangent vectors in the Lie algebra\nA vector field mathcal X mathcal G  Tmathcal G, X(g)  T_gmathcal G is called a left-invariant vector field if it satisfiesmathcal X(λ_g(h)) = Dλ_g(h)mathcal X(h) quadtextfor allquad g h  mathcal Gwhere λ_g mathcal G  mathcal G is the left multiplication by g. Hence mathcal X is determined already when X  mathfrak g is given, since mathcal X(g) = Dλ_g(e)X, cf [HN12, Definition 9.1.7].Throughout LieGroups.jl, we use this left-invariant convention to store tangent vectors at points on a Lie group as elements of the corresponding Lie algebra.\n\nConstructor\n\nLieAlgebra(G::AbstractLieGroup)\n\nReturn the Lie Algebra belonging to the AbstractLieGroup G.\n\n\n\n\n\n","category":"type"},{"location":"interface/algebra/#LieGroups.DefaultLieAlgebraOrthogonalBasis","page":"Lie algebra","title":"LieGroups.DefaultLieAlgebraOrthogonalBasis","text":"DefaultLieAlgebraOrthogonalBasis{𝔽} <: ManifoldsBase.AbstractOrthogonalBasis{𝔽,ManifoldsBase.TangentSpaceType}\n\nSpecify an orthogonal basis for a Lie algebra. This is used as the default within hat and vee.\n\nIf not specifically overwritten/implemented for a Lie group, the DefaultOrthogonalBasis at the identity_element on the `base_manifold acts as a fallback.\n\nnote: Note\nIn order to implement the corresponding get_coordinates and get_vector functions, define get_coordinates_lie(::AbstractLieAlgebra, X, B) and get_vector_lie(::AbstractLieAlgebra, X, B), resp.\n\n\n\n\n\n","category":"type"},{"location":"interface/algebra/#Functions-on-Lie-algebras","page":"Lie algebra","title":"Functions on Lie algebras","text":"","category":"section"},{"location":"interface/algebra/#Base.rand-Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s25\", O, M} where {var\"#s25\", M<:ManifoldsBase.AbstractManifold{var\"#s25\"}})}}","page":"Lie algebra","title":"Base.rand","text":"rand(::LieGroup; vector_at=nothing, σ=1.0, kwargs...)\nrand(::LieAlgebra; σ=1.0, kwargs...)\nrand!(::AbstractLieGroup, gX; vector_at=nothing, kwargs...)\nrand!(::LieAlgebra, X; σ=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#LieGroups.base_lie_group-Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s25\", O, M} where {var\"#s25\", M<:ManifoldsBase.AbstractManifold{var\"#s25\"}})}}","page":"Lie algebra","title":"LieGroups.base_lie_group","text":"base_lie_group(𝔤::LieAlgebra)\n\nReturn the base_lie_group of the given LieAlgebra belongs to.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#LieGroups.lie_bracket!-Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s25\", O, M} where {var\"#s25\", M<:ManifoldsBase.AbstractManifold{var\"#s25\"}})}, Any, Any, Any}","page":"Lie algebra","title":"LieGroups.lie_bracket!","text":"lie_bracket!(𝔤::LieAlgebra, X, Y)\nlie_bracket!(𝔤::LieAlgebra, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g which fulfills\n\nXX = 0 for all X  mathfrak g\nThe Jacobi identity X YZ = XYZ = Y XZ holds for all X Y Z  mathfrak g.\n\nThe computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#LieGroups.lie_bracket-Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s25\", O, M} where {var\"#s25\", M<:ManifoldsBase.AbstractManifold{var\"#s25\"}})}, Any, Any}","page":"Lie algebra","title":"LieGroups.lie_bracket","text":"lie_bracket!(𝔤::LieAlgebra, X, Y)\nlie_bracket!(𝔤::LieAlgebra, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g which fulfills\n\nXX = 0 for all X  mathfrak g\nThe Jacobi identity X YZ = XYZ = Y XZ holds for all X Y Z  mathfrak g.\n\nThe computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.base_manifold-Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s25\", O, M} where {var\"#s25\", M<:ManifoldsBase.AbstractManifold{var\"#s25\"}})}}","page":"Lie algebra","title":"ManifoldsBase.base_manifold","text":"base_manifold(𝔤::LieAlgebra)\n\nReturn the base_manifold the AbstractLieGroup of the given LieAlgebra is based on.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.get_coordinates","page":"Lie algebra","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(𝔤::LieAlgebra, X::T, B::AbstractBasis)\nget_coordinates!(𝔤::LieAlgebra, c, X::T, B::AbstractBasis)\n\nReturn the vector of coordinates to the decomposition of X with respect to an AbstractBasis of the LieAlgebra 𝔤. The operation can be performed in-place of c.\n\nBy default this function requires that identity_element(G, T) is available and calls the corresponding get_coordinates function of the Riemannian manifold the Lie group is build on.\n\nThe inverse operation is get_vector.\n\nSee also vee.\n\n\n\n\n\n","category":"function"},{"location":"interface/algebra/#ManifoldsBase.get_coordinates!","page":"Lie algebra","title":"ManifoldsBase.get_coordinates!","text":"get_coordinates(𝔤::LieAlgebra, X::T, B::AbstractBasis)\nget_coordinates!(𝔤::LieAlgebra, c, X::T, B::AbstractBasis)\n\nReturn the vector of coordinates to the decomposition of X with respect to an AbstractBasis of the LieAlgebra 𝔤. The operation can be performed in-place of c.\n\nBy default this function requires that identity_element(G, T) is available and calls the corresponding get_coordinates function of the Riemannian manifold the Lie group is build on.\n\nThe inverse operation is get_vector.\n\nSee also vee.\n\n\n\n\n\n","category":"function"},{"location":"interface/algebra/#ManifoldsBase.get_vector","page":"Lie algebra","title":"ManifoldsBase.get_vector","text":"get_vector(G::AbstractLieGroup, c, B::AbstractBasis; kwargs...)\nget_vector(𝔤::LieAlgebra, c, B::AbstractBasis; kwargs...)\nget_vector!(G::AbstractLieGroup, X::T, c, B::AbstractBasis; kwargs...)\nget_vector!(𝔤::LieAlgebra, X::T, c, B::AbstractBasis; kwargs...)\n\nReturn the vector corresponding to a set of coefficients in an AbstractBasis of the LieAlgebra 𝔤. Since all tangent vectors are assumed to be represented in the Lie algebra, both signatures are equivalent. The operation can be performed in-place of a tangent vector X of type ::T.\n\nBy default this function requires identity_element(G) and calls the corresponding get_vector function of the Riemannian manifold the Lie group is build on.\n\nThe inverse operation is get_coordinates.\n\nKeyword arguments\n\ntangent_vector_type specify the tangent vector type to use for the allocating variants.\n\nSee also hat\n\n\n\n\n\n","category":"function"},{"location":"interface/algebra/#ManifoldsBase.get_vector!","page":"Lie algebra","title":"ManifoldsBase.get_vector!","text":"get_vector(G::AbstractLieGroup, c, B::AbstractBasis; kwargs...)\nget_vector(𝔤::LieAlgebra, c, B::AbstractBasis; kwargs...)\nget_vector!(G::AbstractLieGroup, X::T, c, B::AbstractBasis; kwargs...)\nget_vector!(𝔤::LieAlgebra, X::T, c, B::AbstractBasis; kwargs...)\n\nReturn the vector corresponding to a set of coefficients in an AbstractBasis of the LieAlgebra 𝔤. Since all tangent vectors are assumed to be represented in the Lie algebra, both signatures are equivalent. The operation can be performed in-place of a tangent vector X of type ::T.\n\nBy default this function requires identity_element(G) and calls the corresponding get_vector function of the Riemannian manifold the Lie group is build on.\n\nThe inverse operation is get_coordinates.\n\nKeyword arguments\n\ntangent_vector_type specify the tangent vector type to use for the allocating variants.\n\nSee also hat\n\n\n\n\n\n","category":"function"},{"location":"interface/algebra/#ManifoldsBase.hat!-Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s25\", O, M} where {var\"#s25\", M<:ManifoldsBase.AbstractManifold{var\"#s25\"}})}, Any, Any}","page":"Lie algebra","title":"ManifoldsBase.hat!","text":"hat(G::LieAlgebra, c)\nhat(G::LieAlgebra, c, T::Type)\nhat!(G::LieAlgebra, X::T, c)\n\nCompute the hat map ()^wedge mathcal V  𝔤 that maps a vector of coordinates mathbfc  mathcal V, to a tangent vector X  mathfrak g. The coefficients are given with respect to a specific basis to a tangent vector in the Lie algebra\n\nX = sum_imathcal I c_iB_i\n\nwhere  B_i _imathcal I is a basis of the Lie algebra and mathcal I a corresponding index set, which is usually mathcal I= 1ldotsn . Then mathcal V = ℝ^n.\n\nFor the allocating variant, you can specify the type T of the tangent vector to obtain, in case there are different representations. The first signature produces the default representation.\n\nThe computation can be performed in-place of X. The inverse of hat is vee. Technically, hat is a specific case of get_vector and is implemented using the DefaultLieAlgebraOrthogonalBasis.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.hat-Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s25\", O, M} where {var\"#s25\", M<:ManifoldsBase.AbstractManifold{var\"#s25\"}})}, Any}","page":"Lie algebra","title":"ManifoldsBase.hat","text":"hat(G::LieAlgebra, c)\nhat(G::LieAlgebra, c, T::Type)\nhat!(G::LieAlgebra, X::T, c)\n\nCompute the hat map ()^wedge mathcal V  𝔤 that maps a vector of coordinates mathbfc  mathcal V, to a tangent vector X  mathfrak g. The coefficients are given with respect to a specific basis to a tangent vector in the Lie algebra\n\nX = sum_imathcal I c_iB_i\n\nwhere  B_i _imathcal I is a basis of the Lie algebra and mathcal I a corresponding index set, which is usually mathcal I= 1ldotsn . Then mathcal V = ℝ^n.\n\nFor the allocating variant, you can specify the type T of the tangent vector to obtain, in case there are different representations. The first signature produces the default representation.\n\nThe computation can be performed in-place of X. The inverse of hat is vee. Technically, hat is a specific case of get_vector and is implemented using the DefaultLieAlgebraOrthogonalBasis.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.inner-Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s25\", O, M} where {var\"#s25\", M<:ManifoldsBase.AbstractManifold{var\"#s25\"}})}, Any, Any}","page":"Lie algebra","title":"ManifoldsBase.inner","text":"inner(𝔤::LieAlgebra, X, Y)\n\nCompute the inner product  mathfrak gmathfrak g  ℝ on the Lie algebra 𝔤. By default this uses the inner product on the underlying manifold of the AbstractLieGroup of 𝔤 at the identity_element(G). Note that this method allocates an appropriate identity element.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.is_point-Union{Tuple{T}, Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s25\", O, M} where {var\"#s25\", M<:ManifoldsBase.AbstractManifold{var\"#s25\"}})}, T}, Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s25\", O, M} where {var\"#s25\", M<:ManifoldsBase.AbstractManifold{var\"#s25\"}})}, T, Bool}} where T","page":"Lie algebra","title":"ManifoldsBase.is_point","text":"is_point(𝔤::LieAlgebra, X; kwargs...)\n\nCheck whether X is a valid point on the Lie Algebra 𝔤. This falls back to checking whether X is a valid point on the tangent space at the identity_element(G) on the base_manifold(G) on the AbstractLieGroup of 𝔤\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.vee!-Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s25\", O, M} where {var\"#s25\", M<:ManifoldsBase.AbstractManifold{var\"#s25\"}})}, Any, Any}","page":"Lie algebra","title":"ManifoldsBase.vee!","text":"vee(𝔤::LieAlgebra, X)\nvee!(𝔤::LieAlgebra, c, X)\n\nCompute the vee map ()vee mathfrak g  mathcal V that maps a tangent vector X from the LieAlgebra \\mathfrak g to its coordinates with respect to the DefaultLieAlgebraOrthogonalBasis basis in the Lie algebra\n\nX = sum_imathcal I c_iB_i\n\nwhere  B_i _imathcal I is a basis of the Lie algebra and mathcal I a corresponding index set, which is usually mathcal I= 1ldotsn . Then mathcal V = ℝ^n\n\nThe computation can be performed in-place of c. The inverse of vee is hat. Technically, vee is a specific case of get_coordinates and is implemented using the DefaultLieAlgebraOrthogonalBasis.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.vee-Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s25\", O, M} where {var\"#s25\", M<:ManifoldsBase.AbstractManifold{var\"#s25\"}})}, Any}","page":"Lie algebra","title":"ManifoldsBase.vee","text":"vee(𝔤::LieAlgebra, X)\nvee!(𝔤::LieAlgebra, c, X)\n\nCompute the vee map ()vee mathfrak g  mathcal V that maps a tangent vector X from the LieAlgebra \\mathfrak g to its coordinates with respect to the DefaultLieAlgebraOrthogonalBasis basis in the Lie algebra\n\nX = sum_imathcal I c_iB_i\n\nwhere  B_i _imathcal I is a basis of the Lie algebra and mathcal I a corresponding index set, which is usually mathcal I= 1ldotsn . Then mathcal V = ℝ^n\n\nThe computation can be performed in-place of c. The inverse of vee is hat. Technically, vee is a specific case of get_coordinates and is implemented using the DefaultLieAlgebraOrthogonalBasis.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.zero_vector-Union{Tuple{O}, Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s25\", M} where {var\"#s25\"<:O, M<:ManifoldsBase.AbstractManifold{𝔽}}, Type}} where {𝔽, O<:AbstractGroupOperation}","page":"Lie algebra","title":"ManifoldsBase.zero_vector","text":"zero_vector(𝔤::LieAlgebra)\nzero_vector(𝔤::LieAlgebra, T::Type)\nzero_vector!(𝔤::LieAlgebra, X::T)\n\nGenerate a zero_vector of type T in the LieAlgebra 𝔤 of the AbstractLieGroup G. By default this calls zero_vector on the manifold of G at the identity_element(G,T)\n\nFor the allocating variant the type T of the zero vector can be specified.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#Random.rand!-Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s25\", O, M} where {var\"#s25\", M<:ManifoldsBase.AbstractManifold{var\"#s25\"}})}, Any}","page":"Lie algebra","title":"Random.rand!","text":"rand(::LieGroup; vector_at=nothing, σ=1.0, kwargs...)\nrand(::LieAlgebra; σ=1.0, kwargs...)\nrand!(::AbstractLieGroup, gX; vector_at=nothing, kwargs...)\nrand!(::LieAlgebra, X; σ=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#Internal-functions-and-macros","page":"Lie algebra","title":"Internal functions and macros","text":"","category":"section"},{"location":"interface/algebra/#LieGroups.@default_lie_algebra_fallbacks","page":"Lie algebra","title":"LieGroups.@default_lie_algebra_fallbacks","text":"default_lie_algebra_fallbacks(TG, TF, Op, TV, Xfield::Symbol)\n\nIntroduce default fallbacks for all basic functions on Lie algebras, for Lie group of type TG with number system TF, an group operation Op, tangent vectors of type TV, with forwarding to fields Xfield and tangent vector functions\n\n\n\n\n\n","category":"macro"},{"location":"interface/algebra/#Literature","page":"Lie algebra","title":"Literature","text":"","category":"section"},{"location":"interface/algebra/","page":"Lie algebra","title":"Lie algebra","text":"J. Hilgert and K.-H. Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\n","category":"page"},{"location":"groups/unitary_group/#The-unitary-group","page":"Unitary group","title":"The unitary group","text":"","category":"section"},{"location":"groups/unitary_group/#LieGroups.UnitaryGroup","page":"Unitary group","title":"LieGroups.UnitaryGroup","text":"UnitaryGroup{𝔽, T}\n\nThe special orthogonal group mathrmU(n) is the Lie group consisting of the MatrixMultiplicationGroupOperation on the manifold of rotations UnitaryMatrices with absolute value of the determinant equal to one.\n\nConstructor\n\nUnitaryGroup(n::Int, 𝔽::AbstractNumbers=ℂ; kwargs...)\n\nGenerate unitary group mathrmU(n). All keyword arguments in kwargs... are passed on to Rotations as well.\n\n\n\n\n\n","category":"type"},{"location":"groups/unitary_group/","page":"Unitary group","title":"Unitary group","text":"For this Lie group, several implementations are already covered by the defaults in the generic (matrix) multiplication operation. Besides that the following methods are implemented:","category":"page"},{"location":"groups/unitary_group/#Utility-functions-and-constants","page":"Unitary group","title":"Utility functions and constants","text":"","category":"section"},{"location":"groups/unitary_group/#LieGroups.CommonUnitarySubGroup","page":"Unitary group","title":"LieGroups.CommonUnitarySubGroup","text":"CommonUnitarySubGroup{𝔽,T}\n\nA constant that allows to refer to several subgroups of mathrmU(n) for implementations where\n\ncertain subgroups real/complex share a common implementation, e.g. for the same sizes T usually via TypeParameter\ncertain functions are the same for all sizes T as long as the field 𝔽 is the same\n\n\n\n\n\n","category":"type"},{"location":"groups/semidirect_product_group/#The-semidirect-product-Lie-group","page":"Semidirect product group","title":"The semidirect product Lie group","text":"","category":"section"},{"location":"groups/semidirect_product_group/","page":"Semidirect product group","title":"Semidirect product group","text":"The semidirect product has a few choices regarding left and right:","category":"page"},{"location":"groups/semidirect_product_group/","page":"Semidirect product group","title":"Semidirect product group","text":"for the order of the product: LeftSemidirectProductLieGroup mathcal G  mathcal H vs.  RightSemidirectProductLieGroup mathcal H  mathcal G\nfor the GroupAction α: AbstractLeftGroupActionType σ vs. AbstractRightGroupActionType τ\nfor the GroupAction α_g w.r.t. a fixed g  mathcal G, within a group operation h_1h_2: ActionActsOnLeft α_g(h_1)h_2 vs. ActionActsOnRight h_1α_g(h_2)","category":"page"},{"location":"groups/semidirect_product_group/","page":"Semidirect product group","title":"Semidirect product group","text":"These choices lead to different formulae, usually even all eight cases are different. We still try to document them.","category":"page"},{"location":"groups/semidirect_product_group/#LieGroups.LeftSemidirectProductGroupOperation","page":"Semidirect product group","title":"LieGroups.LeftSemidirectProductGroupOperation","text":"LeftSemidirectProductGroupOperation{O1,O2,A,AO} <: SemidirectProductGroupOperation{O1,O2,A,AO}\n\nA struct to model a left semidirect Lie group product.\n\nLet (mathcal G ) and (mathcal H ) be two Lie groups with group operations  and , respectively.\n\nThen this group operation  is defined on the product manifold mathcal Gmathcal H and uses the group operations  in the first component. The second component depends on the choice of the actual AbstractGroupActionType A and what it acts on, i.e. the AbstractActionActsOnType AO.\n\nThe resulting group operations are documented in the corresponding compose documentation.\n\nFor all four possible cases, we still use the shorthand notation mathcal G⋉mathcal H = (mathcal Gmathcal H) when it is clear which variant we refer to. See [HN12, Definition 9.2.22], first definition for more details.\n\nConstructor\n\nLeftSemidirectProductGroupOperation(\n    op1::AbstractGroupOperation,\n    op2::AbstractGroupOperation,\n    action::AbstractGroupActionType,\n    action_on::AbstractActionActsOnType=ActionActsOnLeft()\n)\n\nParameters\n\nop1::AbstractGroupOperation: The group operation  on mathcal G\nop2::AbstractGroupOperation: The group operation  on mathcal H\naction::AbstractGroupActionType: The group action α of mathcal G acting on mathcal H.\naction_on::AbstractActionActsOnType=ActionActsOnLeft(): The type of element in mathcal H the action is applied to.\n\nnote: A note on left/right\nThe “left” in the left semidirect product refers to the side, where the “pure” group operation takes place The “left/right” for the action refers to the type of group action used The “left/right” to act on refers to the left or right element in the second component, the action is applied to, see e.g. the explanation in ActionActsOnLeft\n\n\n\n\n\n","category":"type"},{"location":"groups/semidirect_product_group/#LieGroups.RightSemidirectProductGroupOperation","page":"Semidirect product group","title":"LieGroups.RightSemidirectProductGroupOperation","text":"RightSemidirectProductGroupOperation{O1,O2,A} <: SemidirectProductGroupOperation{O1,O2,A}\n\nA struct to model a right semidirect Lie group product.\n\nLet (mathcal G ) and (mathcal H ) be two Lie groups with group operations  and , respectively.\n\nThen this group operation  is defined on the product manifold mathcal Hmathcal G and uses the group operations  in the second component. The first component depends on the choice of the actual AbstractGroupActionType A and what it acts on, i.e. the AbstractActionActsOnType AO.\n\nThe resulting group operations are documented in the corresponding compose documentation.\n\nFor all four possible cases, we still use the shorthand notation mathcal H⋊mathcal G = (mathcal Hmathcal G) when it is clear which variant we refer to. See [HN12, Definition 9.2.22], first definition for more details.\n\nConstructor\n\nRightSemidirectProductGroupOperation(\n    op1::AbstractGroupOperation,\n    op2::AbstractGroupOperation,\n    action::AbstractGroupActionType\n    action_on::AbstractActionActsOnType=ActionActsOnRight()\n)\n\nParameters\n\nop1::AbstractGroupOperation: The group operation  on mathcal H\nop2::AbstractGroupOperation: The group operation  on mathcal G\naction::AbstractGroupActionType: The group action α of mathcal G acting on mathcal H.\naction_on::AbstractActionActsOnType=ActionActsOnRight(): The type of element in mathcal H the action is applied to.\n\nnote: A note on left/right\nThe “right” in the right semidirect product refers to the side, where the “pure” group operation takes place The “left/right” for the action refers to the type of group action used The “left/right” to act on refers to the left or right element in the second component, the action is applied to, see e.g. the explanation in ActionActsOnLeft\n\n\n\n\n\n","category":"type"},{"location":"groups/semidirect_product_group/#LieGroups.SemidirectProductGroupOperation","page":"Semidirect product group","title":"LieGroups.SemidirectProductGroupOperation","text":"SemidirectProductGroupOperation{\n    O1<:AbstractGroupOperation,\n    O2<:AbstractGroupOperation,\n    A<:AbstractGroupActionType,\n    AO <: AbstractActionActsOnType\n} <: AbstractProductGroupOperation\n\nAn abstract type for all semidirect product group operations.\n\nMost notably there are the left and right semidirect product group operations, see LeftSemidirectProductGroupOperation and RightSemidirectProductGroupOperation, respectively.\n\n\n\n\n\n","category":"type"},{"location":"groups/semidirect_product_group/#Base.inv-Union{Tuple{AO}, Tuple{A}, Tuple{O2}, Tuple{O1}, Tuple{𝔽}, Tuple{LieGroup{𝔽, <:LieGroups.SemidirectProductGroupOperation{O1, O2, A, AO}, <:ManifoldsBase.ProductManifold}, Any}} where {𝔽, O1, O2, A<:AbstractGroupActionType, AO<:AbstractActionActsOnType}","page":"Semidirect product group","title":"Base.inv","text":"inv(L::LieGroup{𝔽,<:SemidirectProductGroupOperation{⋆,⋄,A,AO}}, g)\n\nWhere {A <: AbstractGroupActionType, AO <: AbstractActionActsOnType} Let (mathcal G ) and (mathcal H ) be two Lie groups with group operations  and , respectively.\n\nInverse in Semidirect Product Groups\n\nLet σ denote a left group action (<:AbstractLeftGroupActionType) and τ a right group action (<:AbstractRightGroupActionType).   Let AO be the type indicating whether the action is applied on the left (ActionActsOnLeft) or right (ActionActsOnRight).\n\nThe formulas for the inverse depend on whether the action act on the left or on the right as follows:\n\nLeft semidirect product (LeftSemidirectProductGroupOperation):\n\nActing on the left (AO <: ActionActsOnLeft):\n\n(g h)^-1 = (g^-1 σ_g(h^-1))\n\n(g h)^-1 = (g^-1 τ_g^-1(h^-1))\n\nActing on the right (AO <: ActionActsOnRight):\n\n(g h)^-1 = (g^-1 σ_g^-1(h^-1))\n\n(g h)^-1 = (g^-1 τ_g(h^-1))\n\nRight semidirect product (RightSemidirectProductGroupOperation):\n\nActing on the left (AO <: ActionActsOnLeft):\n\n(h g)^-1 = (σ_g(h^-1) g^-1)\n\n(h g)^-1 = (τ_g^-1(h^-1) g^-1)\n\nActing on the right (AO <: ActionActsOnRight):\n\n(h g)^-1 = (σ_g^-1(h^-1) g^-1)\n\n(h g)^-1 = (τ_g(h^-1) g^-1)\n\nNote:  \n\nThe formulas above match the conventions in [HN12, Definition 9.2.22] with σ = α.\nThe relationship between left and right actions is σ_g = τ_g^-1.\n\nSee also: AbstractLeftGroupActionType, AbstractRightGroupActionType, ActionActsOnLeft, ActionActsOnRight\n\n\n\n\n\n","category":"method"},{"location":"groups/semidirect_product_group/#LieGroups.:⋉-Tuple{LieGroup, LieGroup}","page":"Semidirect product group","title":"LieGroups.:⋉","text":"G ⋉ H\n⋉(G, H)\n\nFor two LieGroups G, H, generate the LeftSemidirectProductLieGroup(G, H), where the corresponding default_left_action(G, H) and ActionActsOnRight are used.\n\n\n\n\n\n","category":"method"},{"location":"groups/semidirect_product_group/#LieGroups.:⋊-Tuple{LieGroup, LieGroup}","page":"Semidirect product group","title":"LieGroups.:⋊","text":"H ⋊ G\n⋊(H, G)\n\nFor two LieGroups H, G, generate the RightSemidirectProductLieGroup(H, G), where the corresponding default_right_action(H, G) and ActionActsOnRight are used.\n\n\n\n\n\n","category":"method"},{"location":"groups/semidirect_product_group/#LieGroups.LeftSemidirectProductLieGroup","page":"Semidirect product group","title":"LieGroups.LeftSemidirectProductLieGroup","text":"LeftSemidirectProductLieGroup(\n    N::LieGroup, H::LieGroup, action::AbstractGroupActionType=default_left_action(N, H);\n    action_on::AbstractActionActsOnType=ActionActsOnLeft()\n)\n\nGenerate the semidirect product Lie Group mathcal G  mathcal H for an AbstractGroupActionType using the LeftSemidirectProductGroupOperation as group operation definition. See [HN12, Definition 9.2.22], second definition, for more details.\n\nThe short form G ⋉ H can be used if the corresponding default_left_action(G,H) as well as the ActionActsOnLeft are the ones you want to use.\n\n\n\n\n\n","category":"function"},{"location":"groups/semidirect_product_group/#LieGroups.RightSemidirectProductLieGroup","page":"Semidirect product group","title":"LieGroups.RightSemidirectProductLieGroup","text":"RightSemidirectProductLieGroup(\n    N::LieGroup, H::LieGroup, action::AbstractGroupActionType=default_right_action(N,H);\n    action_on::AbstractActionActsOnType=ActionActsOnRight()\n)\n\nGenerate the semidirect product Lie Group mathcal H  mathcal G for an AbstractGroupActionType using the RightSemidirectProductGroupOperation for the group operation definition. See [HN12, Definition 9.2.22], first definition, for more details.\n\nThe short form H ⋊ G can be used if the corresponding default_right_action(H,G) and the ActionActsOnRight are the ones you want to use.\n\n\n\n\n\n","category":"function"},{"location":"groups/semidirect_product_group/#LieGroups.compose-Union{Tuple{AO}, Tuple{A}, Tuple{O2}, Tuple{O1}, Tuple{𝔽}, Tuple{LieGroup{𝔽, <:LieGroups.SemidirectProductGroupOperation{O1, O2, A, AO}, <:ManifoldsBase.ProductManifold}, Any, Any}} where {𝔽, O1, O2, A<:AbstractLeftGroupActionType, AO<:ActionActsOnLeft}","page":"Semidirect product group","title":"LieGroups.compose","text":"compose(L::LieGroup{𝔽,<:SemidirectProductGroupOperation{⋆,⋄,<:AbstractLeftGroupActionType,ActionActsOnLeft}}, g, h)\n\nLet (mathcal G ) and (mathcal H ) be two Lie groups with group operations  and , respectively.  Let σ denote a left group action. It here acts on the left.\n\nThe LeftSemidirectProductGroupOperation  on G  H is given by\n\n    (g_1h_1)  (g_2h_2) = bigl( g_1  g_2 σ_g_2^-1(h_1)  h_2 bigr)\n\nThe RightSemidirectProductGroupOperation  on H  G is given by\n\n    (h_1g_1)  (h_2g_2) = bigl( σ_g_2^-1(h_1)  h_2 g_1  g_2 bigr)\n\nSee also AbstractLeftGroupActionType and ActionActsOnLeft.\n\n\n\n\n\n","category":"method"},{"location":"groups/semidirect_product_group/#LieGroups.compose-Union{Tuple{AO}, Tuple{A}, Tuple{O2}, Tuple{O1}, Tuple{𝔽}, Tuple{LieGroup{𝔽, <:LieGroups.SemidirectProductGroupOperation{O1, O2, A, AO}, <:ManifoldsBase.ProductManifold}, Any, Any}} where {𝔽, O1, O2, A<:AbstractLeftGroupActionType, AO<:ActionActsOnRight}","page":"Semidirect product group","title":"LieGroups.compose","text":"compose(L::LieGroup{𝔽,<:SemidirectProductGroupOperation{⋆,⋄,<:AbstractLeftGroupActionType,ActionActsOnRight}}, g, h)\n\nLet (mathcal G ) and (mathcal H ) be two Lie groups with group operations  and , respectively.  Let σ denote a left group action. It here acts on the right.\n\nThe LeftSemidirectProductGroupOperation  on G  H is given by\n\n    (g_1h_1)  (g_2h_2) = bigl( g_1  g_2 h_1  σ_g_1(h_2) bigr)\n\nThe RightSemidirectProductGroupOperation  on H  G is given by\n\n    (h_1g_1)  (h_2g_2) = bigl( h_1  σ_g_1(h_2) g_1  g_2 bigr)\n\nSee also AbstractLeftGroupActionType and ActionActsOnRight.\n\n\n\n\n\n","category":"method"},{"location":"groups/semidirect_product_group/#LieGroups.compose-Union{Tuple{AO}, Tuple{A}, Tuple{O2}, Tuple{O1}, Tuple{𝔽}, Tuple{LieGroup{𝔽, <:LieGroups.SemidirectProductGroupOperation{O1, O2, A, AO}, <:ManifoldsBase.ProductManifold}, Any, Any}} where {𝔽, O1, O2, A<:AbstractRightGroupActionType, AO<:ActionActsOnLeft}","page":"Semidirect product group","title":"LieGroups.compose","text":"compose(L::LieGroup{𝔽,SemidirectProductGroupOperation{⋄,⋆,<:AbstractRightGroupActionType,ActionActsOnLeft}}, g, h)\n\nLet (mathcal G ) and (mathcal H ) be two Lie groups with group operations  and , respectively.  Let τ denote a right group action. It here acts on the left.\n\nThe LeftSemidirectProductGroupOperation  on G  H is given by\n\n    (g_1h_1)  (g_2h_2) = bigl( g_1  g_2 τ_g_2(h_1)  h_2 bigr)\n\nThe RightSemidirectProductGroupOperation  on H  G is given by\n\n    (h_1g_1)  (h_2g_2) = bigl( τ_g_2(h_1)  h_2 g_1  g_2 bigr)\n\nSee also AbstractRightGroupActionType and ActionActsOnLeft.\n\n\n\n\n\n","category":"method"},{"location":"groups/semidirect_product_group/#LieGroups.compose-Union{Tuple{AO}, Tuple{A}, Tuple{O2}, Tuple{O1}, Tuple{𝔽}, Tuple{LieGroup{𝔽, <:LieGroups.SemidirectProductGroupOperation{O1, O2, A, AO}, <:ManifoldsBase.ProductManifold}, Any, Any}} where {𝔽, O1, O2, A<:AbstractRightGroupActionType, AO<:ActionActsOnRight}","page":"Semidirect product group","title":"LieGroups.compose","text":"compose(L::LieGroup{𝔽,LeftSemidirectProductGroupOperation{⋆,⋄,<:AbstractRightGroupActionType,ActionActsOnRight}}, g, h)\n\nLet (mathcal G ) and (mathcal H ) be two Lie groups with group operations  and , respectively.  Let τ denote a right group action. It here acts on the right.\n\nThe LeftSemidirectProductGroupOperation  on G  H is given by\n\n    (g_1h_1)  (g_2h_2) = bigl( g_1  g_2 h_1  τ_g_1^-1(h_2) bigr)\n\nThe RightSemidirectProductGroupOperation  on H  G is given by\n\n    (h_1g_1)  (h_2g_2) = bigl( h_1  τ_g_1^-1(h_2)  g_1  g_2 bigr)\n\nSee also AbstractRightGroupActionType and ActionActsOnRight.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_linear/#The-special-linear-group","page":"Special linear","title":"The special linear group","text":"","category":"section"},{"location":"groups/special_linear/#LieGroups.SpecialLinearGroup","page":"Special linear","title":"LieGroups.SpecialLinearGroup","text":"SpecialLinear{𝔽,T}\n\nThe special linear group mathrmSL(n𝔽) is the group of all invertible matrices with unit determinant in 𝔽^nn and the MatrixMultiplicationGroupOperation as group operation.\n\nThe Lie algebra mathfrak sl(n 𝔽) = T_e mathrmSL(n𝔽) is the set of all matrices in 𝔽^nn with trace of zero. By default, tangent vectors X_p  T_p mathrmSL(n𝔽) for p  mathrmSL(n𝔽) are represented with their corresponding Lie algebra vector X_e = p^-1X_p  𝔰𝔩(n 𝔽).\n\nConstructor\n\nGeneralLinearGroup(n::Int, field=ℝ; kwargs...)\n\nGenerate the general linear group  group on 𝔽^nn. All keyword arguments in kwargs... are passed on to DeterminantOneMatrices.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_linear/#ManifoldsBase.hat!-Tuple{ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, <:SpecialLinearGroup, Identity{MatrixMultiplicationGroupOperation}}, Any, Any}","page":"Special linear","title":"ManifoldsBase.hat!","text":"X = hat(𝔤::LieAlgebra{ℝ,MatrixMultiplicationGroupOperation,<:SpecialLinearGroup}, c)\nhat!(𝔤::LieAlgebra{ℝ,MatrixMultiplicationGroupOperation,<:SpecialLinearGroup}, X, c)\n\nCompute the hat map ()^wedge  ℝ^n^2-1  𝔤 that turns a vector of coordinates c into a tangent vector in the Lie algebra.\n\nThe formula on the Lie algebra 𝔤 of the SpecialLinearGroup(n) is given by reshaping c  ℝ^n^2-1 into an n-byn matrix X with the final entry X[n,n] initialised to zero and then set to the trace of this initial matrix.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_linear/#ManifoldsBase.hat-Tuple{ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, <:SpecialLinearGroup, Identity{MatrixMultiplicationGroupOperation}}, Any}","page":"Special linear","title":"ManifoldsBase.hat","text":"X = hat(𝔤::LieAlgebra{ℝ,MatrixMultiplicationGroupOperation,<:SpecialLinearGroup}, c)\nhat!(𝔤::LieAlgebra{ℝ,MatrixMultiplicationGroupOperation,<:SpecialLinearGroup}, X, c)\n\nCompute the hat map ()^wedge  ℝ^n^2-1  𝔤 that turns a vector of coordinates c into a tangent vector in the Lie algebra.\n\nThe formula on the Lie algebra 𝔤 of the SpecialLinearGroup(n) is given by reshaping c  ℝ^n^2-1 into an n-byn matrix X with the final entry X[n,n] initialised to zero and then set to the trace of this initial matrix.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_linear/#ManifoldsBase.vee!-Tuple{ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, <:SpecialLinearGroup, Identity{MatrixMultiplicationGroupOperation}}, Any, Any}","page":"Special linear","title":"ManifoldsBase.vee!","text":"c = vee(𝔤::LieAlgebra{ℝ,MatrixMultiplicationGroupOperation,<:SpecialLinearGroup}, X)\nvee!(𝔤::LieAlgebra{ℝ,MatrixMultiplicationGroupOperation,<:SpecialLinearGroup}, c, X)\n\nCompute the vee map ()^vee mathfrak g   ℝ^n^2-1 that maps a tangent vector from the Lie algebra to a vector of coordinates c.\n\nThe formula on the Lie algebra 𝔤 of the SpecialLinearGroup(n) is given by reshaping X  ℝ^nn into a vector and omitting the last entry, since that can be reconstructed by considering that X has to be of trace zero.\n\nThis can be computed in-place of c.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_linear/#ManifoldsBase.vee-Tuple{ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, <:SpecialLinearGroup, Identity{MatrixMultiplicationGroupOperation}}, Any}","page":"Special linear","title":"ManifoldsBase.vee","text":"c = vee(𝔤::LieAlgebra{ℝ,MatrixMultiplicationGroupOperation,<:SpecialLinearGroup}, X)\nvee!(𝔤::LieAlgebra{ℝ,MatrixMultiplicationGroupOperation,<:SpecialLinearGroup}, c, X)\n\nCompute the vee map ()^vee mathfrak g   ℝ^n^2-1 that maps a tangent vector from the Lie algebra to a vector of coordinates c.\n\nThe formula on the Lie algebra 𝔤 of the SpecialLinearGroup(n) is given by reshaping X  ℝ^nn into a vector and omitting the last entry, since that can be reconstructed by considering that X has to be of trace zero.\n\nThis can be computed in-place of c.\n\n\n\n\n\n","category":"method"},{"location":"groups/general_linear/#The-general-linear-group","page":"General linear group","title":"The general linear group","text":"","category":"section"},{"location":"groups/general_linear/#LieGroups.GeneralLinearGroup","page":"General linear group","title":"LieGroups.GeneralLinearGroup","text":"GeneralLinearGroup{𝔽,T}\n\nThe general linear group mathrmGL(n) is the set of all invertible matrices\n\nmathrmGL(n) = bigl M  𝔽^nn big mathrmdet(M)  0bigr \nqquad 𝔽   ℝ ℂ \n\nequipped with the MatrixMultiplicationGroupOperation as the group operation.\n\nThe set of invertible matrices is a Riemannian manifold, since it inherits its structure from the embedding as an open subset of the space of matrices ℝ^nn.\n\nConstructor\n\nGeneralLinearGroup(n::Int; field=ℝ, kwargs...)\n\nGenerate the general linear group on 𝔽^nn. All keyword arguments in kwargs... are passed on to InvertibleMatrices.\n\n\n\n\n\n","category":"type"},{"location":"groups/general_linear/#Base.exp-Tuple{GeneralLinearGroup, Any}","page":"General linear group","title":"Base.exp","text":"exp(::GeneralLinearGroup, X)\nexp!(::GeneralLinearGroup, g, X)\n\nCompute the Lie group exponential on the GeneralLinearGroup, which is given by the matrix exponential\n\nexp X = sum_k=0^ frac1kX^k\n\nsee also [HN12, Example 9.2.3 (b)]\n\n\n\n\n\n","category":"method"},{"location":"groups/general_linear/#ManifoldsBase.exp!-Tuple{GeneralLinearGroup, Any, Any}","page":"General linear group","title":"ManifoldsBase.exp!","text":"exp(::GeneralLinearGroup, X)\nexp!(::GeneralLinearGroup, g, X)\n\nCompute the Lie group exponential on the GeneralLinearGroup, which is given by the matrix exponential\n\nexp X = sum_k=0^ frac1kX^k\n\nsee also [HN12, Example 9.2.3 (b)]\n\n\n\n\n\n","category":"method"},{"location":"groups/symplectic_group/#The-symplectic-group","page":"Symplectic group","title":"The symplectic group","text":"","category":"section"},{"location":"groups/symplectic_group/#LieGroups.SymplecticGroup","page":"Symplectic group","title":"LieGroups.SymplecticGroup","text":"SymplecticGroup{T}\n\nThe manifold of real symplectic matrices, of size 2n2n for some nℕ is given by\n\nmathrmSp(2n ℝ) = bigl p  ℝ^2n2n big p^mathrmTJ_2np = J_2nbigr \n\nwhere J_2n = beginpmatrix 0_n  I_n -I_n  0_nendpmatrix denotes the SymplecticElement.\n\nThis yields the SymplecticGroup together with the MatrixMultiplicationGroupOperation as the group operation.\n\nThe corresponding Lie algebra is given by the HamiltonianMatrices\n\nmathfrak so(2n ℝ) = bigl X  ℝ^2n2n big X^+ = -Xbigr \n\nwhere ^+ denotes the symplectic_inverse.\n\nSee [BZ21, Section 2] for more information.\n\n\n\n\n\n","category":"type"},{"location":"groups/symplectic_group/#Literature","page":"Symplectic group","title":"Literature","text":"","category":"section"},{"location":"groups/symplectic_group/","page":"Symplectic group","title":"Symplectic group","text":"T. Bendokat and R. Zimmermann. The real symplectic Stiefel and Grassmann manifolds: metrics, geodesics and applications, arXiv Preprint, 2108.12447 (2021), arXiv:2108.12447.\n\n\n\n","category":"page"},{"location":"groups/#An-overview-of-Lie-groups","page":"List of Lie groups","title":"An overview of Lie groups","text":"","category":"section"},{"location":"groups/","page":"List of Lie groups","title":"List of Lie groups","text":"Group Manifold  Comment\nCircleGroup real or complex Circle, Sphere * \nGeneralLinearGroup InvertibleMatrices * \nHeisenbergGroup HeisenbergMatrices * \nOrthogonalGroup OrthogonalMatrices * This can be interpreted as all rotations and reflections.\nPowerLieGroup PowerManifold ∘ ^ is a constructor\nProductLieGroup ProductManifold ∘ × of two Lie groups is a constructor\nLeftSemidirectProductLieGroup ProductManifold ∘ ⋉ of 2 Lie groups is a constructor, similarly ⋊ for the right variant\nSpecialEuclideanGroup Rotations⋉Euclidean ∘ Analogously you can also use a ⋊ if you prefer tuples (t,R) having the rotation matrix in the second component\nSpecialLinearGroup DeterminantOneMatrices * \nSpecialOrthogonalGroup Rotations * \nSpecialUnitaryGroup GeneralUnitaryMatrices * \nSymplecticGroup SymplecticMatrices * \nTranslationGroup Euclidean + \nUnitaryGroup UnitaryMatrices * ","category":"page"},{"location":"groups/power_group/#The-power-Lie-group","page":"Power group","title":"The power Lie group","text":"","category":"section"},{"location":"groups/power_group/#LieGroups.PowerGroupOperation","page":"Power group","title":"LieGroups.PowerGroupOperation","text":"PowerGroupOperation{O<:AbstractGroupOperation} <: AbstractGroupOperation\n\nA struct do model a that a certain group operation is applied element-wise on a PowerManifold.\n\nConstructor\n\nPowerGroupOperation(o::AbstractGroupOperation)\n\n\n\n\n\n","category":"type"},{"location":"groups/power_group/#LieGroups.PowerLieGroup-Tuple{ManifoldsBase.AbstractManifold, Vararg{Any}}","page":"Power group","title":"LieGroups.PowerLieGroup","text":"PowerLieGroup(G::LieGroup, args...; kwargs...)\n(G::LieGroup)^(n::Integer) = PowerLieGroup(G, n)\n\nGenerate the LieGroup of the n-th power of a Lie group G or manifold M. If passed a Lie group G, the group operation on the PowerLieGroup is the same as on G, but applied elementwise. Internally, the corresponding PowerGroupOperation is created. If you pass a manifold M, you have to provide the corresponding PowerGroupOperation yourself.\n\nBot the arguments args... as well as the keyword arguments kwargs... are passed on to the constructor of the PowerManifold. This especially includes the size of the manifold and allows to specify a NestedPowerRepresentation.\n\n\n\n\n\n","category":"method"},{"location":"groups/power_group/","page":"Power group","title":"Power group","text":"On power Lie groups, all functions work element-wise, so for their formulae, check the corresponding single Lie group for details.","category":"page"},{"location":"groups/heisenberg_group/#The-Heisenberg-group","page":"Heisenberg group","title":"The Heisenberg group","text":"","category":"section"},{"location":"groups/heisenberg_group/#LieGroups.HeisenbergGroup","page":"Heisenberg group","title":"LieGroups.HeisenbergGroup","text":"HeisenbergGroup{T}\n\nThe HeisenbergGroup(n) is the group of (n+2)(n+2) matrices, see also [BP08] or Heisenberg group where T specifies the eltype of the matrix entries.\n\nbeginpmatrix 1  mathbfa^mathrmT  c mathbf0_n  I_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix\n\nwhere I_n is the nn unit matrix, mathbfa mathbfb  ℝ^n are vectors of length n, mathbf0_n is the zero vector of length n, and c  ℝ is a real number. The group operation is matrix multiplication.\n\nThe Lie algebra consists of the elements\n\nbeginpmatrix 0  mathbfa^mathrmT  c mathbf0_n  Z_n  mathbfb 0  mathbf0_n^mathrmT  0endpmatrix\n\nwhere additionally Z_n denotes the nn zero matrix.\n\n\n\n\n\n","category":"type"},{"location":"groups/heisenberg_group/#Base.exp-Tuple{HeisenbergGroup, Any, Any}","page":"Heisenberg group","title":"Base.exp","text":"exp(G::HeisenbergGroup, g, X)\n\nExponential map on the HeisenbergGroup G with the left-invariant metric.\n\nWe denote by g a point on the Heisenberg group and by X a vector from the Lie algebra. These are of the form\n\ng = beginpmatrix 1  mathbfa^mathrmT  c mathbf0_n  I_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix\nqquad\nX = beginpmatrix 0  mathbfd^mathrmT  f mathbf0_n  Z_n  mathbfe 0  mathbf0_n^mathrmT  0endpmatrix\n\nwhere I_n is the nn unit matrix, Z_n is the nn zero matrix, mathbfa mathbfb mathbfd mathbfe  ℝ^n are vectors of length n, mathbf0_n is the zero vector of length n, and cf  ℝ are real numbers.\n\nThen the formula reads\n\nexp_g(X) =\nbeginpmatrix 1  (mathbfa+mathbfd)^mathrmT  c+f+frac12mathbfd^mathrmTmathbfe + mathbfa^mathrmTmathbfe mathbf0_n  I_n  mathbfb+mathbfe 0  mathbf0_n^mathrmT  1endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#Base.exp-Tuple{HeisenbergGroup, Any}","page":"Heisenberg group","title":"Base.exp","text":"exp(G::HeisenbergGroup, X)\nexp!(G::HeisenbergGroup, g, X)\n\nCompute the Lie group exponential for the HeisenbergGroup G of the vector X.\n\nFor X = beginpmatrix 0  mathbfa^mathrmT  c mathbf0_n  Z_n  mathbfb 0  mathbf0_n^mathrmT  0endpmatrix from the Lie algebra of the Heisenberg group, where mathbfa mathbfb  ℝ^n vectors of length n, mathbf0_n is the zero vector of length n, c  ℝ, and Z_n denotes the nn zero matrix.\n\nThen the\n\nexp_mathcal G(X) =\nbeginpmatrix 1  mathbfa^mathrmT  c + frac12mathbfa^mathrmTmathbfb mathbf0_n  I_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix\n\nwhere I_n is the nn unit matrix.\n\nThis can be computed in-place of the Lie group element g.\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#Base.log-Tuple{HeisenbergGroup, Any, Any}","page":"Heisenberg group","title":"Base.log","text":"log(G::HeisenbergGroup, g, h)\n\nCompute the logarithmic map on the HeisenbergGroup group.\n\nWe denote two points g h from the Heisenberg by\n\ng = beginpmatrix 1  mathbfa^mathrmT  c mathbf0_n  I_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix\nqquad\nh = beginpmatrix 1  mathbfd^mathrmT  f mathbf0_n  I_n  mathbfe 0  mathbf0_n^mathrmT  1endpmatrix\n\nwhere I_n is the nn unit matrix, mathbfa mathbfb mathbfd mathbfe  ℝ^n are vectors of length n, mathbf0_n is the zero vector of length n, and cf  ℝ are real numbers.\n\nThen formula reads\n\nlog_g(h) = beginpmatrix 0  (mathbfd-mathbfq)^mathrmT  f - c + mathbfa^mathrmTmathbfb - mathbfd^mathrmTmathbfe - frac12(mathbfd-mathbfa)^mathrmT(mathbfe-mathbfb) mathbf0_n  Z_n  mathbfe - mathbfb 0  mathbf0_n^mathrmT  0endpmatrix\n\nwhere additionally Z_n denotes the nn zero matrix.\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#Base.log-Tuple{HeisenbergGroup, Any}","page":"Heisenberg group","title":"Base.log","text":"log(G::HeisenbergGroup, g)\nlog!(G::HeisenbergGroup, X, g)\n\nCompute the Lie group logarithm for the HeisenbergGroup G.\n\nFor g = beginpmatrix 1  mathbfa^mathrmT  c mathbf0_n  I_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix from the Lie algebra of the Heisenberg group, where mathbfa mathbfb  ℝ^n vectors of length n, mathbf0_n is the zero vector of length n, c  ℝ, and I_n is the nn unit matrix.\n\nThen the\n\nlog_mathcal G(g) =\nbeginpmatrix 1  mathbfa^mathrmT  c - frac12mathbfa^mathrmTmathbfb mathbf0_n  Z_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix\n\nwhere Z_n denotes the nn zero matrix.\n\nThis can be computed in-place of the Lie algebra vector X.\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#ManifoldsBase.injectivity_radius-Tuple{HeisenbergGroup}","page":"Heisenberg group","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(G::HeisenbergGroup)\n\nReturn the injectivity radius on the HeisenbergGroup G, which is .\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#Literature","page":"Heisenberg group","title":"Literature","text":"","category":"section"},{"location":"groups/heisenberg_group/","page":"Heisenberg group","title":"Heisenberg group","text":"E. Biny and S. Pods. The Geometry of Heisenberg Groups: With Applications in Signal Theory, Optics, Quantization, and Field Quantization (American Mathematical Society, 2008).\n\n\n\n","category":"page"},{"location":"groups/special_galilean_group/#The-special-Galilean-group","page":"Special Galilean group","title":"The special Galilean group","text":"","category":"section"},{"location":"groups/special_galilean_group/#LieGroups.RotationBoostAction","page":"Special Galilean group","title":"LieGroups.RotationBoostAction","text":"RotationBoostAction\n\nThe group action of the semidirect product of spatial rotations and velocity boosts ((R v) in SO(n)  ℝⁿ)  on the space of events (position, time) ((p t) in ℝⁿ  ℝ). See [Kel25, section 4.1] and apply!.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_galilean_group/#LieGroups.SpecialGalileanGroup-Tuple{Int64}","page":"Special Galilean group","title":"LieGroups.SpecialGalileanGroup","text":"SpecialGalileanGroup(n::Int)\n\nConstruct the special Galilean group SGal(n) as a nested semidirect product:     (SO(n)  ℝⁿ)  (ℝⁿ  ℝ) where R  SO(n) are spatial rotations, v  ℝⁿ are velocity boosts, and (p t)  (ℝⁿ  ℝ) are the (position, time) events. The affine representation of the group is given by the matrix:\n\nmathrmSGal(3) = beginbmatrix\nR  v  p \n0  1  t \n0  0  1\nendbmatrix subset mathbbR^5times 5\n\nAnd the ArrayPartition representation as: ((R v) (p t))\n\nThe group operation (compose) is given by:\n\n((R_1 v_1) (p_1 t_1)) circ ((R_2 v_2) (p_2 t_2))\n= ((R_1 R_2 v_1 + R_1 v_2) (p_1 + v_1 t_2 + R_1 p_2 t_1 + t_2))\n\nand the identity element (identity_element) is ((I_n mathbf0) (mathbf0 0)).\n\nnote: Technical Detail\nThe ArrayPartition (default) implementation requires RecursiveArrayTools.jl to be loaded. The matrix representation is not implemented yet.\n\n[Kel25]\n\n\n\n\n\n","category":"method"},{"location":"groups/special_galilean_group/#Base.exp-Tuple{SpecialGalileanGroup{ManifoldsBase.TypeParameter{Tuple{3}}, <:LeftSemidirectProductGroupOperation{LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, ProductGroupOperation{Tuple{AdditionGroupOperation, AdditionGroupOperation}}, LieGroups.RotationBoostAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}}}, ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{1}}}}}}}}, Any}","page":"Special Galilean group","title":"Base.exp","text":"LieGroups.exp(M::SpecialGalileanGroup, X)\nLieGroups.exp!(M::SpecialGalileanGroup, h, X)\n\nCompute the Lie group exponential function on the SpecialGalileanGroup(3), where X is an element of the Lie algebra.\n\nThe closed-form expression for the matrix exponential from [Kel25, section 6] is used.\n\nexp X\n=\nexpbeginbmatrix\nboldsymbolphi^wedge  nu  rho \n0  0  iota \n0  0  0\nendbmatrix\n= beginbmatrix\nC  Dν  Dρ + Eνι \n0  1  ι \n0  0  1\nendbmatrix\n\nwhere\n\nC = I_3 + sin(phi) mathbfu^wedge + bigl(1 - cos(phi)bigr) mathbfu^wedgemathbfu^wedge \n\nD = I_3 + frac1 - cos(phi)phi  mathbfu^wedge\n+ fracphi - sin(phi)phi  mathbfu^wedgemathbfu^wedge \n\nE = tfrac12 I_3\n+ fracphi - sin(phi)phi^2  mathbfu^wedge\n+ fracphi^2 + 2cos(phi) - 22phi^2  mathbfu^wedgemathbfu^wedge\n\nboldsymbolphi=phi mathbfu is the angle-axis rotation parameterization with phi = boldsymbolphi and mathbfu = boldsymbolphiphi. \n\nThe computation can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_galilean_group/#Base.log-Tuple{SpecialGalileanGroup{ManifoldsBase.TypeParameter{Tuple{3}}, <:LeftSemidirectProductGroupOperation{LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, ProductGroupOperation{Tuple{AdditionGroupOperation, AdditionGroupOperation}}, LieGroups.RotationBoostAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}}}, ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{1}}}}}}}}, Any}","page":"Special Galilean group","title":"Base.log","text":"LieGroups.log(M::SpecialGalileanGroup, g)\nLieGroups.log!(M::SpecialGalileanGroup, X, g)\n\nCompute the Lie group logarithm function on the SpecialGalileanGroup(3), where g is a group element.\n\nThe closed-form expression from [Kel25, section 6] is used.\n\nThe computation can be done in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_galilean_group/#LieGroups.apply!-Tuple{GroupAction{LieGroups.RotationBoostAction}, Any, Any, Any}","page":"Special Galilean group","title":"LieGroups.apply!","text":"LieGroups.apply!(A::GroupAction{RotationBoostAction}, k, g, h)\n\nApply the action of the rotation-boost semidirect product group (SO(n) ⋉ ℝⁿ) on an event (p t). Given group element g = (R v) and event h = (p t), computes the transformed event k = (Rp + vt t). See [Kel25, section 4.1].\n\n\n\n\n\n","category":"method"},{"location":"groups/special_galilean_group/#ManifoldsBase.exp!-Tuple{SpecialGalileanGroup{ManifoldsBase.TypeParameter{Tuple{3}}, <:LeftSemidirectProductGroupOperation{LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, ProductGroupOperation{Tuple{AdditionGroupOperation, AdditionGroupOperation}}, LieGroups.RotationBoostAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}}}, ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{1}}}}}}}}, Any, Any}","page":"Special Galilean group","title":"ManifoldsBase.exp!","text":"LieGroups.exp(M::SpecialGalileanGroup, X)\nLieGroups.exp!(M::SpecialGalileanGroup, h, X)\n\nCompute the Lie group exponential function on the SpecialGalileanGroup(3), where X is an element of the Lie algebra.\n\nThe closed-form expression for the matrix exponential from [Kel25, section 6] is used.\n\nexp X\n=\nexpbeginbmatrix\nboldsymbolphi^wedge  nu  rho \n0  0  iota \n0  0  0\nendbmatrix\n= beginbmatrix\nC  Dν  Dρ + Eνι \n0  1  ι \n0  0  1\nendbmatrix\n\nwhere\n\nC = I_3 + sin(phi) mathbfu^wedge + bigl(1 - cos(phi)bigr) mathbfu^wedgemathbfu^wedge \n\nD = I_3 + frac1 - cos(phi)phi  mathbfu^wedge\n+ fracphi - sin(phi)phi  mathbfu^wedgemathbfu^wedge \n\nE = tfrac12 I_3\n+ fracphi - sin(phi)phi^2  mathbfu^wedge\n+ fracphi^2 + 2cos(phi) - 22phi^2  mathbfu^wedgemathbfu^wedge\n\nboldsymbolphi=phi mathbfu is the angle-axis rotation parameterization with phi = boldsymbolphi and mathbfu = boldsymbolphiphi. \n\nThe computation can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_galilean_group/#ManifoldsBase.hat!-Tuple{ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, SpecialGalileanGroup{ManifoldsBase.TypeParameter{Tuple{3}}, LeftSemidirectProductGroupOperation{LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, ProductGroupOperation{Tuple{AdditionGroupOperation, AdditionGroupOperation}}, LieGroups.RotationBoostAction, ActionActsOnRight}, ManifoldsBase.ProductManifold{ℝ, Tuple{ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}}}, ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{1}}}}}}}}, Identity{LeftSemidirectProductGroupOperation{LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, ProductGroupOperation{Tuple{AdditionGroupOperation, AdditionGroupOperation}}, LieGroups.RotationBoostAction, ActionActsOnRight}}}, Any, Any}","page":"Special Galilean group","title":"ManifoldsBase.hat!","text":"X = hat(𝔤::LieAlgebra{ℝ,LeftSpecialGalileanGroupOperation,<:SpecialGalileanGroup}, c)\nhat!(𝔤::LieAlgebra{ℝ,LeftSpecialGalileanGroupOperation,<:SpecialGalileanGroup}, X, c)\n\nCompute the hat map ()^wedge  ℝ^10  𝔤 that turns a vector of coordinates c into a tangent vector in the Lie algebra.\n\nbeginbmatrix\nrho  nu  phi  iota\nendbmatrix^wedge\n=\nbeginbmatrix\nphi^wedge  nu  rho \n0  0  iota \n0  0  0\nendbmatrix\nin mathbbR^5times 5\n\nThe basis is defined in eq 14 of [Kel25].\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_galilean_group/#ManifoldsBase.hat-Tuple{ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, SpecialGalileanGroup{ManifoldsBase.TypeParameter{Tuple{3}}, LeftSemidirectProductGroupOperation{LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, ProductGroupOperation{Tuple{AdditionGroupOperation, AdditionGroupOperation}}, LieGroups.RotationBoostAction, ActionActsOnRight}, ManifoldsBase.ProductManifold{ℝ, Tuple{ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}}}, ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{1}}}}}}}}, Identity{LeftSemidirectProductGroupOperation{LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, ProductGroupOperation{Tuple{AdditionGroupOperation, AdditionGroupOperation}}, LieGroups.RotationBoostAction, ActionActsOnRight}}}, Any}","page":"Special Galilean group","title":"ManifoldsBase.hat","text":"X = hat(𝔤::LieAlgebra{ℝ,LeftSpecialGalileanGroupOperation,<:SpecialGalileanGroup}, c)\nhat!(𝔤::LieAlgebra{ℝ,LeftSpecialGalileanGroupOperation,<:SpecialGalileanGroup}, X, c)\n\nCompute the hat map ()^wedge  ℝ^10  𝔤 that turns a vector of coordinates c into a tangent vector in the Lie algebra.\n\nbeginbmatrix\nrho  nu  phi  iota\nendbmatrix^wedge\n=\nbeginbmatrix\nphi^wedge  nu  rho \n0  0  iota \n0  0  0\nendbmatrix\nin mathbbR^5times 5\n\nThe basis is defined in eq 14 of [Kel25].\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_galilean_group/#ManifoldsBase.log!-Tuple{SpecialGalileanGroup{ManifoldsBase.TypeParameter{Tuple{3}}, <:LeftSemidirectProductGroupOperation{LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, ProductGroupOperation{Tuple{AdditionGroupOperation, AdditionGroupOperation}}, LieGroups.RotationBoostAction, ActionActsOnRight}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}}}, ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{1}}}}}}}}, Any, Any}","page":"Special Galilean group","title":"ManifoldsBase.log!","text":"LieGroups.log(M::SpecialGalileanGroup, g)\nLieGroups.log!(M::SpecialGalileanGroup, X, g)\n\nCompute the Lie group logarithm function on the SpecialGalileanGroup(3), where g is a group element.\n\nThe closed-form expression from [Kel25, section 6] is used.\n\nThe computation can be done in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_galilean_group/#ManifoldsBase.vee!-Tuple{ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, SpecialGalileanGroup{ManifoldsBase.TypeParameter{Tuple{3}}, LeftSemidirectProductGroupOperation{LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, ProductGroupOperation{Tuple{AdditionGroupOperation, AdditionGroupOperation}}, LieGroups.RotationBoostAction, ActionActsOnRight}, ManifoldsBase.ProductManifold{ℝ, Tuple{ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}}}, ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{1}}}}}}}}, Identity{LeftSemidirectProductGroupOperation{LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, ProductGroupOperation{Tuple{AdditionGroupOperation, AdditionGroupOperation}}, LieGroups.RotationBoostAction, ActionActsOnRight}}}, Any, Any}","page":"Special Galilean group","title":"ManifoldsBase.vee!","text":"c = vee(𝔤::LieAlgebra{ℝ,<:LeftSpecialGalileanGroupOperation,<:SpecialGalileanGroup}, X)\nvee!(𝔤::LieAlgebra{ℝ,LeftSpecialGalileanGroupOperation,<:SpecialGalileanGroup}, c, X)\n\nCompute the vee map ()^vee mathfrak g   ℝ^10 that maps a tangent vector from the Lie algebra to a vector of coordinates c.\n\nbeginbmatrix\nphi^wedge  nu  rho \n0  0  iota \n0  0  0\nendbmatrix^vee =\nbeginbmatrix\nrho  nu  phi  iota\nendbmatrix\nin mathbbR^10\n\nThe basis is defined in eq 14 of [Kel25].\n\nThis can be computed in-place of c.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_galilean_group/#ManifoldsBase.vee-Tuple{ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, SpecialGalileanGroup{ManifoldsBase.TypeParameter{Tuple{3}}, LeftSemidirectProductGroupOperation{LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, ProductGroupOperation{Tuple{AdditionGroupOperation, AdditionGroupOperation}}, LieGroups.RotationBoostAction, ActionActsOnRight}, ManifoldsBase.ProductManifold{ℝ, Tuple{ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}}}, ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ℝ, ManifoldsBase.TypeParameter{Tuple{1}}}}}}}}, Identity{LeftSemidirectProductGroupOperation{LeftSemidirectProductGroupOperation{MatrixMultiplicationGroupOperation, AdditionGroupOperation, LeftMultiplicationGroupAction, ActionActsOnRight}, ProductGroupOperation{Tuple{AdditionGroupOperation, AdditionGroupOperation}}, LieGroups.RotationBoostAction, ActionActsOnRight}}}, Any}","page":"Special Galilean group","title":"ManifoldsBase.vee","text":"c = vee(𝔤::LieAlgebra{ℝ,<:LeftSpecialGalileanGroupOperation,<:SpecialGalileanGroup}, X)\nvee!(𝔤::LieAlgebra{ℝ,LeftSpecialGalileanGroupOperation,<:SpecialGalileanGroup}, c, X)\n\nCompute the vee map ()^vee mathfrak g   ℝ^10 that maps a tangent vector from the Lie algebra to a vector of coordinates c.\n\nbeginbmatrix\nphi^wedge  nu  rho \n0  0  iota \n0  0  0\nendbmatrix^vee =\nbeginbmatrix\nrho  nu  phi  iota\nendbmatrix\nin mathbbR^10\n\nThe basis is defined in eq 14 of [Kel25].\n\nThis can be computed in-place of c.\n\n\n\n\n\n","category":"method"},{"location":"groups/product_group/#The-product-Lie-group","page":"Product group","title":"The product Lie group","text":"","category":"section"},{"location":"groups/product_group/#LieGroups.AbstractProductGroupOperation","page":"Product group","title":"LieGroups.AbstractProductGroupOperation","text":"AbstractProductGroupOperation <: AbstractGroupOperation\n\nAn abstract type to model group operations on a product manifold\n\n\n\n\n\n","category":"type"},{"location":"groups/product_group/#LieGroups.ProductGroupOperation","page":"Product group","title":"LieGroups.ProductGroupOperation","text":"ProductGroupOperation{O<:NTuple{N,AbstractGroupOperation} where N} <: AbstractProductGroupOperation\n\nA struct do model a tuple of group operations, one for each factor of a product group, that together forms a new group operation.\n\nAccess to the single operations can be done by pgo[i].\n\nConstructor\n\nProductGroupOperation(o::AbstractGroupOperation...)\n×(o::AbstractGroupOperation...) = ProductGroupOperation(o...)\n\n\n\n\n\n","category":"type"},{"location":"groups/product_group/#LieGroups.ProductLieGroup-Tuple{Vararg{LieGroup}}","page":"Product group","title":"LieGroups.ProductLieGroup","text":"ProductLieGroup(G1, G2, ..., Gn)\n\nReturn the LieGroup of the product of Lie groups G1, G2, up to Gn and all following Lie groups. This can be considered as a vector of Lie group, where the vector is always of the same length as the number of provided Lie Groups.\n\nIf none of the Lie groups are product Lie groups themselves, this is equivalent to G1 × G2 × ... × Gn.\n\nFor an example illustrating the differences see [x](@ref LinearAlgebra.cross(::LieGroup...)(::LieGroup...).\n\n\n\n\n\n","category":"method"},{"location":"groups/product_group/#LinearAlgebra.cross-Tuple{Vararg{AbstractGroupOperation}}","page":"Product group","title":"LinearAlgebra.cross","text":"cross(O1::AbstractGroupOperation, O2::AbstractGroupOperation)\nO1 × O2\nO1 × O2 × O3 × ...\n\nReturn the ProductGroupOperation For two AbstractGroupOperation` O1 and O2, where for the case that one of them is a ProductGroupOperation itself, the other is either prepended (if O1 is a product) or appended (if O2 is). If both are product operations, they are combined into one, keeping the order of operations.\n\nFor the case that more than two are concatenated with × this is iterated.\n\n\n\n\n\n","category":"method"},{"location":"groups/product_group/#LinearAlgebra.cross-Tuple{Vararg{LieGroup}}","page":"Product group","title":"LinearAlgebra.cross","text":"cross(G::LieGroup, H::LieGroup)\nG × H\nG1 × G2 × G3 × ...\n\nReturn the ProductLieGroup For two LieGroups G and H.\n\nFor the case that one of them is a product Lie group already, the other one is appended or prepended, depending on which one is the product; they are joined into one large product if both are product Lie groups.\n\nIn order to build a ProductLieGroup that does not “splat” its arguments, or in other words to obtain “nested” products, use ProductLieGroup(G1, G2, G3, ...).\n\nExample.\n\nFor\n\nG1 = TranslationGroup(2)\nG2 = SpecialOrthogonalGroup(2)\nG3 = GeneralLinearGroup(2)\n\nWe can have one large product Lie group\n\nG = G1 × G2 × G3 # or equivalently ProductLieGroup(G1, G2, G3)\n\nand alternatively generate a product of a Lie group with an existing product using\n\nH = ProductLieGroup(G1, G2 × G3)\n\nnote: Technical detail\nSince for the first, single Lie group, the order should be irrelevant, it means in practice that × behaves slightly different than ProductLieGroup in that it “splats” its arguments. G is equivalent to calling ProductLieGroup(G1, G2) × G3 or G1 × ProductLieGroup(G2, G3). Both, as G would consist of vectors of length 3. These are different from both ProductLieGroup(ProductLieGroup(G1, G2), G3) and ProductLieGroup(G1, ProductLieGroup(G2, G3)), which are both vectors of length 2, where the first has a vector of length 2 in its first component, the second such a vector in its second component.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#The-special-orthogonal-group","page":"Special orthogonal group","title":"The special orthogonal group","text":"","category":"section"},{"location":"groups/special_orthogonal_group/#LieGroups.SpecialOrthogonalGroup","page":"Special orthogonal group","title":"LieGroups.SpecialOrthogonalGroup","text":"SpecialOrthogonalGroup{T}\n\nThe special orthogonal group mathrmSO(n) is the Lie group consisting of the MatrixMultiplicationGroupOperation on the manifold of rotations Rotations.\n\nConstructor\n\nSpecialOrthogonalGroup(n::Int; kwargs...)\n\nGenerate  special orthogonal group mathrmSO(n). All keyword arguments in kwargs... are passed on to Rotations as well.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_orthogonal_group/","page":"Special orthogonal group","title":"Special orthogonal group","text":"For this Lie group, several implementations are already covered by the defaults in the generic (matrix) multiplication operation.","category":"page"},{"location":"groups/special_orthogonal_group/#Functions","page":"Special orthogonal group","title":"Functions","text":"","category":"section"},{"location":"groups/special_orthogonal_group/#Base.exp-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any}","page":"Special orthogonal group","title":"Base.exp","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, these simplify for the case of 22 matrices to X=beginpmatrix 0  -α α  0endpmatrix, for some αℝ.\n\nTheir exponential is\n\nexp_mathcal G(X) =  beginpmatrix cos(α)  -sin(α) sin(α)  cos(α)endpmatrix\n\nThis result can be computed in-place of g.\n\nNote that since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#Base.exp-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any}","page":"Special orthogonal group","title":"Base.exp","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, the 33 skew symmetric matrices are of the form\n\n    X = beginpmatrix 0  -c  b c  0  -a -b  a  0endpmatrix\n\nfor some a b c  ℝ. To compute the exponential, the Rodrigues' rotation formula can be used. With α = sqrta^2+b^2+c^2 = frac1sqrt2lVert X rVert_ we obtain for α  0\n\nexp_mathcal G(X) = I_3 + fracsinαX + frac(1 - cos)α^2X^2\n\nand \\exp{\\mathcal G}(X) = I3`` otherwise.\n\nThis result can be computed in-place of g.\n\nNote that since mathrmSO(3) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#Base.exp-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any}","page":"Special orthogonal group","title":"Base.exp","text":"exp(G, e, X)\nexp!(G, e, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSimilar to the 33 case, an efficient computation is provided, adapted from [GX02], [AR13] with a few numerical stabilisations.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#Base.log-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any}","page":"Special orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nFor the two-dimensional case, any rotation matrix g can be represented as beginpmatrix cos(α)  -sin(α) sin(α)  cos(α)endpmatrix. For the SpecialOrthogonalGroup, g might also include reflections.\n\nThe logarithm is then\n\nlog_mathcal G(g) =  beginpmatrix 0  α -α  0endpmatrix\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#Base.log-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any}","page":"Special orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nHere, exp_mathcal G(X) = g is inverted using the Rodrigues' rotation formula\n\nexp_mathcal G(X) = I_3 + fracsinαX + frac(1 - cos)α^2X^2\n\nFor α   0 π  we obtain X from the observation that\n\nmathrmtr(g) = 1 + 2cos(α)\nqquadtext and qquad\nfrac12(g-g^mathrmT) = sin(α)X\n\nFor α = 0 we have g = I_3 and X = 0.\n\nFor α = π we have to solve X^2 = frac12(g-I_3), where X is skew-symmetric and hence we have to solve for three unknowns.\n\nlog_mathcal G(g) = X\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(3) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#Base.log-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any}","page":"Special orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nThe implementation is based on a generalized variant of the Rodrigues' like formula. For details, see [GX02, Section 3].\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#LieGroups.jacobian_exp","page":"Special orthogonal group","title":"LieGroups.jacobian_exp","text":"jacobian_exp(M::SpecialOrthogonalGroup{TypeParameter{Tuple{3}}}, p, X, ::DefaultLieAlgebraOrthogonalBasis)\njacobian_exp!(M::SpecialOrthogonalGroup{TypeParameter{Tuple{3}}}, J, p, X, ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute Jacobian of the Lie group exponential in a basis of the Lie algebra on the SpecialOrthogonalGroup(3) manifold. The formula reads\n\nJ = 𝕀 + fraccos(θ) - 1θ^2 X + fracθ - sin(θ)θ^3 X^2\n\nwhere θ is the norm of X. It is adapted from [Chi12], Eq. (10.86), to LieGroups.jl conventions.\n\n\n\n\n\n","category":"function"},{"location":"groups/special_orthogonal_group/#LieGroups.jacobian_exp-2","page":"Special orthogonal group","title":"LieGroups.jacobian_exp","text":"jacobian_exp(M::SpecialOrthogonalGroup{TypeParameter{Tuple{2}}}, g, X, ::DefaultLieAlgebraOrthogonalBasis)\njacobian_exp!(M::SpecialOrthogonalGroup{TypeParameter{Tuple{2}}}, J, g, X, ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute Jacobian of the Lie group exponential in a basis of the Lie algebra on the SpecialOrthogonalGroup(2) manifold.\n\nIt is equal to matrix 1, see [SDA21], Appendix A.\n\n\n\n\n\n","category":"function"},{"location":"groups/special_orthogonal_group/#LieGroups.jacobian_exp!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, AbstractMatrix, Any, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Special orthogonal group","title":"LieGroups.jacobian_exp!","text":"jacobian_exp(M::SpecialOrthogonalGroup{TypeParameter{Tuple{2}}}, g, X, ::DefaultLieAlgebraOrthogonalBasis)\njacobian_exp!(M::SpecialOrthogonalGroup{TypeParameter{Tuple{2}}}, J, g, X, ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute Jacobian of the Lie group exponential in a basis of the Lie algebra on the SpecialOrthogonalGroup(2) manifold.\n\nIt is equal to matrix 1, see [SDA21], Appendix A.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#LieGroups.jacobian_exp!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, AbstractMatrix, Any, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Special orthogonal group","title":"LieGroups.jacobian_exp!","text":"jacobian_exp(M::SpecialOrthogonalGroup{TypeParameter{Tuple{3}}}, p, X, ::DefaultLieAlgebraOrthogonalBasis)\njacobian_exp!(M::SpecialOrthogonalGroup{TypeParameter{Tuple{3}}}, J, p, X, ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute Jacobian of the Lie group exponential in a basis of the Lie algebra on the SpecialOrthogonalGroup(3) manifold. The formula reads\n\nJ = 𝕀 + fraccos(θ) - 1θ^2 X + fracθ - sin(θ)θ^3 X^2\n\nwhere θ is the norm of X. It is adapted from [Chi12], Eq. (10.86), to LieGroups.jl conventions.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.exp!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, these simplify for the case of 22 matrices to X=beginpmatrix 0  -α α  0endpmatrix, for some αℝ.\n\nTheir exponential is\n\nexp_mathcal G(X) =  beginpmatrix cos(α)  -sin(α) sin(α)  cos(α)endpmatrix\n\nThis result can be computed in-place of g.\n\nNote that since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.exp!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, the 33 skew symmetric matrices are of the form\n\n    X = beginpmatrix 0  -c  b c  0  -a -b  a  0endpmatrix\n\nfor some a b c  ℝ. To compute the exponential, the Rodrigues' rotation formula can be used. With α = sqrta^2+b^2+c^2 = frac1sqrt2lVert X rVert_ we obtain for α  0\n\nexp_mathcal G(X) = I_3 + fracsinαX + frac(1 - cos)α^2X^2\n\nand \\exp{\\mathcal G}(X) = I3`` otherwise.\n\nThis result can be computed in-place of g.\n\nNote that since mathrmSO(3) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.exp!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, e, X)\nexp!(G, e, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSimilar to the 33 case, an efficient computation is provided, adapted from [GX02], [AR13] with a few numerical stabilisations.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.get_coordinates!-Tuple{SpecialOrthogonalGroup, Any, Identity{MatrixMultiplicationGroupOperation}, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Special orthogonal group","title":"ManifoldsBase.get_coordinates!","text":"get_coordinates(𝔤::OrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates(G::SpecialOrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::OrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::SpecialOrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the vector of coordinates c  ℝ^d from the Lie algebra tangent vector X  𝔬(n) of the OrthogonalGroup O(n) in the DefaultLieAlgebraOrthogonalBasis, where d is the dimension of the Lie algebra. This is also the version used in vee.\n\nFor O(2) there is only one coefficient α in the basis beginpmatrix 0  -α α  0endpmatrix, which is returned as c = (α)^mathrmT.\n\nA usual basis representation of ``𝔬(3) is given by\n\n    X = beginpmatrix 0  -γ  β γ  0  -α -β  α  0endpmatrix\n\nhence the coordinate vector is c = (α β γ)^mathrmT  ℝ^3.\n\nFor n ≥ 4the lower triangular part is added toc` row-wise.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.get_coordinates-Tuple{SpecialOrthogonalGroup, Identity{MatrixMultiplicationGroupOperation}, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Special orthogonal group","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(𝔤::OrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates(G::SpecialOrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::OrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::SpecialOrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the vector of coordinates c  ℝ^d from the Lie algebra tangent vector X  𝔬(n) of the OrthogonalGroup O(n) in the DefaultLieAlgebraOrthogonalBasis, where d is the dimension of the Lie algebra. This is also the version used in vee.\n\nFor O(2) there is only one coefficient α in the basis beginpmatrix 0  -α α  0endpmatrix, which is returned as c = (α)^mathrmT.\n\nA usual basis representation of ``𝔬(3) is given by\n\n    X = beginpmatrix 0  -γ  β γ  0  -α -β  α  0endpmatrix\n\nhence the coordinate vector is c = (α β γ)^mathrmT  ℝ^3.\n\nFor n ≥ 4the lower triangular part is added toc` row-wise.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.get_vector!-Tuple{SpecialOrthogonalGroup, Any, Identity{MatrixMultiplicationGroupOperation}, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Special orthogonal group","title":"ManifoldsBase.get_vector!","text":"get_vector(G::OrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector(G::SpecialOrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::OrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::SpecialOrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the tangent vector X  𝔬(n) based on a vector of coordinates c  ℝ^d, where d is the dimension of the Lie algebra of the OrthogonalGroup O(n) and the coordinates are with respect to the DefaultLieAlgebraOrthogonalBasis. This is also the version used in hat.\n\nFor O(2) there is only one coefficient ``c = (α)^mathrmT and hence X = beginpmatrix 0  -α α  0endpmatrix is returned.\n\nFor n=3 a usual representtion turns c = (α β γ)^mathrmT  ℝ^3 into\n\n    X = beginpmatrix 0  -γ  β γ  0  -α -β  α  0endpmatrix\n\nhence the coordinate vector is .\n\nFor n ≥ 4` all further coefficients are used to fill up the following rows of the lower triangular part – which determines the upper triangular part due to skew-symmetry\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.get_vector-Tuple{SpecialOrthogonalGroup, Identity{MatrixMultiplicationGroupOperation}, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Special orthogonal group","title":"ManifoldsBase.get_vector","text":"get_vector(G::OrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector(G::SpecialOrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::OrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::SpecialOrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the tangent vector X  𝔬(n) based on a vector of coordinates c  ℝ^d, where d is the dimension of the Lie algebra of the OrthogonalGroup O(n) and the coordinates are with respect to the DefaultLieAlgebraOrthogonalBasis. This is also the version used in hat.\n\nFor O(2) there is only one coefficient ``c = (α)^mathrmT and hence X = beginpmatrix 0  -α α  0endpmatrix is returned.\n\nFor n=3 a usual representtion turns c = (α β γ)^mathrmT  ℝ^3 into\n\n    X = beginpmatrix 0  -γ  β γ  0  -α -β  α  0endpmatrix\n\nhence the coordinate vector is .\n\nFor n ≥ 4` all further coefficients are used to fill up the following rows of the lower triangular part – which determines the upper triangular part due to skew-symmetry\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.log!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nFor the two-dimensional case, any rotation matrix g can be represented as beginpmatrix cos(α)  -sin(α) sin(α)  cos(α)endpmatrix. For the SpecialOrthogonalGroup, g might also include reflections.\n\nThe logarithm is then\n\nlog_mathcal G(g) =  beginpmatrix 0  α -α  0endpmatrix\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.log!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nHere, exp_mathcal G(X) = g is inverted using the Rodrigues' rotation formula\n\nexp_mathcal G(X) = I_3 + fracsinαX + frac(1 - cos)α^2X^2\n\nFor α   0 π  we obtain X from the observation that\n\nmathrmtr(g) = 1 + 2cos(α)\nqquadtext and qquad\nfrac12(g-g^mathrmT) = sin(α)X\n\nFor α = 0 we have g = I_3 and X = 0.\n\nFor α = π we have to solve X^2 = frac12(g-I_3), where X is skew-symmetric and hence we have to solve for three unknowns.\n\nlog_mathcal G(g) = X\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(3) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.log!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nThe implementation is based on a generalized variant of the Rodrigues' like formula. For details, see [GX02, Section 3].\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#The-orthogonal-group","page":"Orthogonal group","title":"The orthogonal group","text":"","category":"section"},{"location":"groups/orthogonal_group/#LieGroups.OrthogonalGroup","page":"Orthogonal group","title":"LieGroups.OrthogonalGroup","text":"OrthogonalGroup{T}\n\nThe orthogonal group mathrmO(n) is the Lie group consisting of the MatrixMultiplicationGroupOperation on the manifold of rotations OrthogonalMatrices.\n\nConstructor\n\nOrthogonalGroup(n::Int; kwargs...)\n\nGenerate  orthogonal group mathrmO(n). All keyword arguments in kwargs... are passed on to OrthogonalMatrices as well.\n\n\n\n\n\n","category":"type"},{"location":"groups/orthogonal_group/","page":"Orthogonal group","title":"Orthogonal group","text":"For this Lie group, several implementations are already covered by the defaults in the generic (matrix) multiplication operation.","category":"page"},{"location":"groups/orthogonal_group/#Functions","page":"Orthogonal group","title":"Functions","text":"","category":"section"},{"location":"groups/orthogonal_group/#Base.exp-Tuple{LieGroup{ℝ, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ℝ, ManifoldsBase.TypeParameter{Tuple{2}}, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any}","page":"Orthogonal group","title":"Base.exp","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, these simplify for the case of 22 matrices to X=beginpmatrix 0  -α α  0endpmatrix, for some αℝ.\n\nTheir exponential is\n\nexp_mathcal G(X) =  beginpmatrix cos(α)  -sin(α) sin(α)  cos(α)endpmatrix\n\nThis result can be computed in-place of g.\n\nNote that since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Base.exp-Tuple{LieGroup{ℝ, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any}","page":"Orthogonal group","title":"Base.exp","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, the 33 skew symmetric matrices are of the form\n\n    X = beginpmatrix 0  -c  b c  0  -a -b  a  0endpmatrix\n\nfor some a b c  ℝ. To compute the exponential, the Rodrigues' rotation formula can be used. With α = sqrta^2+b^2+c^2 = frac1sqrt2lVert X rVert_ we obtain for α  0\n\nexp_mathcal G(X) = I_3 + fracsinαX + frac(1 - cos)α^2X^2\n\nand \\exp{\\mathcal G}(X) = I3`` otherwise.\n\nThis result can be computed in-place of g.\n\nNote that since mathrmSO(3) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Base.exp-Tuple{LieGroup{ℝ, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ℝ, ManifoldsBase.TypeParameter{Tuple{4}}, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any}","page":"Orthogonal group","title":"Base.exp","text":"exp(G, e, X)\nexp!(G, e, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSimilar to the 33 case, an efficient computation is provided, adapted from [GX02], [AR13] with a few numerical stabilisations.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Base.log-Tuple{LieGroup{ℝ, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ℝ, ManifoldsBase.TypeParameter{Tuple{2}}, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any}","page":"Orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nFor the two-dimensional case, any rotation matrix g can be represented as beginpmatrix cos(α)  -sin(α) sin(α)  cos(α)endpmatrix. For the SpecialOrthogonalGroup, g might also include reflections.\n\nThe logarithm is then\n\nlog_mathcal G(g) =  beginpmatrix 0  α -α  0endpmatrix\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Base.log-Tuple{LieGroup{ℝ, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any}","page":"Orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nHere, exp_mathcal G(X) = g is inverted using the Rodrigues' rotation formula\n\nexp_mathcal G(X) = I_3 + fracsinαX + frac(1 - cos)α^2X^2\n\nFor α   0 π  we obtain X from the observation that\n\nmathrmtr(g) = 1 + 2cos(α)\nqquadtext and qquad\nfrac12(g-g^mathrmT) = sin(α)X\n\nFor α = 0 we have g = I_3 and X = 0.\n\nFor α = π we have to solve X^2 = frac12(g-I_3), where X is skew-symmetric and hence we have to solve for three unknowns.\n\nlog_mathcal G(g) = X\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(3) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Base.log-Tuple{LieGroup{ℝ, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ℝ, ManifoldsBase.TypeParameter{Tuple{4}}, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any}","page":"Orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nThe implementation is based on a generalized variant of the Rodrigues' like formula. For details, see [GX02, Section 3].\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.exp!-Tuple{LieGroup{ℝ, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ℝ, ManifoldsBase.TypeParameter{Tuple{2}}, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, these simplify for the case of 22 matrices to X=beginpmatrix 0  -α α  0endpmatrix, for some αℝ.\n\nTheir exponential is\n\nexp_mathcal G(X) =  beginpmatrix cos(α)  -sin(α) sin(α)  cos(α)endpmatrix\n\nThis result can be computed in-place of g.\n\nNote that since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.exp!-Tuple{LieGroup{ℝ, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, the 33 skew symmetric matrices are of the form\n\n    X = beginpmatrix 0  -c  b c  0  -a -b  a  0endpmatrix\n\nfor some a b c  ℝ. To compute the exponential, the Rodrigues' rotation formula can be used. With α = sqrta^2+b^2+c^2 = frac1sqrt2lVert X rVert_ we obtain for α  0\n\nexp_mathcal G(X) = I_3 + fracsinαX + frac(1 - cos)α^2X^2\n\nand \\exp{\\mathcal G}(X) = I3`` otherwise.\n\nThis result can be computed in-place of g.\n\nNote that since mathrmSO(3) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.exp!-Tuple{LieGroup{ℝ, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ℝ, ManifoldsBase.TypeParameter{Tuple{4}}, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, e, X)\nexp!(G, e, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSimilar to the 33 case, an efficient computation is provided, adapted from [GX02], [AR13] with a few numerical stabilisations.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.get_coordinates!-Tuple{ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, LieGroup{ℝ, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ℝ, T, Manifolds.AbsoluteDeterminantOneMatrixType}}, Identity{MatrixMultiplicationGroupOperation}} where T, Any, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Orthogonal group","title":"ManifoldsBase.get_coordinates!","text":"get_coordinates(𝔤::OrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates(G::SpecialOrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::OrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::SpecialOrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the vector of coordinates c  ℝ^d from the Lie algebra tangent vector X  𝔬(n) of the OrthogonalGroup O(n) in the DefaultLieAlgebraOrthogonalBasis, where d is the dimension of the Lie algebra. This is also the version used in vee.\n\nFor O(2) there is only one coefficient α in the basis beginpmatrix 0  -α α  0endpmatrix, which is returned as c = (α)^mathrmT.\n\nA usual basis representation of ``𝔬(3) is given by\n\n    X = beginpmatrix 0  -γ  β γ  0  -α -β  α  0endpmatrix\n\nhence the coordinate vector is c = (α β γ)^mathrmT  ℝ^3.\n\nFor n ≥ 4the lower triangular part is added toc` row-wise.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.get_coordinates-Tuple{ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, LieGroup{ℝ, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ℝ, T, Manifolds.AbsoluteDeterminantOneMatrixType}}, Identity{MatrixMultiplicationGroupOperation}} where T, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Orthogonal group","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(𝔤::OrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates(G::SpecialOrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::OrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::SpecialOrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the vector of coordinates c  ℝ^d from the Lie algebra tangent vector X  𝔬(n) of the OrthogonalGroup O(n) in the DefaultLieAlgebraOrthogonalBasis, where d is the dimension of the Lie algebra. This is also the version used in vee.\n\nFor O(2) there is only one coefficient α in the basis beginpmatrix 0  -α α  0endpmatrix, which is returned as c = (α)^mathrmT.\n\nA usual basis representation of ``𝔬(3) is given by\n\n    X = beginpmatrix 0  -γ  β γ  0  -α -β  α  0endpmatrix\n\nhence the coordinate vector is c = (α β γ)^mathrmT  ℝ^3.\n\nFor n ≥ 4the lower triangular part is added toc` row-wise.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.get_vector!-Tuple{ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, LieGroup{ℝ, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ℝ, T, Manifolds.AbsoluteDeterminantOneMatrixType}}, Identity{MatrixMultiplicationGroupOperation}} where T, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Orthogonal group","title":"ManifoldsBase.get_vector!","text":"get_vector(G::OrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector(G::SpecialOrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::OrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::SpecialOrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the tangent vector X  𝔬(n) based on a vector of coordinates c  ℝ^d, where d is the dimension of the Lie algebra of the OrthogonalGroup O(n) and the coordinates are with respect to the DefaultLieAlgebraOrthogonalBasis. This is also the version used in hat.\n\nFor O(2) there is only one coefficient ``c = (α)^mathrmT and hence X = beginpmatrix 0  -α α  0endpmatrix is returned.\n\nFor n=3 a usual representtion turns c = (α β γ)^mathrmT  ℝ^3 into\n\n    X = beginpmatrix 0  -γ  β γ  0  -α -β  α  0endpmatrix\n\nhence the coordinate vector is .\n\nFor n ≥ 4` all further coefficients are used to fill up the following rows of the lower triangular part – which determines the upper triangular part due to skew-symmetry\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.get_vector-Tuple{ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, LieGroup{ℝ, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ℝ, T, Manifolds.AbsoluteDeterminantOneMatrixType}}, Identity{MatrixMultiplicationGroupOperation}} where T, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Orthogonal group","title":"ManifoldsBase.get_vector","text":"get_vector(G::OrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector(G::SpecialOrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::OrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::SpecialOrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the tangent vector X  𝔬(n) based on a vector of coordinates c  ℝ^d, where d is the dimension of the Lie algebra of the OrthogonalGroup O(n) and the coordinates are with respect to the DefaultLieAlgebraOrthogonalBasis. This is also the version used in hat.\n\nFor O(2) there is only one coefficient ``c = (α)^mathrmT and hence X = beginpmatrix 0  -α α  0endpmatrix is returned.\n\nFor n=3 a usual representtion turns c = (α β γ)^mathrmT  ℝ^3 into\n\n    X = beginpmatrix 0  -γ  β γ  0  -α -β  α  0endpmatrix\n\nhence the coordinate vector is .\n\nFor n ≥ 4` all further coefficients are used to fill up the following rows of the lower triangular part – which determines the upper triangular part due to skew-symmetry\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.log!-Tuple{LieGroup{ℝ, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ℝ, ManifoldsBase.TypeParameter{Tuple{2}}, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nFor the two-dimensional case, any rotation matrix g can be represented as beginpmatrix cos(α)  -sin(α) sin(α)  cos(α)endpmatrix. For the SpecialOrthogonalGroup, g might also include reflections.\n\nThe logarithm is then\n\nlog_mathcal G(g) =  beginpmatrix 0  α -α  0endpmatrix\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.log!-Tuple{LieGroup{ℝ, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ℝ, ManifoldsBase.TypeParameter{Tuple{3}}, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nHere, exp_mathcal G(X) = g is inverted using the Rodrigues' rotation formula\n\nexp_mathcal G(X) = I_3 + fracsinαX + frac(1 - cos)α^2X^2\n\nFor α   0 π  we obtain X from the observation that\n\nmathrmtr(g) = 1 + 2cos(α)\nqquadtext and qquad\nfrac12(g-g^mathrmT) = sin(α)X\n\nFor α = 0 we have g = I_3 and X = 0.\n\nFor α = π we have to solve X^2 = frac12(g-I_3), where X is skew-symmetric and hence we have to solve for three unknowns.\n\nlog_mathcal G(g) = X\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(3) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.log!-Tuple{LieGroup{ℝ, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ℝ, ManifoldsBase.TypeParameter{Tuple{4}}, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nThe implementation is based on a generalized variant of the Rodrigues' like formula. For details, see [GX02, Section 3].\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Utility-functions","page":"Orthogonal group","title":"Utility functions","text":"","category":"section"},{"location":"groups/orthogonal_group/#LieGroups.angles_4d_skew_sym_matrix","page":"Orthogonal group","title":"LieGroups.angles_4d_skew_sym_matrix","text":"angles_4d_skew_sym_matrix(A)\n\nThe Lie algebra 𝔰𝔬(4) of OrthogonalGroup(4) in ℝ^44, consists of 44 skew-symmetric matrices. The unique imaginary components of their eigenvalues are the angles of the two plane rotations. This function computes these more efficiently than eigvals.\n\nBy convention, the returned values are sorted in decreasing order. See also cos_angles_4d_rotation_matrix.\n\n\n\n\n\n","category":"function"},{"location":"groups/orthogonal_group/#LieGroups.cos_angles_4d_rotation_matrix","page":"Orthogonal group","title":"LieGroups.cos_angles_4d_rotation_matrix","text":"cos_angles_4d_rotation_matrix(R)\n\n4D rotations can be described by two orthogonal planes that are unchanged by the action of the rotation (vectors within a plane rotate only within the plane). The cosines of the two angles αβ of rotation about these planes may be obtained from the distinct real parts of the eigenvalues of the rotation matrix. This function computes these more efficiently by solving the system\n\nbeginaligned cosα + cosβ = frac12mathrmtr(R) cosα cosβ = frac18mathrmtr(R)^2 - frac116mathrmtr((R - R^T)^2) - 1endaligned\n\nBy convention, the returned values are sorted in decreasing order. See also angles_4d_skew_sym_matrix.\n\n\n\n\n\n","category":"function"},{"location":"groups/orthogonal_group/#LieGroups.log_safe!","page":"Orthogonal group","title":"LieGroups.log_safe!","text":"log_safe!(y, x)\n\nCompute the matrix logarithm of x. If the eltype of y is real, then the imaginary part of x is ignored, and a DomainError is raised if real(x) has no real logarithm.\n\n\n\n\n\n","category":"function"},{"location":"groups/orthogonal_group/#LieGroups.usinc_from_cos","page":"Orthogonal group","title":"LieGroups.usinc_from_cos","text":"usinc_from_cos(x::Real)\n\nUnnormalized version of sinc function, i.e. mathrmusinc(θ) = fracsin(θ)θ, computed from x = cos(θ).\n\n\n\n\n\n","category":"function"},{"location":"groups/special_unitary_group/#The-special-unitary-group","page":"Special unitary group","title":"The special unitary group","text":"","category":"section"},{"location":"groups/special_unitary_group/#LieGroups.SpecialUnitaryGroup","page":"Special unitary group","title":"LieGroups.SpecialUnitaryGroup","text":"SpecialUnitaryGroup{T}\n\nThe special orthogonal group mathrmSU(n) is the Lie group consisting of the MatrixMultiplicationGroupOperation on the manifold of rotations GeneralUnitaryMatrices with determinant one.\n\nConstructor\n\nSpecialUnitaryGroup(n::Int; kwargs...)\n\nGenerate special unitary group mathrmSU(n). All keyword arguments in kwargs... are passed on to Rotations as well.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_unitary_group/","page":"Special unitary group","title":"Special unitary group","text":"For this Lie group, several implementations are already covered by the defaults in the generic (matrix) multiplication operation.","category":"page"},{"location":"#LieGroups.jl","page":"Home","title":"LieGroups.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the Documentation of LieGroups.jl.","category":"page"},{"location":"#LieGroups.LieGroups","page":"Home","title":"LieGroups.LieGroups","text":"LieGroups.jl: Lie groups and Lie algebras in Julia.\n\nThe package is named after the Norwegian mathematician Marius Sophus Lie (1842–1899).\n\n📚 Documentation: juliamanifolds.github.io/LieGroups.jl/\n📦 Repository: github.com/JuliaManifolds/LieGroups.jl\n💬 Discussions: github.com/JuliaManifolds/LieGroups.jl/discussions\n🎯 Issues: github.com/JuliaManifolds/LieGroups.jl/issues\n\n\n\n\n\n","category":"module"},{"location":"","page":"Home","title":"Home","text":"The implemented Lie groups use the interface for manifolds in ManifoldsBase.jl together with an interface for Lie groups and Lie algebras as well as internally using the manifolds implemented in Manifolds.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more general information about the history of and contributions to the package see the About page.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package just type","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(\"LieGroups\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then you can directly start, for example consider the SpecialEuclideanGroup mathrmSE(3) representing all orientations and places an object can take in ℝ^3. These are characterised by a 33 rotation matrix together with a point the object is at. For example. having such a point, we can use the Lie group logarithmic function log(G::SpecialEuclideanGroup, g) and the Lie group exponential function exp(G::SpecialEuclideanGroup, X) to create an orientation “half the way” from the origin pose.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The default representation is in homogeneous coordinates","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LieGroups\nSE3 = SpecialEuclideanGroup(3)\ng = 1/sqrt(2) .* [1.0 -1.0 0.0 0.0; 1.0 1.0 0.0 3.0*sqrt(2); 0.0 0.0 sqrt(2) 0.0; 0.0 0.0 0.0 sqrt(2)]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then half that pose is","category":"page"},{"location":"","page":"Home","title":"Home","text":"h = exp(SE3, 0.5 .* log(SE3, g))","category":"page"},{"location":"","page":"Home","title":"Home","text":"To check, just “perform that movement” twice with the group operation compose of h with itself to get g back","category":"page"},{"location":"","page":"Home","title":"Home","text":"compose(SE3, h, h)","category":"page"},{"location":"","page":"Home","title":"Home","text":"for more details see the get started tutorial.","category":"page"},{"location":"groups/translation_group/#The-Lie-group-of-translations-on-a-Euclidean-space","page":"Translation group","title":"The Lie group of translations on a Euclidean space","text":"","category":"section"},{"location":"groups/translation_group/#LieGroups.TranslationGroup","page":"Translation group","title":"LieGroups.TranslationGroup","text":"TranslationGroup{𝔽,T}\n\nThe translation group mathcal T(n) is Lie group consisting of the AdditionGroupOperation on some Euclidean space.\n\nConstructor\n\nTranslationGroup(n₁,...,nᵢ; kwargs...)\n\nGenerate the translation group on 𝔽^n₁nᵢ = Euclidean(n₁,...,nᵢ; field=𝔽), which is isomorphic to the group itself. All keyword arguments in kwargs... are passed on to Euclidean as well\n\nWe denote the Lie algebra of mathcal T(n) by mathfrak t(n).\n\n\n\n\n\n","category":"type"},{"location":"groups/translation_group/","page":"Translation group","title":"Translation group","text":"For this Lie group, all implementations are already covered by the defaults in the generic addition operation.","category":"page"},{"location":"notation/#Notation-on-Lie-groups","page":"Notation","title":"Notation on Lie groups","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"In this package,the notation introduced in Manifolds.jl Notation is used with the following additional parts.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Symbol Description Also used Comment\nα a general group action, when it is not specified whether it is a left (α=σ) or right (α=τ) action.  \n a group operation  \nc_gmathcal G  mathcal G the conjugation map (with g)  \nDf(p)X the differential of a map f at point p in direction X  \nmathrmdf the differential of a map f as a function on the Lie group and the differential on the Lie algebra.  see also note below\nmathrmD_af the differential of a map f. An index is used to indicate a certain parameter. If f is defined on or maps into the Lie group, this differential indicates the one with respect to tangent spaces  see also note below\nmathrme identity element of a group  \nexp_mathcal G(X) The Lie group exponential function  \nexp_g(X) The Lie group exponential map (w.r.t. a Cartan Schouten connection)  \ng h k elements on a (Lie) group. Sometimes called points. g_1 g_2  \nmathfrak g a Lie algebra  \nmathcalG a Lie group  \noperatornameJ_f(p) the Jacobian of a map f at point p  sometimes left Jacobian, see note below.\nλ_g mathcal G  mathcal G the left group operation map λ_g(h) = gh  \nlog_mathcal G(g) The Lie group logarithmic function  \nlog_g(h) The Lie group logarithmic map (w.r.t. a Cartan Schouten connection)  \nα mathcal M  mathcal G  mathcal M a (general) group action  \nρ_g mathcal G  mathcal G the right group operation map ρ_g(h) = hg  \nσ mathcal G  mathcal M  mathcal M a left group action  σ_g(p) to emphasize a fixed group element\nτ mathcal G  mathcal M  mathcal M a right group action σ_mathrmR τ_g(p) to emphasize a fixed group element","category":"page"},{"location":"notation/#About-differentials-and-Jacobians","page":"Notation","title":"About differentials and Jacobians","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"For a function defined on a manifold fmathcal M  mathcal N, the differential at a point p  mathcal M is a map between the tangent spaces","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Df(p)  T_pmathcal M  T_f(p)mathcal N","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"This is the default in  Manifolds.jl.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"For the case where mathcal M = mathcal N = mathcal G is an AbstractLieGroup, the differential can be expressed in terms of the Lie algebra mathfrak g as","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"mathrmdf(g)  mathfrak g  mathfrak g","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"An alternate way to define this differential on the Lie algebra is to consider the (usual) differential Dg(p) of g(q) = f(qp)f(p)^-1.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"where we use a different notation on purpose. This second notation is the default throughout LieGroups.jl.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"The Jacobian operatornameJ_f(p) of f at p is the matrix representation of the differential with respect to a basis of each of the tangent spaces. For the default representation mathrmdf(g) we have to choose a basis of the Lie algebra mathfrak g. Throughout LieGroups.jl this is the DefaultLieAlgebraOrthogonalBasis.","category":"page"},{"location":"notation/#About-left-and-right-Jacobians","page":"Notation","title":"About left and right Jacobians","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"This jacobian using mathrmdf(g) and the DefaultLieAlgebraOrthogonalBasis is sometimes called the left Jacobian. The other choice using on two tangent space bases of T_pmathcal G and T_f(p)mathcal G, respectively, is sometimes called the right Jacobian. The default throughout LieGroups.jl is the left Jacobian.","category":"page"}]
}
