var documenterSearchIndex = {"docs":
[{"location":"tutorials/transition/#Transition-from-GroupManifolds-in-Manifolds.jl","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds in Manifolds.jl","text":"","category":"section"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"One predecessor of LieGroups.jl are the GroupManifolds in Manifolds.jl. While this package provides the same features, one reason for a new package is, that a ‚Äúrestart‚Äù offers the opportunity to put the main focus for the functions in this package really on Lie groups.","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"This tutorial provides an overview of the necessary changes to your code if you based it on the predecessor.","category":"page"},{"location":"tutorials/transition/#Table-of-function-names-and-its-successors","page":"Transition from GroupManifolds","title":"Table of function names and its successors","text":"","category":"section"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"The following table lists all functions related to GroupManifolds and their new names or replacements here in LieGroups.jl. In this code G always refers to the GroupManifold in the first column and the LieGroup in the second. Lie group elements (points) are always g,h, Lie algebra elements (vectors) always X, Y.","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"New functions and types in this package are only mentioned, if they are worth a comment and if something changed.","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"The list is alphabetical, but first lists types, then functions","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"Manifolds.jl LieGroups.jl Comment\nAdditionOperation AdditionGroupOperation \nLeftForwardAction LeftGroupOperationAction \nLeftBackwardAction InverseRightGroupOperationAction note that this is now also aa AbstractLeftGroupActionType\n LieAlgebra(G) new alias to emphasize its manifold- and vector structure as well as for a few dispatch methods.\nGroupManifold(M, op) LieGroup(M, op) \nPowerGroup(M) PowerLieGroup(G,n) The main change is, that the constructor now requires a Lie group to build the power Lie group; This also allows for G^n. The other two former constructors for nested and nested-replacing are no longer necessary. PowerLieGroup behaves exactly the same as PowerManifold.\nProductGroup(M) ProductLieGroup(G, H) The main change is, that the constructor now requires two Lie groups to build their product. This also allows for the short hand G√óH to generate this product.\nSemidirectProductGroup(G, H, a) LeftSemidirectProductLieGroup(G, H, a) While this staid the same, there is now also the default_left_action(G,H). When this agrees with a you can use the short hand G‚ãâH to generate this semidirect product. Analogously there now also exists the RightSemidirectProductLieGroup(G,H) withdefault_left_action(G,H) that allows for the short cut G‚ãäH\nRightBackwardAction RightGroupOperationAction \nRightForwardAction InverseLeftGroupOperationAction note that this is an AbstractRightGroupActionType\nadjoint adjoint now implemented with a default, when you provide diff_conjugate!.\napply_diff diff_apply modifiers (diff) come first, consistent with ManifoldsDiff.jl\napply_diff_group diff_group_apply modifiers (diff/group) come first, consistent with ManifoldsDiff.jl\n conjugate, diff_conjugate a new function to model c_g mathcal G  mathcal G given by c_g(h) = ghg^-1\ndifferential_exp_argument_lie_approx - Scheduled for update and renaming. Though available in ManifoldDiff.jl for GroupManifolds, that will move to differential_exp_argument_approx instead, since exp_lie changed to now just exp.\nexp(G, g, X) exp(base_manifold(G), g, X) the previous defaults whenever not agreeing with the Riemannian one can now be accessed on the internal manifold\nexp_inv(G, g, X) exp(G, g, X) the exponential map invariant to the group operation is the default on Lie groups here\nexp_lie(G, X) exp(G, X) the (matrix/Lie group) exponential\ninverse_translate(G, g, h, c) inv_left_compose(G, g, h), inv_right_compose(G, g, h) compute g^-1h and gh^-1, resp.\ninverse_translate_diff(G, g, h, X, LeftForwardAction()) - discontinued, use diff_left_compose(G, inv(G,g), h)\ninverse_translate_diff(G, g, h, X, RightBackwardAction()) - discontinued, use diff_left_compose(G, h, inv(G,g))\nlog(G, g, h) log(base_manifold(G), g, h) you can now access the previous defaults on the internal manifold whenever they do not agree with the invariant one\nlog_inv(G, g, h) log(G, g, h) the logarithmic map invariant to the group operation is the default on Lie groups here\nlog_lie(G, g) log(G, g) the (matrix/Lie group) logarithm\nswitch_direction(A) inv(A) switches from an action to its inverse action (formerly the direction forward/backward, sometimes even left/right, do not confuse with the side left/right).\nswitch_side(A) switch(A) switches from a left action to its corresponding right action.\ntranslate(G, g, h) compose(G, g, h) unified to compose\ntranslate_diff(G, g, X, c) diff_left_compose(G, g, h, X), diff_right_compose(G, g, h, X) for compose gh the functions now specify whether the derivative is taken w.r.t. to the left (g) or right (h) argument\nVeeOrthogonalBasis DefaultLieAlgebraOrthogonalBasis ","category":"page"},{"location":"tutorials/transition/#Further-notable-changes","page":"Transition from GroupManifolds","title":"Further notable changes","text":"","category":"section"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"In general the default for tangent vectors is now to represent them in the LieAlgebra, which obtains its own name now, though defined as a constant of a certain tangent space.\nIn accordance with point 1., the GeneralLinearGroup (formerly GeneralLinear) switched to using its Lie algebra to represent tangent vectors.\nFormerly, both a power manifold of Lie groups as a manifold as well as a Lie group of a power manifold as a Lie group were possible. This is unified to just defining G^n as the Lie group on the power manifold with the element-wise group operation.\nFormerly, product manifolds were stored as a ProductManifold of Lie groups and an indicator for the group operation, that the direct product should be used. This is switched to internally only store a ProductManifold as well as a (new) ProductGroupOperation that specifies one group operation for every factor.\nThe last two points achieve one unified modelling aspect of Lie groups: they are now always a manifold M together with a group operation op, but a Lie group does not store another Lie group (or product of them) internally with one common type they share, a LieGroup.","category":"page"},{"location":"references/#Literature","page":"References","title":"Literature","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"This is all literature mentioned / referenced in the LieGroups.jl documentation. You can find a small reference section at the end of every documentation page that contains the corresponding references as well.","category":"page"},{"location":"references/","page":"References","title":"References","text":"D.¬†Andrica and R.-A.¬†Rohan. Computing the Rodrigues coefficients of the exponential map of the Lie groups of matrices. Balkan¬†Journal¬†of¬†Geometry¬†and¬†Its¬†Applications 18, 1‚Äì10 (2013).\n\n\n\nE.¬†Biny and S.¬†Pods. The Geometry of Heisenberg Groups: With Applications in Signal Theory, Optics, Quantization, and Field Quantization (American Mathematical Society, 2008).\n\n\n\nJ.¬†Gallier and D.¬†Xu. Computing exponentials of skew-symmetric matrices and logarithms of orthogonal matrices. International¬†Journal¬†of¬†Robotics¬†and¬†Automation 17, 1‚Äì11 (2002).\n\n\n\nM.¬†B.¬†Giles. Collected Matrix Derivative Results for Forward and Reverse Mode Algorithmic Differentiation. In: Advances in Automatic Differentiation, Lecture Notes in Computational Science and Engineering, edited by C.¬†H.¬†Bischof, H.¬†M.¬†B√ºcker, P.¬†Hovland, U.¬†Naumann and J.¬†Utke (Springer, Berlin, Heidelberg, 2008); pp.¬†35‚Äì44.\n\n\n\nJ.¬†Hilgert and K.-H.¬†Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\nJ.¬†Sol√†, J.¬†Deray and D.¬†Atchuthan. A micro Lie theory for state estimation in robotics (Dec 2021), arXiv:1812.01537 [cs.RO], arXiv: 1812.01537.\n\n\n\n","category":"page"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"EditURL = \"https://github.com/JuliaManifolds/LieGroups.jl/blob/main/CONTRIBUTING.md\"","category":"page"},{"location":"contributing/#Contributing-to-LieGroups.jl","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"First, thanks for taking the time to contribute. We appreciate and welcome any contribution.","category":"page"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"The following is a set of guidelines to LieGroups.jl.","category":"page"},{"location":"contributing/#Table-of-contents","page":"Contributing to LieGroups.jl","title":"Table of contents","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Contributing to LieGroups.jl     - Table of Contents\nHow to just ask a question\nHow to file an issue\nHow to contribute\nCode style","category":"page"},{"location":"contributing/#How-to-just-ask-a-question","page":"Contributing to LieGroups.jl","title":"How to just ask a question","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"You can most easily reach the developers in the Julia Slack channel #manifolds. You can apply for the Julia Slack workspace here if you haven't joined yet. You can also ask your question on discourse.julialang.org.","category":"page"},{"location":"contributing/#How-to-file-an-issue","page":"Contributing to LieGroups.jl","title":"How to file an issue","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"If you found a bug or want to propose a feature, please open an issue in within the GitHub repository.","category":"page"},{"location":"contributing/#How-to-contribute","page":"Contributing to LieGroups.jl","title":"How to contribute","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Currently most details are still work-in-progress. Feel free to contribute ideas, features you would like to see, Lie groups you want to have or would like to contribute, or any other idea for LieGroups.jl. For these, use either the discussions or issues in the GitHub repository","category":"page"},{"location":"contributing/#Code-style","page":"Contributing to LieGroups.jl","title":"Code style","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Please follow the documentation guidelines from the Julia documentation as well as Blue Style. Run JuliaFormatter.jl on the repository running using JuliaFormatter; format(\".\") on the main folder of the project.","category":"page"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Please follow a few internal conventions:","category":"page"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Include the mathematical formulae for any implemented function if a closed form exists.\nDefine a Lie group, a Lie group action, or a Lie algebra in its own file. Include all related functions in the same file\nan alphabetical order of functions in every file is preferable.\nThe preceding implies that the mutating variant of a function follows the non-mutating variant.\nDocument both the allocating and the mutating variants of a function. To avoid duplication, attach one doc string defined before both functions and attach it to both.\nThere should be no dangling = signs.\nAdd a newline between things of different types (struct/method/const).\nAdd a newline between methods for different functions (including allocating/mutating variants).\nPrefer to have no newline between methods for the same function; when reasonable, merge the documentation strings.\nAll import/using/include should be in the main module file.\nAvoid using import and use the explicit full name, like Base.exp, when implementing functions, that extend functions of other packages.\nif possible provide both mathematical formulae and literature references using DocumenterCitations.jl and BibTeX where possible\nAlways document all input variables and keyword arguments","category":"page"},{"location":"groups/special_euclidean_group/#The-special-Euclidean-group","page":"Special Euclidean group","title":"The special Euclidean group","text":"","category":"section"},{"location":"groups/special_euclidean_group/","page":"Special Euclidean group","title":"Special Euclidean group","text":"SpecialEuclideanGroup","category":"page"},{"location":"groups/special_euclidean_group/#LieGroups.SpecialEuclideanGroup","page":"Special Euclidean group","title":"LieGroups.SpecialEuclideanGroup","text":"SpecialEuclideanGroup{T}\n\nThe special Euclidean group mathrmSE(n) = mathrmSO(n)  mathcal T(n) is the Lie group consisting of the LeftSemidirectProductGroupOperation of the SpecialOrthogonalGroup and the TranslationGroup together with the GroupOperationAction{LeftGroupOperationAction}.\n\nTo be precise, the group operation is defined on mathrmSO(n)  mathcal T(n) as follows:\n\n(r_1 t_1)  (r_2 t_2) = (r_1r_2 t_1 + r_1t_2)\n\nwhere r_1r_2  mathrmSO(n) and t_1t_2  mathcal T(n)\n\nAnalogously you can write this on elements of mathrmSO(n)  mathcal T(n) as\n\n(t_1 r_1)  (t_2 r_2) = (t_1 + r_1s_2 r_1r_2)\n\nBoth these cases can be represented in a single matrix in affine form\n\ng = beginpmatrix r  t mathbf0_n^mathrmT  1endpmatrix\nqquad r  mathrmSO(n) t  mathcal T(n)\n\nwhere mathbf0_n  ‚Ñù^n denotes the vector containing zeros.\n\nWe refer also in general to elements on mathrmSE(n) as g and their rotation and translation components as r and t, respectively.\n\nConstructor\n\nSpecialEuclideanGroup(n::Int; variant=:left, kwargs...)\nSpecialOrthogonalGroup(n; kwargs...) ‚ãâ TranslationGroup(n; kwargs...)\nTranslationGroup(n; kwargs...) ‚ãä SpecialOrthogonalGroup(n; kwargs...)\n\nGenerate special Euclidean group mathrmSE(n) = mathrmSO(n)  mathcal T(n), where the first constructor is equivalent to the second.\n\nAll keyword arguments in kwargs... are passed on to Rotations as well.\n\nThe default representation for mathrmSE(n) is the affine form. Alternatively you can use the ArrayPartition from RecursiveArrayTools.jl to work on (rt). or for mathcal T(n)  mathrmSO(n) using the ArrayPartitions (tr); which corresponds to setting variant=:right in the first constructor.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_euclidean_group/#Representation-of-points-and-tangent-vectors","page":"Special Euclidean group","title":"Representation of points and tangent vectors","text":"","category":"section"},{"location":"groups/special_euclidean_group/","page":"Special Euclidean group","title":"Special Euclidean group","text":"SpecialEuclideanMatrixPoint\nSpecialEuclideanMatrixTangentVector\nSpecialEuclideanProductPoint\nSpecialEuclideanProductTangentVector","category":"page"},{"location":"groups/special_euclidean_group/#LieGroups.SpecialEuclideanMatrixPoint","page":"Special Euclidean group","title":"LieGroups.SpecialEuclideanMatrixPoint","text":"SpecialEuclideanMatrixPoint <: AbstractLieGroupPoint\n\nrepresent a point on some LieGroup by an affine matrix.\n\nbeginpmatrix M  v mathbf0_n^mathrmT  1endpmatrix  ‚Ñù^(n+1)(n+1)\nqquad M  ‚Ñù^nn v  mathcal T(n)\n\nwhere mathbf0_n  ‚Ñù^n denotes the vector containing zeros.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_euclidean_group/#LieGroups.SpecialEuclideanMatrixTangentVector","page":"Special Euclidean group","title":"LieGroups.SpecialEuclideanMatrixTangentVector","text":"SpecialEuclideanMatrixTangentVector <: AbstractLieAlgebraTangentVector\n\nrepresent a tangent vector on some LieGroup by a matrix of the form\n\nbeginpmatrix M  v mathbf0_n^mathrmT  0endpmatrix  ‚Ñù^(n+1)(n+1)\nqquad M  ‚Ñù^nn v  mathcal T(n)\n\nwhere mathbf0_n  ‚Ñù^n denotes the vector containing zeros.\n\nWhile this tangent vector itself is not an affine matrix itself, it can be used for the Lie algebra of the affine group\n\n\n\n\n\n","category":"type"},{"location":"groups/special_euclidean_group/#LieGroups.SpecialEuclideanProductPoint","page":"Special Euclidean group","title":"LieGroups.SpecialEuclideanProductPoint","text":"SpecialEuclideanProductPoint <: AbstractLieGroupPoint\n\nRepresent a point on a Lie group (explicitly) as a point that consists of components\n\n\n\n\n\n","category":"type"},{"location":"groups/special_euclidean_group/#LieGroups.SpecialEuclideanProductTangentVector","page":"Special Euclidean group","title":"LieGroups.SpecialEuclideanProductTangentVector","text":"SpecialEuclideanProductTangentVector <: AbstractLieAlgebraTangentVector\n\nRepresent a point on a Lie algebra (explicitly) as a tangent vector that consists of components.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_euclidean_group/#Specific-functions","page":"Special Euclidean group","title":"Specific functions","text":"","category":"section"},{"location":"groups/special_euclidean_group/","page":"Special Euclidean group","title":"Special Euclidean group","text":"Modules = [LieGroups]\nPages = [\"groups/special_euclidean_group.jl\"]\nOrder = [:function]","category":"page"},{"location":"groups/special_euclidean_group/#Base.exp-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{2}}, ‚Ñù}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}, Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{2}}, ‚Ñù}}}}}, Any}","page":"Special Euclidean group","title":"Base.exp","text":"exp(G::SpecialEuclidean, X)\nexp!(G::SpecialEuclidean, g, X)\n\nCompute the Lie group exponential function on the SpecialEuclideanGroup G=mathrmSE(2) using a TypeParameter{Tuple{2}} for dispatch.\n\nThe Lie algebra vector X = (Y v)  mathfrak se(2) consists of a rotation component Y  mathfrak so(2) and a translation component v  mathfrak t(2), so we can use vee on mathrmSO(2) to obtain the angle of rotation Œ± (or alternatively using sqrt2Œ± = lVert Y rVert_)\n\nFor Œ±  0 define\n\nU_Œ± = fracsinŒ±Œ±I_2 + frac1-cosŒ±Œ±^2Y\n\nand U_0 = I_2, where I_2 is the identity matrix.\n\nThen the result g=(Rt) is given by\n\nR = exp_mathrmSO(2)Y  mathrmSO(2)\nquad\ntext and \nquad\nt = U_Œ±v  mathcal T(2)\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.exp-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ‚Ñù}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ‚Ñù}}}}}, Any}","page":"Special Euclidean group","title":"Base.exp","text":"exp(G::SpecialEuclidean, X)\nexp!(G::SpecialEuclidean, g, X)\n\nCompute the Lie group exponential function on the SpecialEuclideanGroup G=mathrmSE(3) using a TypeParameter{Tuple{3}} for dispatch.\n\nSince X = (Y v)  mathfrak se(3) consists of a rotation component Y  mathfrak se(3) and a translation component v  mathfrak t(3), we can use vee on mathrmSO(3) computing the coefficients norm to obtain the angle of rotation Œ± (or alternatively using sqrt2Œ± = lVert Y rVert_).\n\nFor Œ±  0 define\n\nU_Œ± = I_3 + frac1-cosŒ±Œ±^2Y + fracŒ±-sinŒ±Œ±^3Y^2\n\nand U_0 = I_3, where I_2 is the identity matrix.\n\nThen the result g=(Rt) is given by\n\nR = exp_mathrmSO(3)Y  mathrmSO(3)\nquad\ntext and \nquad\nt = U_Œ±v  mathcal T(3)\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.getindex-Tuple{Union{Identity, SpecialEuclideanMatrixPoint, SpecialEuclideanProductPoint}, Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{T, ‚Ñù}, Manifolds.Rotations{T}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{T}, Manifolds.Euclidean{T, ‚Ñù}}}}} where T, Union{Int64, Symbol}}","page":"Special Euclidean group","title":"Base.getindex","text":"g[G::SpecialEuclideanGroup,s]\ngetindex(g, G::SpecialEuclideanGroup, s)\nX[ùî§,s]\ngetindex(g, ùî§, s)\n\nAccess sub-parts of a SpecialEuclideanGroup G or its Lie algebra ùî§. where s can be an index :Rotation, :Translation to access the single parts. Use : to access all submanifold components as a unified tuple.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.getindex-Tuple{Union{SpecialEuclideanMatrixTangentVector, SpecialEuclideanProductTangentVector}, ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, <:SpecialEuclideanGroup{T} where T, Identity{var\"#s126\"}} where var\"#s126\"<:(Union{var\"#s20\", var\"#s19\"} where {var\"#s20\"<:(LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}), var\"#s19\"<:(RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction})}), Colon}","page":"Special Euclidean group","title":"Base.getindex","text":"g[G::SpecialEuclideanGroup,s]\ngetindex(g, G::SpecialEuclideanGroup, s)\nX[ùî§,s]\ngetindex(g, ùî§, s)\n\nAccess sub-parts of a SpecialEuclideanGroup G or its Lie algebra ùî§. where s can be an index :Rotation, :Translation to access the single parts. Use : to access all submanifold components as a unified tuple.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.getindex-Tuple{Union{SpecialEuclideanMatrixTangentVector, SpecialEuclideanProductTangentVector}, ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, <:SpecialEuclideanGroup{T} where T, Identity{var\"#s126\"}} where var\"#s126\"<:(Union{var\"#s20\", var\"#s19\"} where {var\"#s20\"<:(LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}), var\"#s19\"<:(RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction})}), Union{Int64, Symbol}}","page":"Special Euclidean group","title":"Base.getindex","text":"g[G::SpecialEuclideanGroup,s]\ngetindex(g, G::SpecialEuclideanGroup, s)\nX[ùî§,s]\ngetindex(g, ùî§, s)\n\nAccess sub-parts of a SpecialEuclideanGroup G or its Lie algebra ùî§. where s can be an index :Rotation, :Translation to access the single parts. Use : to access all submanifold components as a unified tuple.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.inv-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{T, ‚Ñù}, Manifolds.Rotations{T}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{T}, Manifolds.Euclidean{T, ‚Ñù}}}}} where T, Any}","page":"Special Euclidean group","title":"Base.inv","text":"inv(G::SpecialEuclideanGroup, g)\ninv(G::SpecialEuclideanGroup, h, g)\n\nCompute the inverse element of a g  mathrmSE(n) from the SpecialEuclideanGroup(n).\n\nIn affine form, g = beginpmatrix r  t mathbf0_n^mathrmT  1endpmatrix, where mathbf0_n  ‚Ñù^n denotes the vector containing zeros.\n\nThe inverse reads\n\ng^-1 = beginpmatrix r^mathrmT  -r^mathrmTt mathbf0_n^mathrmT  1endpmatrix\n\nThis computation can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.log-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{2}}, ‚Ñù}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}, Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{2}}, ‚Ñù}}}}}, Any}","page":"Special Euclidean group","title":"Base.log","text":"log(G::SpecialEuclidean, g)\nlog!(G::SpecialEuclidean, X, g)\n\nCompute the Lie group logarithm function on the SpecialEuclideanGroup G=mathrmSE(2), and G uses a TypeParameter{Tuple{2}} for dispatch.\n\nSince g=(Rt)  mathrmSE(2) consists of a rotation component R  mathrmSO(2) and a translation component t  mathcal T(2), we first compute Y = log_mathrmSO(2)R. Then we can use vee on mathrmSO(2) to obtain the angle of rotation Œ± (or alternatively using sqrt2Œ± = lVert Y rVert_)\n\nFor Œ±  0 define\n\nV_Œ± = fracŒ±2 beginpmatrix fracsinŒ±1-cosŒ±  1 -1  fracsinŒ±1-cosŒ±endpmatrix\n\nand V_0 = I_2, where I_2 is the identity matrix. Note that this is the inverse of U_Œ± as given in the group exponential\n\nThen the result X = (Y v)  mathfrak se(2) is given by Y  mathfrak so(2) as computed above and\n\nv = V_Œ±r  mathcal T(2)\n\nwhere v is computed in-place without setting up V_Œ±\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.log-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ‚Ñù}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ‚Ñù}}}}}, Any}","page":"Special Euclidean group","title":"Base.log","text":"log(G::SpecialEuclidean, g)\nlog!(G::SpecialEuclidean, X, g)\n\nCompute the Lie group logarithm function on the SpecialEuclideanGroup G=mathrmSE(3), where e is the Identity on mathrmSE(3) G uses a TypeParameter{Tuple{3}} for dispatch.\n\nSince g=(Rt)  mathrmSE(3) consists of a rotation component R  mathrmSO(3) and a translation component t  mathcal T(2), we first compute Y = log_mathrmSO(3)R. Then we can use vee on mathrmSO(3) to obtain the angle of rotation Œ± (or alternatively using sqrt2Œ± = lVert Y rVert_)\n\nFor Œ±  0 define\n\nV_Œ± = I_3 - frac12Y + Œ≤ Y^2 quadtext where  Œ≤ = frac1Œ±^2 - frac1 + cos(Œ±)2Œ±sin(Œ±)\n\nand V_0 = I_3, where I_3 is the identity matrix. Note that this is the inverse of U_Œ± as given in the group exponential\n\nThen the result X = (Y v)  mathfrak se(3) is given by Y  mathfrak so(3) as computed above and v = V_Œ± t  mathfrak t(3).\n\nThis result can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.default_left_action-Tuple{SpecialOrthogonalGroup, TranslationGroup}","page":"Special Euclidean group","title":"LieGroups.default_left_action","text":"default_left_action(G::SpecialOrthogonalGroup, ::TranslationGroup)\n\nReturn the default left action for the special Euclidean group mathrmSO(n)  mathcal T(n), that is the GroupOperationAction(LeftGroupOperationAction(G.op)).\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.default_right_action-Tuple{TranslationGroup, SpecialOrthogonalGroup}","page":"Special Euclidean group","title":"LieGroups.default_right_action","text":"default_right_action(::TranslationGroup, G::SpecialOrthogonalGroup)\n\nReturn the default right action for the special Euclidean group, that is the GroupOperationAction(LeftGroupOperationAction(G.op)).\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.init_constants!-Tuple{ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, <:SpecialEuclideanGroup{T} where T, Identity{var\"#s126\"}} where var\"#s126\"<:(Union{var\"#s20\", var\"#s19\"} where {var\"#s20\"<:(LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}), var\"#s19\"<:(RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction})}), AbstractMatrix}","page":"Special Euclidean group","title":"LieGroups.init_constants!","text":"init_constants!(G::SpecialEuclidean, g)\ninit_Constants!(ùî∞ùî¢::LieAlgebra{‚Ñù, SpecialEuclideanGroupOperation, SpecialEuclidean}, X)\n\nInitialize the constant elements of g or X.\n\nThe matrix representation of gmathrmSE(n) has a last row, that contains zeros, besides the diagonal element, which is g_n+1n+1 = 1.\n\nThe matrix representation of Xmathfrak se(n) has a last row that contains zeros.\n\nthis function sets these entries accordingly.\n\nPer default for other representations, this function does not change entries for them.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.init_constants!-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{T, ‚Ñù}, Manifolds.Rotations{T}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{T}, Manifolds.Euclidean{T, ‚Ñù}}}}} where T, AbstractMatrix}","page":"Special Euclidean group","title":"LieGroups.init_constants!","text":"init_constants!(G::SpecialEuclidean, g)\ninit_Constants!(ùî∞ùî¢::LieAlgebra{‚Ñù, SpecialEuclideanGroupOperation, SpecialEuclidean}, X)\n\nInitialize the constant elements of g or X.\n\nThe matrix representation of gmathrmSE(n) has a last row, that contains zeros, besides the diagonal element, which is g_n+1n+1 = 1.\n\nThe matrix representation of Xmathfrak se(n) has a last row that contains zeros.\n\nthis function sets these entries accordingly.\n\nPer default for other representations, this function does not change entries for them.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.inv!-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{T, ‚Ñù}, Manifolds.Rotations{T}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{T}, Manifolds.Euclidean{T, ‚Ñù}}}}} where T, AbstractMatrix, AbstractMatrix}","page":"Special Euclidean group","title":"LieGroups.inv!","text":"inv(G::SpecialEuclideanGroup, g)\ninv(G::SpecialEuclideanGroup, h, g)\n\nCompute the inverse element of a g  mathrmSE(n) from the SpecialEuclideanGroup(n).\n\nIn affine form, g = beginpmatrix r  t mathbf0_n^mathrmT  1endpmatrix, where mathbf0_n  ‚Ñù^n denotes the vector containing zeros.\n\nThe inverse reads\n\ng^-1 = beginpmatrix r^mathrmT  -r^mathrmTt mathbf0_n^mathrmT  1endpmatrix\n\nThis computation can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#ManifoldsBase.exp!-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ‚Ñù}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ‚Ñù}}}}}, AbstractMatrix, AbstractMatrix}","page":"Special Euclidean group","title":"ManifoldsBase.exp!","text":"exp(G::SpecialEuclidean, X)\nexp!(G::SpecialEuclidean, g, X)\n\nCompute the Lie group exponential function on the SpecialEuclideanGroup G=mathrmSE(3) using a TypeParameter{Tuple{3}} for dispatch.\n\nSince X = (Y v)  mathfrak se(3) consists of a rotation component Y  mathfrak se(3) and a translation component v  mathfrak t(3), we can use vee on mathrmSO(3) computing the coefficients norm to obtain the angle of rotation Œ± (or alternatively using sqrt2Œ± = lVert Y rVert_).\n\nFor Œ±  0 define\n\nU_Œ± = I_3 + frac1-cosŒ±Œ±^2Y + fracŒ±-sinŒ±Œ±^3Y^2\n\nand U_0 = I_3, where I_2 is the identity matrix.\n\nThen the result g=(Rt) is given by\n\nR = exp_mathrmSO(3)Y  mathrmSO(3)\nquad\ntext and \nquad\nt = U_Œ±v  mathcal T(3)\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#ManifoldsBase.exp!-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{var\"#s127\", ‚Ñù}, Manifolds.Rotations{var\"#s127\"}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{var\"#s127\"}, Manifolds.Euclidean{var\"#s127\", ‚Ñù}}}}} where var\"#s127\"<:ManifoldsBase.TypeParameter{Tuple{2}}, AbstractMatrix, AbstractMatrix}","page":"Special Euclidean group","title":"ManifoldsBase.exp!","text":"exp(G::SpecialEuclidean, X)\nexp!(G::SpecialEuclidean, g, X)\n\nCompute the Lie group exponential function on the SpecialEuclideanGroup G=mathrmSE(2) using a TypeParameter{Tuple{2}} for dispatch.\n\nThe Lie algebra vector X = (Y v)  mathfrak se(2) consists of a rotation component Y  mathfrak so(2) and a translation component v  mathfrak t(2), so we can use vee on mathrmSO(2) to obtain the angle of rotation Œ± (or alternatively using sqrt2Œ± = lVert Y rVert_)\n\nFor Œ±  0 define\n\nU_Œ± = fracsinŒ±Œ±I_2 + frac1-cosŒ±Œ±^2Y\n\nand U_0 = I_2, where I_2 is the identity matrix.\n\nThen the result g=(Rt) is given by\n\nR = exp_mathrmSO(2)Y  mathrmSO(2)\nquad\ntext and \nquad\nt = U_Œ±v  mathcal T(2)\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#ManifoldsBase.log!-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{2}}, ‚Ñù}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}, Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{2}}, ‚Ñù}}}}}, AbstractMatrix, AbstractMatrix}","page":"Special Euclidean group","title":"ManifoldsBase.log!","text":"log(G::SpecialEuclidean, g)\nlog!(G::SpecialEuclidean, X, g)\n\nCompute the Lie group logarithm function on the SpecialEuclideanGroup G=mathrmSE(2), and G uses a TypeParameter{Tuple{2}} for dispatch.\n\nSince g=(Rt)  mathrmSE(2) consists of a rotation component R  mathrmSO(2) and a translation component t  mathcal T(2), we first compute Y = log_mathrmSO(2)R. Then we can use vee on mathrmSO(2) to obtain the angle of rotation Œ± (or alternatively using sqrt2Œ± = lVert Y rVert_)\n\nFor Œ±  0 define\n\nV_Œ± = fracŒ±2 beginpmatrix fracsinŒ±1-cosŒ±  1 -1  fracsinŒ±1-cosŒ±endpmatrix\n\nand V_0 = I_2, where I_2 is the identity matrix. Note that this is the inverse of U_Œ± as given in the group exponential\n\nThen the result X = (Y v)  mathfrak se(2) is given by Y  mathfrak so(2) as computed above and\n\nv = V_Œ±r  mathcal T(2)\n\nwhere v is computed in-place without setting up V_Œ±\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#ManifoldsBase.log!-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ‚Ñù}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ‚Ñù}}}}}, AbstractMatrix, AbstractMatrix}","page":"Special Euclidean group","title":"ManifoldsBase.log!","text":"log(G::SpecialEuclidean, g)\nlog!(G::SpecialEuclidean, X, g)\n\nCompute the Lie group logarithm function on the SpecialEuclideanGroup G=mathrmSE(3), where e is the Identity on mathrmSE(3) G uses a TypeParameter{Tuple{3}} for dispatch.\n\nSince g=(Rt)  mathrmSE(3) consists of a rotation component R  mathrmSO(3) and a translation component t  mathcal T(2), we first compute Y = log_mathrmSO(3)R. Then we can use vee on mathrmSO(3) to obtain the angle of rotation Œ± (or alternatively using sqrt2Œ± = lVert Y rVert_)\n\nFor Œ±  0 define\n\nV_Œ± = I_3 - frac12Y + Œ≤ Y^2 quadtext where  Œ≤ = frac1Œ±^2 - frac1 + cos(Œ±)2Œ±sin(Œ±)\n\nand V_0 = I_3, where I_3 is the identity matrix. Note that this is the inverse of U_Œ± as given in the group exponential\n\nThen the result X = (Y v)  mathfrak se(3) is given by Y  mathfrak so(3) as computed above and v = V_Œ± t  mathfrak t(3).\n\nThis result can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/getstarted/#Get-Started-with-LieGroups.jl","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"In this tutorial, we aim to present how to get started with LieGroups.jl.","category":"page"},{"location":"interface/operations/#An-interface-for-Lie-group-operations","page":"Group operation","title":"An interface for Lie group operations","text":"","category":"section"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"AbstractGroupOperation\nIdentity","category":"page"},{"location":"interface/operations/#LieGroups.AbstractGroupOperation","page":"Group operation","title":"LieGroups.AbstractGroupOperation","text":"AbstractGroupOperation\n\nRepresent a type of group operation for a LieGroup mathcal G, that is a smooth binary operation   mathcal G  mathcal G  mathcal G on elements of a Lie group mathcal G.\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#LieGroups.Identity","page":"Group operation","title":"LieGroups.Identity","text":"Identity{O<:AbstractGroupOperation}\n\nRepresent the group identity element e  mathcal G on a LieGroup mathcal G with AbstractGroupOperation of type O.\n\nSimilar to the philosophy that points are agnostic of their group at hand, the identity does not store the group mathcal G it belongs to. However it depends on the type of the AbstractGroupOperation used.\n\nSee also identity_element on how to obtain the corresponding AbstractManifoldPoint or array representation.\n\nConstructors\n\nIdentity(::LieGroup{ùîΩ,O}) where {ùîΩ,O<:AbstractGroupOperation}\nIdentity(o::AbstractGroupOperation)\nIdentity(::Type{AbstractGroupOperation})\n\ncreate the identity of the corresponding subtype O<:AbstractGroupOperation\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"You can combine some specific group operations with one of several manifolds to form a Lie group. You can still define the corresponding functions generically for all groups with this group operation regardless of the manifold. The following sections collect these.","category":"page"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"an AdditionGroupOperation","category":"page"},{"location":"interface/operations/#addition-operation-sec","page":"Group operation","title":"Additive group operation","text":"","category":"section"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"Modules = [LieGroups]\nPages = [\"addition_operation.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"interface/operations/#LieGroups.AdditionGroupOperation","page":"Group operation","title":"LieGroups.AdditionGroupOperation","text":"AdditionGroupOperation <: AbstractGroupOperation\n\nA group operation that is realised introducing defaults that fall back to + and - being overloaded, for example _compose(G::LieGroup{ùîΩ,AdditionGroupOperation}, a, b) = a + b\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#Base.exp-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any}} where ùîΩ","page":"Group operation","title":"Base.exp","text":"exp(G::LieGroup{ùîΩ,AdditionGroupOperation}, X)\nexp!(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, X)\n\nCompute the Lie group exponential on a LieGroup with an AdditionGroupOperation. This can be computed in-place of g.\n\nSince e is just the zero-element with respect to the corresponding +, the formula reads g=0+X=X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.inv-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any}} where ùîΩ","page":"Group operation","title":"Base.inv","text":"inv(G::LieGroup{ùîΩ,AdditionGroupOperation}, g)\ninv!(G::LieGroup{ùîΩ,AdditionGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for the AdditionGroupOperation simplifies to -g. This can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.log-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any}} where ùîΩ","page":"Group operation","title":"Base.log","text":"log(G::LieGroup{ùîΩ,AdditionGroupOperation}, g)\nlog!(G::LieGroup{ùîΩ,AdditionGroupOperation}, X, g)\n\nCompute the Lie group logarithm on a LieGroup with an AdditionGroupOperation. This can be computed in-place of X.\n\nSince e is just the zero-element with respect to the corresponding +, the formula reads X=g-0=g.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.compose!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.compose!","text":"compose(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, h)\ncompose!(G::LieGroup{ùîΩ,AdditionGroupOperation}, k, g, h)\n\nCompute the group operation composition of g and h with respect to the AdditionGroupOperation on G, which falls back to calling g+h, where + is assumed to be overloaded accordingly.\n\nThis can be computed in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Vararg{Any, 4}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_conjugate!","text":"diff_conjugate(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjutage c_g(h) = ghg^-1 = g+h-g = h, which simplifies for AdditionGroupOperation to D(c_g(h))X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_conjugate","text":"diff_conjugate(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjutage c_g(h) = ghg^-1 = g+h-g = h, which simplifies for AdditionGroupOperation to D(c_g(h))X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_inv!","text":"diff_inv(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, g, X)\n\nCompute the differential of the inverse operation Œπ_mathcal G(g) = g^-1 = -g, which simplifies for AdditionGroupOperation to DŒπ_mathcal G(g)X = -X\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_inv","text":"diff_inv(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, g, X)\n\nCompute the differential of the inverse operation Œπ_mathcal G(g) = g^-1 = -g, which simplifies for AdditionGroupOperation to DŒπ_mathcal G(g)X = -X\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Vararg{Any, 4}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_left_compose!","text":"diff_left_compose(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh, which simplifies for AdditionGroupOperation to DŒª_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_left_compose","text":"diff_left_compose(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh, which simplifies for AdditionGroupOperation to DŒª_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Vararg{Any, 4}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_right_compose!","text":"diff_right_compose(G::LieGroup{ùîΩ,AdditionGroupOperation}, h, g, X)\ndiff_right_compose!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, h, g, X)\n\nCompute the differential of the right group multiplication œÅ_g(h) = hg, which simplifies for AdditionGroupOperation to DœÅ_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_right_compose","text":"diff_right_compose(G::LieGroup{ùîΩ,AdditionGroupOperation}, h, g, X)\ndiff_right_compose!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, h, g, X)\n\nCompute the differential of the right group multiplication œÅ_g(h) = hg, which simplifies for AdditionGroupOperation to DœÅ_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.identity_element!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.identity_element!","text":"identity_element(G::LieGroup{ùîΩ,AdditionGroupOperation})\nidentity_element!(G::LieGroup{ùîΩ,AdditionGroupOperation}, e)\n\nReturn the a point representation of the Identity, which for the AdditionGroupOperation is the zero element or array.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.inv!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.inv!","text":"inv(G::LieGroup{ùîΩ,AdditionGroupOperation}, g)\ninv!(G::LieGroup{ùîΩ,AdditionGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for the AdditionGroupOperation simplifies to -g. This can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket!-Union{Tuple{ùîΩ}, Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{AdditionGroupOperation}} where G<:(LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}), Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.lie_bracket!","text":"lie_bracket!(ùî§::LieAlgebra{ùîΩ,AdditionGroupOperation}, X, Y)\nlie_bracket!(ùî§::LieAlgebra{ùîΩ,AdditionGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the AdditionGroupOperation simplifies to the corresponding zero_vector. The computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket-Union{Tuple{ùîΩ}, Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{AdditionGroupOperation}} where G<:(LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}), Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.lie_bracket","text":"lie_bracket!(ùî§::LieAlgebra{ùîΩ,AdditionGroupOperation}, X, Y)\nlie_bracket!(ùî§::LieAlgebra{ùîΩ,AdditionGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the AdditionGroupOperation simplifies to the corresponding zero_vector. The computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Manifolds.compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any}} where ùîΩ","page":"Group operation","title":"Manifolds.compose","text":"compose(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, h)\ncompose!(G::LieGroup{ùîΩ,AdditionGroupOperation}, k, g, h)\n\nCompute the group operation composition of g and h with respect to the AdditionGroupOperation on G, which falls back to calling g+h, where + is assumed to be overloaded accordingly.\n\nThis can be computed in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Manifolds.identity_element-Union{Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Tuple{ùîΩ}} where ùîΩ","page":"Group operation","title":"Manifolds.identity_element","text":"identity_element(G::LieGroup{ùîΩ,AdditionGroupOperation})\nidentity_element!(G::LieGroup{ùîΩ,AdditionGroupOperation}, e)\n\nReturn the a point representation of the Identity, which for the AdditionGroupOperation is the zero element or array.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.exp!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any}} where ùîΩ","page":"Group operation","title":"ManifoldsBase.exp!","text":"exp(G::LieGroup{ùîΩ,AdditionGroupOperation}, X)\nexp!(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, X)\n\nCompute the Lie group exponential on a LieGroup with an AdditionGroupOperation. This can be computed in-place of g.\n\nSince e is just the zero-element with respect to the corresponding +, the formula reads g=0+X=X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.log!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any}} where ùîΩ","page":"Group operation","title":"ManifoldsBase.log!","text":"log(G::LieGroup{ùîΩ,AdditionGroupOperation}, g)\nlog!(G::LieGroup{ùîΩ,AdditionGroupOperation}, X, g)\n\nCompute the Lie group logarithm on a LieGroup with an AdditionGroupOperation. This can be computed in-place of X.\n\nSince e is just the zero-element with respect to the corresponding +, the formula reads X=g-0=g.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#multiplication-operation-sec","page":"Group operation","title":"Multiplication group operation","text":"","category":"section"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"Modules = [LieGroups]\nPages = [\"multiplication_operation.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"interface/operations/#LieGroups.AbstractMultiplicationGroupOperation","page":"Group operation","title":"LieGroups.AbstractMultiplicationGroupOperation","text":"AbstractMultiplicationGroupOperation <: AbstractGroupOperation\n\nA group operation that is realised introducing defaults that fall back to * being overloaded, for example _compose(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, a, b) = a * b\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#LieGroups.MatrixMultiplicationGroupOperation","page":"Group operation","title":"LieGroups.MatrixMultiplicationGroupOperation","text":"AbstractMultiplicationGroupOperation <: AbstractMultiplicationGroupOperation\n\nA group operation that is realised by a matrix multiplication.\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#Base.exp-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, MatrixMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any}} where ùîΩ","page":"Group operation","title":"Base.exp","text":"exp(G::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, X)\nexp!(G::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, g, X)\n\nCompute the Lie group exponential on a LieGroup with a MatrixMultiplicationGroupOperation, which simplifies to the matrix exponential.\n\nThis can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.inv-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any}} where ùîΩ","page":"Group operation","title":"Base.inv","text":"inv(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperationroupOperation}, g)\ninv!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for an AbstractMultiplicationGroupOperation simplifies to the multiplicative inverse g^-1. This can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.log-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, MatrixMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any}} where ùîΩ","page":"Group operation","title":"Base.log","text":"log(G::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, g)\nlog!(G::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, X, g)\n\nCompute the Lie group logarithm on a LieGroup with a MatrixMultiplicationGroupOperation, which simplifies to the matrix logarithm.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.compose!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.compose!","text":"compose(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, h)\ncompose!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, k, g, h)\n\nCompute the group operation composition of g and h with respect to an AbstractMultiplicationGroupOperation on G, which falls back to calling g*h, where * is assumed to be overloaded accordingly.\n\nThis can be computed in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s19\", M} where {var\"#s19\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Vararg{Any, 4}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_conjugate!","text":"diff_conjugate(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1 = ghg^-1, which simplifies for an AbstractMultiplicationGroupOperation to D(c_g(h))X = gXg^-1.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_conjugate","text":"diff_conjugate(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1 = ghg^-1, which simplifies for an AbstractMultiplicationGroupOperation to D(c_g(h))X = gXg^-1.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s19\", M} where {var\"#s19\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_inv!","text":"diff_inv(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, g, X)\n\nCompute the value of differential DŒπ_mathcal G(g)X of matrix inversion Œπ_mathcal G(g) = g^-1 at X  ùî§ in the LieAlgebra ùî§ of the LieGroup G.\n\nThe formula is given by\n\nDŒπ_mathcal G(g)X = -g^mathrmTXg^-1\n\nwhich stems from using the differential of the inverse from [Gil08] given by D(g^-1)X = -g^-1Xg^-1 composed with the push forward of the left composition DŒª_mathrme(g)X = gX mapping from the Liea algebra into the tangent space at g, and its adjoint D^*Œª_mathrme(g)X = g^mathrmTX. Then we get g^mathrmT(g^-1(gX)g^-1) which simplifies to -g^mathrmTXg^-1 from above.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_inv","text":"diff_inv(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, g, X)\n\nCompute the value of differential DŒπ_mathcal G(g)X of matrix inversion Œπ_mathcal G(g) = g^-1 at X  ùî§ in the LieAlgebra ùî§ of the LieGroup G.\n\nThe formula is given by\n\nDŒπ_mathcal G(g)X = -g^mathrmTXg^-1\n\nwhich stems from using the differential of the inverse from [Gil08] given by D(g^-1)X = -g^-1Xg^-1 composed with the push forward of the left composition DŒª_mathrme(g)X = gX mapping from the Liea algebra into the tangent space at g, and its adjoint D^*Œª_mathrme(g)X = g^mathrmTX. Then we get g^mathrmT(g^-1(gX)g^-1) which simplifies to -g^mathrmTXg^-1 from above.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s19\", M} where {var\"#s19\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Vararg{Any, 4}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_left_compose!","text":"diff_left_compose(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh, which simplifies for an AbstractMultiplicationGroupOperation to DŒª_g(h)X = gX.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_left_compose","text":"diff_left_compose(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh, which simplifies for an AbstractMultiplicationGroupOperation to DŒª_g(h)X = gX.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s19\", M} where {var\"#s19\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Vararg{Any, 4}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_right_compose!","text":"diff_right_compose(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, h, g, X)\ndiff_right_compose!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, h, g, X)\n\nCompute the differential of the right group multiplication œÅ_g(h) = hg, which simplifies for an AbstractMultiplicationGroupOperation to DœÅ_g(h)X = Xg.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_right_compose","text":"diff_right_compose(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, h, g, X)\ndiff_right_compose!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, h, g, X)\n\nCompute the differential of the right group multiplication œÅ_g(h) = hg, which simplifies for an AbstractMultiplicationGroupOperation to DœÅ_g(h)X = Xg.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.identity_element!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.identity_element!","text":"identity_element(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation})\nidentity_element!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, e)\n\nReturn the a point representation of the Identity, which for an AbstractMultiplicationGroupOperation is the one-element or identity array.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.inv!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s19\", M} where {var\"#s19\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.inv!","text":"inv(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperationroupOperation}, g)\ninv!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for an AbstractMultiplicationGroupOperation simplifies to the multiplicative inverse g^-1. This can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket!-Union{Tuple{ùîΩ}, Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{MatrixMultiplicationGroupOperation}} where G<:(LieGroup{ùîΩ, MatrixMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}), Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.lie_bracket!","text":"lie_bracket(::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, X, Y)\nlie_bracket!(::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the MatrixMultiplicationGroupOperation yields the commutator bracket\n\nX Y = XY-YX\n\nThe computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket-Union{Tuple{ùîΩ}, Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{MatrixMultiplicationGroupOperation}} where G<:(LieGroup{ùîΩ, MatrixMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}), Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.lie_bracket","text":"lie_bracket(::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, X, Y)\nlie_bracket!(::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the MatrixMultiplicationGroupOperation yields the commutator bracket\n\nX Y = XY-YX\n\nThe computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Manifolds.compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any}} where ùîΩ","page":"Group operation","title":"Manifolds.compose","text":"compose(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, h)\ncompose!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, k, g, h)\n\nCompute the group operation composition of g and h with respect to an AbstractMultiplicationGroupOperation on G, which falls back to calling g*h, where * is assumed to be overloaded accordingly.\n\nThis can be computed in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Manifolds.identity_element-Union{Tuple{LieGroup{ùîΩ, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}}, Tuple{ùîΩ}} where ùîΩ","page":"Group operation","title":"Manifolds.identity_element","text":"identity_element(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation})\nidentity_element!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, e)\n\nReturn the a point representation of the Identity, which for an AbstractMultiplicationGroupOperation is the one-element or identity array.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.exp!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, MatrixMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any}} where ùîΩ","page":"Group operation","title":"ManifoldsBase.exp!","text":"exp(G::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, X)\nexp!(G::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, g, X)\n\nCompute the Lie group exponential on a LieGroup with a MatrixMultiplicationGroupOperation, which simplifies to the matrix exponential.\n\nThis can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.log!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, MatrixMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any}} where ùîΩ","page":"Group operation","title":"ManifoldsBase.log!","text":"log(G::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, g)\nlog!(G::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, X, g)\n\nCompute the Lie group logarithm on a LieGroup with a MatrixMultiplicationGroupOperation, which simplifies to the matrix logarithm.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Literature","page":"Group operation","title":"Literature","text":"","category":"section"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"M.¬†B.¬†Giles. Collected Matrix Derivative Results for Forward and Reverse Mode Algorithmic Differentiation. In: Advances in Automatic Differentiation, Lecture Notes in Computational Science and Engineering, edited by C.¬†H.¬†Bischof, H.¬†M.¬†B√ºcker, P.¬†Hovland, U.¬†Naumann and J.¬†Utke (Springer, Berlin, Heidelberg, 2008); pp.¬†35‚Äì44.\n\n\n\n","category":"page"},{"location":"about/#About-LieGroups.jl","page":"About","title":"About LieGroups.jl","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"LieGroups.jl is a ‚Äúspin-off‚Äù from `Manifolds.jl, where GroupManifolds where implemented around 2021. Around the same time, Yueh-Hua Tu started a package LieGroups.jl, which was continued than here with a full rewrite to use the manifolds from Manifolds.jl.","category":"page"},{"location":"interface/actions/#An-Interface-for-Lie-group-actions","page":"Group action","title":"An Interface for Lie group actions","text":"","category":"section"},{"location":"interface/actions/","page":"Group action","title":"Group action","text":"Modules = [LieGroups]\nPages = [\"group_action_interface.jl\"]\nOrder = [:type]","category":"page"},{"location":"interface/actions/#LieGroups.AbstractGroupActionType","page":"Group action","title":"LieGroups.AbstractGroupActionType","text":"AbstractGroupActionType\n\nAn abstract supertype for group action types, which are used within a GroupAction.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.AbstractLeftGroupActionType","page":"Group action","title":"LieGroups.AbstractLeftGroupActionType","text":"AbstractLeftGroupActionType <: AbstractGroupActionType\n\nA type representing a (smooth) group action œÉ mathcal G  mathcal M  mathcal M of a LieGroup mathcal G acting (from the left) on an AbstractManifold mathcal M. with the following properties\n\nœÉ(mathrme p) = p holds for all p  mathcal M\nœÉ(g œÉ(h p)) = œÉ(gh p) holds for all gh  mathcal G, p  mathcal M\n\nwhere  denotes the group operation of the LieGroup mathcal G. See also [HN12, Definition 9.1.11].\n\nThe type of action can be seen a bit better when writing the action as a family œÉ_g(p): we obtain from the second property as\n\n  œÉ_g(œÉ_h(p)) = œÉ_gh(p)\n\nand see that g appears on the left.\n\nTo emphasize the side the group operation is acting from, we sometimes write œÉ^mathrmL. If the action is clear from context we write œÉ(g p) = g  p.\n\nOne notable example of a left action is the inverse of an action of AbstractRightGroupActionType œÉ^mathrmR, which is given by œÑ_g = (œÉ^mathrmR_g)^-1 = œÉ^mathrmR_g^-1. We obtain\n\nœÑ_g(œÑ_h(p))\n= œÉ^mathrmR_g^-1(œÉ^mathrmR_h^-1(p))\n= œÉ^mathrmR_h^-1g^-1(p)\n= œÉ^mathrmR_(gh)^-1(p)\nœÑ_gh(p)\n\nnote: Note\nIn function definitions we follow the idea of the family of actions and use the order (M, g, p) in function signatures.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.AbstractRightGroupActionType","page":"Group action","title":"LieGroups.AbstractRightGroupActionType","text":"AbstractRightGroupActionType <: AbstractGroupActionType\n\nA type representing a (smooth) group action œÉ mathcal M  mathcal G  mathcal M of a LieGroup mathcal G acting (from the right) on an AbstractManifold mathcal M. with the following properties\n\nœÉ(p mathrme) = p holds for all p  mathcal M\nœÉ(œÉ(p g) h) = œÉ(p gh) holds for all gh  mathcal G, p  mathcal M\n\nwhere  denotes the group operation of the LieGroup mathcal G. See also [HN12, Remark 9.1.12].\n\nThe type of action can be seen a bit better when writing the action as a family œÉ_g(p): we obtain from the second property as\n\n  œÉ_g(œÉ_h(p)) = œÉ_hg(p)\n\nand see that g appears on the right.\n\nTo emphasize the side the group operation is acting from, we sometimes write œÉ^mathrmR. If the action is clear from context we write œÉ(p g) = p  g.\n\nOne notable example of a right action is the inverse of an action of  AbstractLeftGroupActionType œÉ^mathrmL, which is given by œÑ_g = (œÉ^mathrmL_g)^-1 = œÉ^mathrmL_g^-1. We obtain\n\nœÑ_g(œÑ_h(p))\n= œÉ^mathrmL_g^-1(œÉ^mathrmL_h^-1(p))\n= œÉ^mathrmL_g^-1h^-1(p)\n= œÉ^mathrmL_(hg)^-1(p)\nœÑ_hg(p)\n\nnote: Note\nIn function definitions we follow the idea of the family of actions and use the order (M, g, p) in function signatures.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.GroupAction","page":"Group action","title":"LieGroups.GroupAction","text":"GroupAction{T<:GroupActionType, L<:LieGroup, M<:AbstractManifold}\n\nSpecify a group action of AbstractGroupActionType T of a LieGroup G acting on M.\n\nLet mathcal M be a AbstractManifold and mathcal G be a LieGroup with group operation .\n\nA (smooth) action of the group mathcal G on the manifold mathcal M is a map\n\nœÉ mathcal G  mathcal M  mathcal M\n\nwith the properties\n\nœÉ(mathrme p) = p holds for all p  mathcal M\nœÉ(g œÉ(h p)) = œÉ(gh p) holds for all gh  mathcal G, p  mathcal M\n\nFields\n\ntype::T: The type of the group action.\ngroup::L: The group acting.\nmanifold::M: The manifold the group acts upon.\n\nSee [HN12, Section 9.1.3] for more details.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#Functions-for-Lie-group-actions","page":"Group action","title":"Functions for Lie group actions","text":"","category":"section"},{"location":"interface/actions/","page":"Group action","title":"Group action","text":"Modules = [LieGroups]\nPages = [\"group_action_interface.jl\"]\nOrder = [:function]","category":"page"},{"location":"interface/actions/#Base.inv-Tuple{AbstractGroupActionType}","page":"Group action","title":"Base.inv","text":"inv(::AbstractGroupActionType)\n\nreturn the inverse group operation action, that is, use the type representing the inverse operation.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Base.inv-Tuple{GroupAction}","page":"Group action","title":"Base.inv","text":" inv(A::GroupAction{T})\n\nReturn the GroupAction representing the inverse of an GroupAction of AbstractGroupActionType T. This is usually done by returning the group action with the inverse type of T.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.base_lie_group-Tuple{GroupAction}","page":"Group action","title":"LieGroups.base_lie_group","text":"base_lie_group(A::GroupAction)\n\nReturn the LieGroup of the GroupAction specifying the action.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.default_left_action-Tuple{LieGroup, ManifoldsBase.AbstractManifold}","page":"Group action","title":"LieGroups.default_left_action","text":"default_left_action(G::LieGroup, M::AbstractManifold)\n\nReturn the default left action for a Lie group G acting on a manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.default_right_action-Tuple{LieGroup, ManifoldsBase.AbstractManifold}","page":"Group action","title":"LieGroups.default_right_action","text":"default_right_action(G::LieGroup, M::AbstractManifold)\n\nReturn the default right action for a Lie group G acting on a manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.diff_apply!-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"LieGroups.diff_apply!","text":"diff_apply(A::GroupAction{T, L, M}, g, p, X)\ndiff_apply!(A::GroupAction{T, L, M}, Y, g, p, X)\n\nCompute the differential D_p œÉ_g(p) T_pmathcal M  T_œÉ_g(p)mathcal M, where for a left group action we have œÉ_g(p) = œÉ(gp), for a right action œÉ_g(p) = œÉ(p g).\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.diff_apply-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"LieGroups.diff_apply","text":"diff_apply(A::GroupAction{T, L, M}, g, p, X)\ndiff_apply!(A::GroupAction{T, L, M}, Y, g, p, X)\n\nCompute the differential D_p œÉ_g(p) T_pmathcal M  T_œÉ_g(p)mathcal M, where for a left group action we have œÉ_g(p) = œÉ(gp), for a right action œÉ_g(p) = œÉ(p g).\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.diff_group_apply!-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"LieGroups.diff_group_apply!","text":"diff_group_apply(A::GroupAction{T, L, M}, g, p, X)\ndiff_group_apply!(A::GroupAction{T, L, M}, Y, g, p, X)\n\nCompute the differential D_g œÉ_g(p) mathfrak g  mathfrak g, where we use the short hand notation œÉ_p(g) = œÉ(gp) for a left action, and for a right action œÉ_p(g) = œÉ(p g).\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.diff_group_apply-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"LieGroups.diff_group_apply","text":"diff_group_apply(A::GroupAction{T, L, M}, g, p, X)\ndiff_group_apply!(A::GroupAction{T, L, M}, Y, g, p, X)\n\nCompute the differential D_g œÉ_g(p) mathfrak g  mathfrak g, where we use the short hand notation œÉ_p(g) = œÉ(gp) for a left action, and for a right action œÉ_p(g) = œÉ(p g).\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{AbstractGroupActionType}","page":"Group action","title":"LieGroups.switch","text":"switch(T::AbstractGroupActionType)\n\nReturn the object representing an AbstractGroupActionType related to a group operation action that switched the side, that is it turns a left action type into its corresponding right action type.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{GroupAction}","page":"Group action","title":"LieGroups.switch","text":" switch(A::GroupAction{T})\n\nReturn the group operation action representing the similar GroupAction of AbstractGroupActionType T but acting from the other side. It switches left to right and vice versa. This is done by returning the group action with the ‚Äúswitched‚Äù type of T.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Manifolds.apply!-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"Manifolds.apply!","text":"apply(A::GroupAction{T, L, M}, g, p)\napply!(A::GroupAction{T, L, M}, q, g, p)\n\nApply the group action induced by g  mathcal G to p  mathcal M, where the kind of group action is indicated by the AbstractGroupActionType T. This can be performed in-place of q.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Manifolds.apply-Tuple{GroupAction, Any, Any}","page":"Group action","title":"Manifolds.apply","text":"apply(A::GroupAction{T, L, M}, g, p)\napply!(A::GroupAction{T, L, M}, q, g, p)\n\nApply the group action induced by g  mathcal G to p  mathcal M, where the kind of group action is indicated by the AbstractGroupActionType T. This can be performed in-place of q.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#ManifoldsBase.base_manifold-Tuple{GroupAction}","page":"Group action","title":"ManifoldsBase.base_manifold","text":"base_manifold(A::GroupAction)\n\nReturn the AbstractManifold the group action acts upon.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Generic-Lie-group-actions","page":"Group action","title":"Generic Lie group actions","text":"","category":"section"},{"location":"interface/actions/","page":"Group action","title":"Group action","text":"Modules = [LieGroups]\nPages = [\"group_operation_action.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"interface/actions/#LieGroups.InverseLeftGroupOperationAction","page":"Group action","title":"LieGroups.InverseLeftGroupOperationAction","text":"InverseLeftGroupOperationAction <: AbstractRightGroupActionType\n\nA type for the AbstractLeftGroupActionType when acting on the group itself given by the inverse of a LeftGroupOperationAction œÉ_h as\n\nœÑ_h(g) coloneqq œÉ_h^-1(g) = œÉ(h^-1g) = h^-1g\n\nNote that while in naming it is the inverse of the left action, it's properties yield that is is an AbstractRightGroupActionType, since\n\nœÑ_g(œÑ_h(p))\n= œÉ^mathrmL_g^-1(œÉ^mathrmL_h^-1(p))\n= œÉ^mathrmL_g^-1h^-1(p)\n= œÉ^mathrmL_(hg)^-1(p)\nœÑ_hg(p)\n\nfor its inverse (œÉ_h)^-1 see InverseLeftGroupOperationAction.\n\nnote: Note\nSome literature also calls this by itself the right group operation action.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.InverseRightGroupOperationAction","page":"Group action","title":"LieGroups.InverseRightGroupOperationAction","text":"InverseRightGroupOperationAction <: AbstractLeftGroupActionType\n\nA type for the AbstractLeftGroupActionType when acting on the group itself given by the inverse of a RightGroupOperationAction œÉ_h as\n\nœÑ_h(g) coloneqq œÉ_h^-1(g) = œÉ(h^-1g) = gh^-1\n\nNote that while in naming it is the inverse of the right action, it's properties yield that is is an AbstractLeftGroupActionType, since\n\nœÑ_g(œÑ_h(p))\n= œÉ^mathrmR_g^-1(œÉ^mathrmR_h^-1(p))\n= œÉ^mathrmR_h^-1g^-1(p)\n= œÉ^mathrmR_(gh)^-1(p)\nœÑ_gh(p)\n\nfor its inverse (œÉ_h)^-1 see InverseLeftGroupOperationAction.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.LeftGroupOperationAction","page":"Group action","title":"LieGroups.LeftGroupOperationAction","text":"LeftGroupOperationAction <: AbstractLeftGroupActionType\n\nA type for the AbstractLeftGroupActionType when acting on the group itself from the left, that is\n\nœÉ_h(g) = œÉ(hg) = hg\n\nfor its inverse (œÉ_h)^-1 see InverseLeftGroupOperationAction.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.RightGroupOperationAction","page":"Group action","title":"LieGroups.RightGroupOperationAction","text":"RightGroupOperationAction <: AbstractRightGroupActionType\n\nA type for the AbstractLeftGroupActionType when acting on the group itself from the right.\n\nœÉ_h(g) = œÉ(hg) = gh\n\nfor its inverse (œÉ_h)^-1 see InverseRightGroupOperationAction.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#Base.inv-Tuple{InverseLeftGroupOperationAction}","page":"Group action","title":"Base.inv","text":"inv(::InverseLeftGroupOperationAction)\n\nReturn the inverse of the InverseLeftGroupOperationAction, that is the LeftGroupOperationAction.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Base.inv-Tuple{InverseRightGroupOperationAction}","page":"Group action","title":"Base.inv","text":"inv(::InverseRightGroupOperationAction)\n\nReturn the inverse of the InverseRightGroupOperationAction, that is the RightGroupOperationAction.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Base.inv-Tuple{LeftGroupOperationAction}","page":"Group action","title":"Base.inv","text":"inv(::LeftGroupOperationAction)\n\nReturn the inverse of the LeftGroupOperationAction, that is the InverseLeftGroupOperationAction.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Base.inv-Tuple{RightGroupOperationAction}","page":"Group action","title":"Base.inv","text":"inv(::RightGroupOperationAction)\n\nReturn the inverse of the RightGroupOperationAction, that is the InverseRightGroupOperationAction.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.GroupOperationAction-Tuple{AbstractGroupActionType, LieGroup}","page":"Group action","title":"LieGroups.GroupOperationAction","text":"GroupOperationAction(action::AbstractGroupActionType, group::LieGroup)\n\nReturn a GroupAction for an AbstractGroupActionType action representing the group operation as an action of the group on itself.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{InverseLeftGroupOperationAction}","page":"Group action","title":"LieGroups.switch","text":"switch(::InverseLeftGroupOperationAction)\n\nReturn the InverseRightGroupOperationAction, that is, turns œÉ_g = g^-1h into œÑ_g(h) = hg^-1\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{InverseRightGroupOperationAction}","page":"Group action","title":"LieGroups.switch","text":"switch(::InverseRightGroupOperationAction)\n\nReturn the InverseLeftGroupOperationAction, that is, turns œÉ_g = hg^-1 into œÑ_g(h) = g^-1h\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{LeftGroupOperationAction}","page":"Group action","title":"LieGroups.switch","text":"switch(::LeftGroupOperationAction)\n\nReturn the RightGroupOperationAction, that is, turns œÉ_g = gh into œÑ_g(h) = hg\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{RightGroupOperationAction}","page":"Group action","title":"LieGroups.switch","text":"switch(::RightGroupOperationAction)\n\nReturn the LeftGroupOperationAction, that is, turns œÉ_g = hg into œÑ_g(h) = gh\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Literature","page":"Group action","title":"Literature","text":"","category":"section"},{"location":"interface/actions/","page":"Group action","title":"Group action","text":"J.¬†Hilgert and K.-H.¬†Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\n","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"EditURL = \"https://github.com/JuliaManifolds/LieGroups.jl/blob/main/NEWS.md\"","category":"page"},{"location":"news/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"All notable Changes to the Julia package LieGroups.jl will be documented in this file.","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"news/#[0.1.0]-‚Äì-unreleased","page":"Changelog","title":"[0.1.0] ‚Äì unreleased","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Everything denoted by ‚Äúformerly‚Äù refers to the previous name in Manifolds.jl.","category":"page"},{"location":"news/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"LieAlgebra\nLieGroup (formerly GroupManifold) as well as the concrete groups\nTranslationGroup\nSpecialEuclideanGroup (formerly SpecialEuclidean) including\nSpecialEuclideanMatrixPoint and SpecialEuclideanMatrixTangentVector when representing thepoints as affine (abstract) matrices\nSpecialEuclideanProductPoint and SpecialEuclideanProductTangentVector when representing them in a product structure, e.g. as an ArrayPartition from RecursiveArrayTools.\nneither of those types is necessary, besides for conversion between both. The product representation differs for the left and right semidirect product, while the affine matrix variant does not.\nSpecialOrthogonalGroup (formerly SpecialOrthogonal)\nSpecialUnitaryGroup (formerly SpecialUnitary)\nOrthogonalGroup (formerly Orthogonal)\nUnitaryGroup (formerly Unitary)\nGeneralLinearGroup (formerly GeneralLinear)\nHeisenbergGroup\nLeftSemidirectProductLieGroup (formerly SemidirectProductGroup)\n‚ãâ (alias for LeftSemidirectProductGroupOperation when a default_left_action(G,H) is defined for the two groups)\nPowerLieGroup (formerly PowerGroup)\nPowerGroupOperation to internally avoid ambiguities. Since the constructor always expects a Lie group, this is only necessary internally\nProductLieGroup (formerly ProductGroup)\nRightSemidirectProductLieGroup\n‚ãä (alias for RightSemidirectProductGroupOperation when a default_right_action(G,H) is defined for the two groups)\nAbstractGroupOperation as well as its concrete subtypes\nAdditionGroupOperation (formerly AdditionOperation)\nMatrixMultiplicationGroupOperation (formerly MultiplicationOperation)\nPowerGroupOperation (formerly the Lie group was stored inside a power manifold)\nProductGroupOperation (formerly the Lie groups were stored inside a product manifold)\nLeftSemidirectProductGroupOperation (this was formerly only implicitly stored in the SemidirectProductGroup)\nRightSemidirectProductGroupOperation\nAbstractGroupActionType with its 2 specific (new) abstract subtypes\nAbstractLeftGroupActionType\nAbstractRightGroupActionType\nFor the group operation actions there are now\nLeftGroupOperationAction (formerly LeftForwardAction)\nRightGroupOperationAction (formerly RightBackwardAction)\nInverseLeftGroupOperationAction (formerly RightForwardAction)\nInverseRightGroupOperationAction (formerly LeftBackwardAction)\nDefaultLieAlgebraOrthogonalBasis (replaces VeeOrthogonalBasis, which is still available in ManifoldsBase.jl)\nAbstractLieGroupPoint and AbstractLieAlgebraTangentVector as abstract types to introduce point and Lie algebra tangent vector representations\nIdentity\napplyand apply!\nbase_manifold to access the manifold within a Lie group\ncompose and compose!\nconjugate and conjugate!\ndiff_apply, diff_apply!, diff_group_apply, and diff_group_apply! (formerly apply_diff_[group][!])\ndiff_conjugate and diff_conjugate!\ndiff_left_compose, diff_left_compose!, diff_right_compose, diff_right_compose! (formerly translate_diff with different sides)\nexp(G::LieGroup, g, X) and exp!(G::LieGroup, h, g, X) (formerly exp_inv and exp_inv!)\nexp(G::LieGroup, X) and exp!(G::LieGroup, h, X) (formerly exp_lie and exp_lie!)\nhat and hat!, with slightly different signatures, since the base point is omitted.\nidentity_element and identity_element!\ninv and inv! (inv(::AbstractGroupAction) was formerly switch_direction)\ninv_left_compose, inv_left_compose! and inv_right_compose, inv_right_compose! (these functions correspond to inverse_translate with corresponding direction and side)\nis_identity\nlie_bracket and lie_bracket!\njacobian_conjugate (formerly adjoint_matrix, which is now a special case of this)\nlog(G::LieGroup, g, h) and log!(G::LieGroup, X, g, h) (formerly log_inv and log_inv!)\nlog(G::LieGroup, ::Identity, g) and log!(G::LieGroup, X, ::Identity, g) (formerly log_lie and log_lie!)\nswitch (formerly switch_side)\nvee and vee!, with slightly different signatures, since the base point is omitted.","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Compared to Manifolds.jl","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"all translate functions are not implemented here, since you can just use compose. The differentials are implemented as listed above with respect to both left and right argument of compose\nall inverse_apply functions are not implemented here, since it is recommended to use apply(inv(A), g, p) as a replacement.","category":"page"},{"location":"news/#[0.0.3]-‚Äì-unreleased","page":"Changelog","title":"[0.0.3] ‚Äì unreleased","text":"","category":"section"},{"location":"news/#Added-2","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Finishes most of the work on the interface for the LieGroup type and the new LieAlgebra type.\nFinishes a generic implementation of a SemiDirectProductGroupOperation\nAll details will be detailed in the next release","category":"page"},{"location":"news/#Old-Changelog-pre-0.0.3","page":"Changelog","title":"Old Changelog pre 0.0.3","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Two previous releases where done by Yueh-Hua Tu in 2022 before he was so kind to transfer the development to the JuliaManifolds GitHub organisation.","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"All notable changes to this project will be documented in this file.","category":"page"},{"location":"news/#[0.0.2]","page":"Changelog","title":"[0.0.2]","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"fix SE{3} and add jacobian\ndefine dof and dim for Lie algebra and jacobian of inv\nadd action for SE{N}\nadd se3_location example","category":"page"},{"location":"interface/group/#An-interface-for-Lie-groups","page":"Lie group","title":"An interface for Lie groups","text":"","category":"section"},{"location":"interface/group/","page":"Lie group","title":"Lie group","text":"LieGroup\nAbstractLieAlgebraTangentVector\nAbstractLieGroupPoint","category":"page"},{"location":"interface/group/#LieGroups.LieGroup","page":"Lie group","title":"LieGroups.LieGroup","text":"LieGroup{ùîΩ, O<:AbstractGroupOperation, M<:AbstractManifold{ùîΩ}} <: AbstractManifold{ùîΩ}\n\nRepresent a Lie Group mathcal G.\n\nA Lie Group mathcal G is a group endowed with the structure of a manifold such that the group operations  mathcal Gmathcal G  mathcal G, see compose and the inverse operation ^-1 mathcal G  mathcal G, see inv are smooth, see for example [HN12, Definition 9.1.1].\n\nLie groups are named after the Norwegian mathematician Marius Sophus Lie (1842‚Äì1899).\n\nFields\n\nmanifold: an AbstractManifold mathcal M\nop: an AbstractGroupOperation  on that manifold\n\nConstructor\n\nLieGroup(M::AbstractManifold, op::AbstractGroupOperation)\n\nGenerate a Lie group based on a manifold M and a group operation op, where vectors by default are stored in the Lie Algebra.\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#LieGroups.AbstractLieAlgebraTangentVector","page":"Lie group","title":"LieGroups.AbstractLieAlgebraTangentVector","text":"AbstractLieAlgebraTangentVector <: ManifoldsBase.AbstractTangentVector\n\nAn abstract type for a tangent vector represented in a LieAlgebra.\n\nWhile an tangent vectors are usually kept untyped for flexibility, it might be necessary to distinguish different types of points, for example\n\nfor complicated representations that require a struct\n\n@ semantic verification\n\nwhen there exist different representations\n\nBy sub-typing the AbstractManifoldPoint, this follows the same idea as in ManifoldsBase.jl.\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#LieGroups.AbstractLieGroupPoint","page":"Lie group","title":"LieGroups.AbstractLieGroupPoint","text":"AbstractLieGroupPoint <: ManifoldsBase.AbstractManifoldPoint end\n\nAn abstract type for a point on a LieGroup. While an points and tangent vectors are usually kept untyped for flexibility, it might be necessary to distinguish different types of points, for example\n\nfor complicated representations that require a struct\nsemantic verification\nwhen there exist different representations\n\nBy sub-typing the AbstractManifoldPoint, this follows the same idea as in ManifoldsBase.jl.\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#Functions-on-Lie-groups","page":"Lie group","title":"Functions on Lie groups","text":"","category":"section"},{"location":"interface/group/","page":"Lie group","title":"Lie group","text":"Modules = [LieGroups]\nPages = [\"src/interface.jl\"]\nOrder = [:function]","category":"page"},{"location":"interface/group/#Base.adjoint-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"Base.adjoint","text":"adjoint(G::LieGroup, g, X)\nadjoint!(G::LieGroup, Y, g, X)\n\nCompute the adjoint mathrmAd(g) mathfrak g  mathfrak g, which is defined as the differential diff_conjugate of the conjugate c_g(h) = ghg^-1 evaluated at the Identity h=mathrme. The operation can be performed in-place of Y.\n\n  mathrmAd(g)X = D c_g(mathrme) X qquad X  mathfrak g\n\nsee [HN12, Section 9.2.3].\n\nOn matrix Lie groups the adjoint reads mathrmAd(g)X = gXg^-1.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.exp-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"Base.exp","text":"exp(G::LieGroup, g, X)\nexp!(G::LieGroup, h, g, X)\n\nCompute the Lie group exponential map for gmathcal G and Xmathfrak g, where mathfrak g denotes the LieAlgebra of mathcal G. It is given by\n\nexp_g X = gexp_mathcal G(X)\n\nwhere X can be scaled by t, the computation can be performed in-place of h, and exp_mathcal G denotes the  Lie group exponential function.\n\nIf g is the Identity the Lie group exponential function exp_mathcal G is computed directly. Implementing the Lie group exponential function introduces a default implementation with the formula above.\n\nnote: Note\nThe Lie group exponential map is usually different from the exponential map with respect to the metric of the underlying Riemannian manifold mathcal M. To access the (Riemannian) exponential map, use exp(base_manifold(G), g, X).\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.exp-Tuple{LieGroup, Any}","page":"Lie group","title":"Base.exp","text":"exp(G::LieGroup, X::T)\nexp!(G::LieGroup, g, X)\n\nCompute the (Lie group) exponential function\n\nexp_mathcal G mathfrak g  mathcal Gqquad exp_mathcal G(X) = Œ≥_X(1)\n\nwhere Œ≥_X is the unique solution of the initial value problem\n\nŒ≥(0) = mathrme quad Œ≥(s) = Œ≥(s)X\n\nSee also [HN12, Definition 9.2.2]. On matrix Lie groups this is the same as the matrix exponential.\n\nThe computation can be performed in-place of g.\n\ninfo: Naming convention\nThere are at least two different objects usually called ‚Äúexponential‚Äù that need to be distinguishedthe (Riemannian) exponential map exp(M, p, X) from ManifoldsBase.jl. This can be accessed here using exp(base_manifold(G), p, X)\nthe exponential map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric exp(G, g, X), which we use as a default within this package\nthe (matrix/Lie group) exponential function exp(G, g) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.inv-Tuple{LieGroup, Any}","page":"Lie group","title":"Base.inv","text":"inv(G::LieGroup, g)\ninv!(G::LieGroup, h, g)\n\nCompute the inverse group element g^-1 with respect to the AbstractGroupOperation  on the LieGroup mathcal G, that is, return the unique element h=g^-1 such that hg=mathrme, where mathrme denotes the Identity.\n\nThis can be done in-place of h, without side effects, that is you can do inv!(G, g, g).\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.isapprox-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"Base.isapprox","text":"isapprox(M::LieGroup, g, h; kwargs...)\n\nCheck if points g and h from LieGroup are approximately equal. this function calls the corresponding isapprox on the AbstractManifold after handling the cases where one or more of the points are the Identity. All keyword argments are passed to this function as well.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.log-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"Base.log","text":"log(G::LieGroup, g, h)\nlog!(G::LieGroup, X, g, h)\n\nCompute the Lie group logarithmic map log_g mathcal G  mathfrak g, where mathfrak g denotes the LieAlgebra of mathcal G. It is given by\n\nlog_g h = log_mathcal G(g^-1h)\n\nwhere log_mathcal G denotes the Lie group logarithmic function The computation can be performed in-place of X.\n\ninfo: Naming convention\nThere are at least two different objects usually called ‚Äúlogarithm‚Äù that need to be distinguishedthe (Riemannian) logarithmic map log(M, p, X) from ManifoldsBase.jl\nthe exponential map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric exp(G, g, X), which we use as a default within this package\nthe (matrix/Lie group) exponential function exp(G, g) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.log-Tuple{LieGroup, Any}","page":"Lie group","title":"Base.log","text":"log(G::LieGroup, g, h)\nlog(G::LieGroup, g)\nlog(G::LieGroup, g::Identity, T)\nlog!(G::LieGroup, X::T, g)\n\nCompute the (Lie group) logarithmic function log_mathcal G mathcal G  mathfrak g, which is the inverse of the Lie group exponential function. For the allocating variant, you can specify the type T, when the point argument is the identity and hence does not provide the representation used. The computation can be performed in-place of X::T, which then determines the type.\n\ninfo: Naming convention\nThere are at least two different objects usually called ‚Äúlogarithm‚Äù that need to be distinguishedthe (Riemannian) logarithm map log(M, p, q) from ManifoldsBase.jl. This can be accessed here using log(base_manifold(G), p, q).\nthe logarithmic map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric log(G, g, h), which we use as a default within this package\nthe (matrix/Lie group) logarithm function log(G, h) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.rand-Tuple{LieGroup, Type}","page":"Lie group","title":"Base.rand","text":"rand(::LieGroup; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand(::LieGroup, PT::Type; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, T::Type; œÉ::Real=1.0, kwargs...)\nrand!(::LieGroup, gX::PT; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, X::T; œÉ::Real=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\nFor both cases, you can provide the type T for the tangent vector and/or point PT, if you want to generate a random point in a certain representation. For the in-place variants the type is inferred from pX¬¥ andX`, respectively.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.rand-Tuple{LieGroup}","page":"Lie group","title":"Base.rand","text":"rand(::LieGroup; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand(::LieGroup, PT::Type; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, T::Type; œÉ::Real=1.0, kwargs...)\nrand!(::LieGroup, gX::PT; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, X::T; œÉ::Real=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\nFor both cases, you can provide the type T for the tangent vector and/or point PT, if you want to generate a random point in a certain representation. For the in-place variants the type is inferred from pX¬¥ andX`, respectively.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.compose!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.compose!","text":"compose(G::LieGroup, g, h)\ncompose!(G::LieGroup, k, g, h)\n\nPerform the group operation g  h for two g h  mathcal G on the LieGroup G. This can also be done in-place of h.\n\ninfo: Info\nThis function also handles the case where g or/and h are the Identity(G). Since this would lead to ambiguities when implementing a new group operations, this function calls _compose and _compose!, respectively, which is meant for the actual computation of group operations on (non-Identity` but maybe its numerical representation) elements.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.conjugate!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.conjugate!","text":"conjugate(G::LieGroup, g, h)\nconjugate!(G::LieGroup, k, g, h)\n\nCompute the conjugation map c_g mathcal G  mathcal G given by c_g(h) = ghg^-1. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.conjugate-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"LieGroups.conjugate","text":"conjugate(G::LieGroup, g, h)\nconjugate!(G::LieGroup, k, g, h)\n\nCompute the conjugation map c_g mathcal G  mathcal G given by c_g(h) = ghg^-1. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_conjugate!-Tuple{LieGroup, Vararg{Any, 4}}","page":"Lie group","title":"LieGroups.diff_conjugate!","text":"diff_conjugate(G::LieGroup, g, h, X)\ndiff_conjugate!(G::LieGroup, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1, which can be performed in-place of Y.\n\n  D(c_g(h))X qquad X  mathfrak g\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_conjugate-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.diff_conjugate","text":"diff_conjugate(G::LieGroup, g, h, X)\ndiff_conjugate!(G::LieGroup, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1, which can be performed in-place of Y.\n\n  D(c_g(h))X qquad X  mathfrak g\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_inv!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.diff_inv!","text":"diff_inv(G::LieGroup, g, X)\ndiff_inv!(G::LieGroup, Y, g, X)\n\nCompute the differential of the function Œπ_mathcal G(g) = g^-1, where DŒπ_mathcal G(g) mathfrak g  mathfrak g. This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_inv-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"LieGroups.diff_inv","text":"diff_inv(G::LieGroup, g, X)\ndiff_inv!(G::LieGroup, Y, g, X)\n\nCompute the differential of the function Œπ_mathcal G(g) = g^-1, where DŒπ_mathcal G(g) mathfrak g  mathfrak g. This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_left_compose!-Tuple{LieGroup, Vararg{Any, 4}}","page":"Lie group","title":"LieGroups.diff_left_compose!","text":"diff_left_compose(G::LieGroup, g, h, X)\ndiff_left_compose!(G::LieGroup, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh, on the LieGroup G, that is Compute DŒª_g(h)X, X  ùî§. This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_left_compose-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.diff_left_compose","text":"diff_left_compose(G::LieGroup, g, h, X)\ndiff_left_compose!(G::LieGroup, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh, on the LieGroup G, that is Compute DŒª_g(h)X, X  ùî§. This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_right_compose!-Tuple{LieGroup, Vararg{Any, 4}}","page":"Lie group","title":"LieGroups.diff_right_compose!","text":"diff_right_compose(G::LieGroup, h, g, X)\ndiff_right_compose!(G::LieGroup, Y, h, g, X)\n\nCompute the differential of the right group multiplication œÅ_g(h) = hg, on the LieGroup G, that is Compute DœÅ_g(h)X, X  ùî§ This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_right_compose-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.diff_right_compose","text":"diff_right_compose(G::LieGroup, h, g, X)\ndiff_right_compose!(G::LieGroup, Y, h, g, X)\n\nCompute the differential of the right group multiplication œÅ_g(h) = hg, on the LieGroup G, that is Compute DœÅ_g(h)X, X  ùî§ This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.identity_element!-Tuple{LieGroup, Any}","page":"Lie group","title":"LieGroups.identity_element!","text":"identity_element(G::LieGroup)\nidentity_element(G::LieGroup, T)\nidentity_element!(G::LieGroup, e::T)\n\nReturn a point representation of the Identity on the LieGroup G. By default this representation is the default array or number representation. If there exist several representations, the type T can be used to distinguish between them, and it should be provided for both the AbstractLieGroupPoint as well as the AbstractLieAlgebraTangentVector if they differ, since maybe only one of these types might be available for the second signature.\n\nIt returns the corresponding default representation of e as a point on G. This can be performed in-place of e.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv!-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"LieGroups.inv!","text":"inv(G::LieGroup, g)\ninv!(G::LieGroup, h, g)\n\nCompute the inverse group element g^-1 with respect to the AbstractGroupOperation  on the LieGroup mathcal G, that is, return the unique element h=g^-1 such that hg=mathrme, where mathrme denotes the Identity.\n\nThis can be done in-place of h, without side effects, that is you can do inv!(G, g, g).\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv_left_compose!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.inv_left_compose!","text":"compose(G::LieGroup, g, h)\ncompose!(G::LieGroup, k, g, h)\n\nPerform the group operation g  h for two g h  mathcal G on the LieGroup G. This can also be done in-place of h.\n\ninfo: Info\nThis function also handles the case where g or/and h are the Identity(G). Since this would lead to ambiguities when implementing a new group operations, this function calls _compose and _compose!, respectively, which is meant for the actual computation of group operations on (non-Identity` but maybe its numerical representation) elements.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv_left_compose-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"LieGroups.inv_left_compose","text":"inv_left_compose(G::LieGroup, g, h)\ninv_left_compose!(G::LieGroup, k, g, h)\n\nCompute the inverse of the left group operation Œª_g(h) = gh, on the LieGroup G, that is, compute Œª_g^-1(h) = g^-1h. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv_right_compose!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.inv_right_compose!","text":"inv_right_compose(G::LieGroup, h, g)\ninv_right_compose!(G::LieGroup, k, h, g)\n\nCompute the inverse of the right group operation œÅ_g(h) = hg, on the LieGroup G, that is compute œÅ_g^-1(h) = hg^-1. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv_right_compose-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"LieGroups.inv_right_compose","text":"inv_right_compose(G::LieGroup, h, g)\ninv_right_compose!(G::LieGroup, k, h, g)\n\nCompute the inverse of the right group operation œÅ_g(h) = hg, on the LieGroup G, that is compute œÅ_g^-1(h) = hg^-1. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.jacobian_conjugate","page":"Lie group","title":"LieGroups.jacobian_conjugate","text":"jacobian_conjugate(G::LieGroup, g, h, B::AbstractBasis=DefaultLieAlgebraOrthogonalBasis())\njacobian_conjugate!(G::LieGroup, J, g, h, B::AbstractBasis=DefaultLieAlgebraOrthogonalBasis())\n\nCompute the Jacobian of the conjugate c_g(h) = ghg^-1, with respect to an AbstractBasis.\n\nThis can be seen as a matrix representation of the diff_conjugate D(c_g(h))X with respect to the given basis.\n\nnote: Note\nFor the case that h is the Identity and the relation of D(c_g(h))X to the adjoint mathrmAd(g), the Jacobian then sometimes called ‚Äúadjoint matrix‚Äù, e.g. in [SDA21], when choosing as a basis the DefaultLieAlgebraOrthogonalBasis() that is used for hat and vee.\n\n\n\n\n\n","category":"function"},{"location":"interface/group/#LieGroups.jacobian_conjugate!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.jacobian_conjugate!","text":"jacobian_conjugate(G::LieGroup, g, h, B::AbstractBasis=DefaultLieAlgebraOrthogonalBasis())\njacobian_conjugate!(G::LieGroup, J, g, h, B::AbstractBasis=DefaultLieAlgebraOrthogonalBasis())\n\nCompute the Jacobian of the conjugate c_g(h) = ghg^-1, with respect to an AbstractBasis.\n\nThis can be seen as a matrix representation of the diff_conjugate D(c_g(h))X with respect to the given basis.\n\nnote: Note\nFor the case that h is the Identity and the relation of D(c_g(h))X to the adjoint mathrmAd(g), the Jacobian then sometimes called ‚Äúadjoint matrix‚Äù, e.g. in [SDA21], when choosing as a basis the DefaultLieAlgebraOrthogonalBasis() that is used for hat and vee.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LinearAlgebra.adjoint!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LinearAlgebra.adjoint!","text":"adjoint(G::LieGroup, g, X)\nadjoint!(G::LieGroup, Y, g, X)\n\nCompute the adjoint mathrmAd(g) mathfrak g  mathfrak g, which is defined as the differential diff_conjugate of the conjugate c_g(h) = ghg^-1 evaluated at the Identity h=mathrme. The operation can be performed in-place of Y.\n\n  mathrmAd(g)X = D c_g(mathrme) X qquad X  mathfrak g\n\nsee [HN12, Section 9.2.3].\n\nOn matrix Lie groups the adjoint reads mathrmAd(g)X = gXg^-1.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Manifolds.compose-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"Manifolds.compose","text":"compose(G::LieGroup, g, h)\ncompose!(G::LieGroup, k, g, h)\n\nPerform the group operation g  h for two g h  mathcal G on the LieGroup G. This can also be done in-place of h.\n\ninfo: Info\nThis function also handles the case where g or/and h are the Identity(G). Since this would lead to ambiguities when implementing a new group operations, this function calls _compose and _compose!, respectively, which is meant for the actual computation of group operations on (non-Identity` but maybe its numerical representation) elements.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Manifolds.identity_element-Tuple{LieGroup}","page":"Lie group","title":"Manifolds.identity_element","text":"identity_element(G::LieGroup)\nidentity_element(G::LieGroup, T)\nidentity_element!(G::LieGroup, e::T)\n\nReturn a point representation of the Identity on the LieGroup G. By default this representation is the default array or number representation. If there exist several representations, the type T can be used to distinguish between them, and it should be provided for both the AbstractLieGroupPoint as well as the AbstractLieAlgebraTangentVector if they differ, since maybe only one of these types might be available for the second signature.\n\nIt returns the corresponding default representation of e as a point on G. This can be performed in-place of e.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Manifolds.is_identity-Tuple{LieGroup, Any}","page":"Lie group","title":"Manifolds.is_identity","text":"is_identity(G::LieGroup, q; kwargs...)\n\nCheck whether q is the identity on the LieGroup mathcal G. This means it is either the Identity{O} with the respect to the corresponding AbstractGroupOperation O, or (approximately) the correct point representation.\n\nSee also\n\nidentity_element, identity_element!\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.base_manifold-Tuple{LieGroup}","page":"Lie group","title":"ManifoldsBase.base_manifold","text":"base_manifold(G::LieGroup)\n\nReturn the manifold stored within the LieGroup G.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.exp!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"ManifoldsBase.exp!","text":"exp(G::LieGroup, g, X)\nexp!(G::LieGroup, h, g, X)\n\nCompute the Lie group exponential map for gmathcal G and Xmathfrak g, where mathfrak g denotes the LieAlgebra of mathcal G. It is given by\n\nexp_g X = gexp_mathcal G(X)\n\nwhere X can be scaled by t, the computation can be performed in-place of h, and exp_mathcal G denotes the  Lie group exponential function.\n\nIf g is the Identity the Lie group exponential function exp_mathcal G is computed directly. Implementing the Lie group exponential function introduces a default implementation with the formula above.\n\nnote: Note\nThe Lie group exponential map is usually different from the exponential map with respect to the metric of the underlying Riemannian manifold mathcal M. To access the (Riemannian) exponential map, use exp(base_manifold(G), g, X).\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.exp!-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"ManifoldsBase.exp!","text":"exp(G::LieGroup, X::T)\nexp!(G::LieGroup, g, X)\n\nCompute the (Lie group) exponential function\n\nexp_mathcal G mathfrak g  mathcal Gqquad exp_mathcal G(X) = Œ≥_X(1)\n\nwhere Œ≥_X is the unique solution of the initial value problem\n\nŒ≥(0) = mathrme quad Œ≥(s) = Œ≥(s)X\n\nSee also [HN12, Definition 9.2.2]. On matrix Lie groups this is the same as the matrix exponential.\n\nThe computation can be performed in-place of g.\n\ninfo: Naming convention\nThere are at least two different objects usually called ‚Äúexponential‚Äù that need to be distinguishedthe (Riemannian) exponential map exp(M, p, X) from ManifoldsBase.jl. This can be accessed here using exp(base_manifold(G), p, X)\nthe exponential map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric exp(G, g, X), which we use as a default within this package\nthe (matrix/Lie group) exponential function exp(G, g) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.is_point-Tuple{LieGroup, Any}","page":"Lie group","title":"ManifoldsBase.is_point","text":"is_point(G::LieGroup, g; kwargs...)\n\nCheck whether g is a valid point on the Lie Group G. This falls back to checking whether g is a valid point on the base_manifoldG. unless g is an Identity. Then, it is checked whether it is the identity element corresponding to G.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.log!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"ManifoldsBase.log!","text":"log(G::LieGroup, g, h)\nlog!(G::LieGroup, X, g, h)\n\nCompute the Lie group logarithmic map log_g mathcal G  mathfrak g, where mathfrak g denotes the LieAlgebra of mathcal G. It is given by\n\nlog_g h = log_mathcal G(g^-1h)\n\nwhere log_mathcal G denotes the Lie group logarithmic function The computation can be performed in-place of X.\n\ninfo: Naming convention\nThere are at least two different objects usually called ‚Äúlogarithm‚Äù that need to be distinguishedthe (Riemannian) logarithmic map log(M, p, X) from ManifoldsBase.jl\nthe exponential map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric exp(G, g, X), which we use as a default within this package\nthe (matrix/Lie group) exponential function exp(G, g) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.log!-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"ManifoldsBase.log!","text":"log(G::LieGroup, g, h)\nlog(G::LieGroup, g)\nlog(G::LieGroup, g::Identity, T)\nlog!(G::LieGroup, X::T, g)\n\nCompute the (Lie group) logarithmic function log_mathcal G mathcal G  mathfrak g, which is the inverse of the Lie group exponential function. For the allocating variant, you can specify the type T, when the point argument is the identity and hence does not provide the representation used. The computation can be performed in-place of X::T, which then determines the type.\n\ninfo: Naming convention\nThere are at least two different objects usually called ‚Äúlogarithm‚Äù that need to be distinguishedthe (Riemannian) logarithm map log(M, p, q) from ManifoldsBase.jl. This can be accessed here using log(base_manifold(G), p, q).\nthe logarithmic map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric log(G, g, h), which we use as a default within this package\nthe (matrix/Lie group) logarithm function log(G, h) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Random.rand!-Tuple{LieGroup, Any}","page":"Lie group","title":"Random.rand!","text":"rand(::LieGroup; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand(::LieGroup, PT::Type; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, T::Type; œÉ::Real=1.0, kwargs...)\nrand!(::LieGroup, gX::PT; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, X::T; œÉ::Real=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\nFor both cases, you can provide the type T for the tangent vector and/or point PT, if you want to generate a random point in a certain representation. For the in-place variants the type is inferred from pX¬¥ andX`, respectively.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Internal-functions-and-macros","page":"Lie group","title":"Internal functions and macros","text":"","category":"section"},{"location":"interface/group/","page":"Lie group","title":"Lie group","text":"LieGroups.CommonUnitarySubAlgebra\nLieGroups.@default_lie_group_fallbacks","category":"page"},{"location":"interface/group/#LieGroups.CommonUnitarySubAlgebra","page":"Lie group","title":"LieGroups.CommonUnitarySubAlgebra","text":"CommonUnitarySubAlgebra{ùîΩ,T}\n\nA constant that allows to refer to several sub Algebras of mathfrak u(n) for implementations where\n\ncertain sub algebras real/complex share a common implementation, e.g. for the same sizes T usually via TypeParameter\ncertain functions are the same for all sizes T as long as the field ùîΩ is the same\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#LieGroups.@default_lie_group_fallbacks","page":"Lie group","title":"LieGroups.@default_lie_group_fallbacks","text":"default_lie_group_fallbacks(TG, TF, TP, TV, pfield::Symbol, Xfield::Symbol, groupOp)\n\nIntroduce default fallbacks for all basic functions on Lie groups, for Lie group of type TG with group operation Op, points of type TP, tangent vectors of type TV, with forwarding to fields pfield and Xfield for point and tangent vector functions, respectively.\n\n\n\n\n\n","category":"macro"},{"location":"interface/group/#Literature","page":"Lie group","title":"Literature","text":"","category":"section"},{"location":"interface/group/","page":"Lie group","title":"Lie group","text":"J.¬†Hilgert and K.-H.¬†Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\nJ.¬†Sol√†, J.¬†Deray and D.¬†Atchuthan. A micro Lie theory for state estimation in robotics (Dec 2021), arXiv:1812.01537 [cs.RO], arXiv: 1812.01537.\n\n\n\n","category":"page"},{"location":"interface/algebra/#An-interface-for-Lie-algebras","page":"Lie algebra","title":"An interface for Lie algebras","text":"","category":"section"},{"location":"interface/algebra/","page":"Lie algebra","title":"Lie algebra","text":"LieAlgebra\nDefaultLieAlgebraOrthogonalBasis","category":"page"},{"location":"interface/algebra/#LieGroups.LieAlgebra","page":"Lie algebra","title":"LieGroups.LieAlgebra","text":"LieAlgebra{ùîΩ, G} <: AbstractManifold{ùîΩ}\n\nRepresent the Lie algebra mathfrak g, that is a ùîΩ vector space with an associated lie_bracket  mathfrak gmathfrak g  mathfrak g which fulfills\n\nXX = 0 for all X  mathfrak g\nThe Jacobi identity X YZ = XYZ = Y XZ holds for all X Y Z  mathfrak g.\n\nThe Lie algebras considered here are those related to a LieGroup mathcal G, namely the tangent space T_mathrmemathcal G at the Identity, this is internally just a const of the corresponding TangentSpace.\n\nnote: Convention for representing tangent vectors in the Lie algebra\nA vector field mathcal X mathcal G  Tmathcal G, X(g)  T_gmathcal G is called a left-invariant vector field if it satisfiesmathcal X(Œª_g(h)) = DŒª_g(h)mathcal X(h) quadtextfor allquad g h  mathcal Gwhere Œª_g mathcal G  mathcal G is the left multiplication by g. Hence mathcal X is determined already when X  mathfrak g is given, since mathcal X(g) = DŒª_g(e)X, cf [HN12, Definition 9.1.7].Throughout LieGroups.jl, we use this left-invariant convention to store tangent vectors at points on a Lie group as elements of the corresponding Lie algebra.\n\nConstructor\n\nLieAlgebra(G::LieGroup)\n\nReturn the Lie Algebra belonging to the LieGroup G.\n\n\n\n\n\n","category":"type"},{"location":"interface/algebra/#LieGroups.DefaultLieAlgebraOrthogonalBasis","page":"Lie algebra","title":"LieGroups.DefaultLieAlgebraOrthogonalBasis","text":"DefaultLieAlgebraOrthogonalBasis{ùîΩ} <: ManifoldsBase.AbstractOrthogonalBasis{ùîΩ,ManifoldsBase.TangentSpaceType}\n\nSpecify an orthogonal basis for a Lie algebra. This is used as the default within hat and vee.\n\nIf not specifically overwritten/implemented for a Lie group, the DefaultOrthogonalBasis at the identity_element on the `base_manifold acts as a fallback.\n\nnote: Note\nIn order to implement the corresponding get_coordinates and get_vector functions, define get_coordinates_lie(::LieGroup, p, X, B) and get_vector_lie(::LieGroup, p, X, B), resp.\n\n\n\n\n\n","category":"type"},{"location":"interface/algebra/#Functions-on-Lie-algebras","page":"Lie algebra","title":"Functions on Lie algebras","text":"","category":"section"},{"location":"interface/algebra/","page":"Lie algebra","title":"Lie algebra","text":"Modules = [LieGroups]\nPages = [\"src/Lie_algebra/Lie_algebra_interface.jl\"]\nOrder = [:function]","category":"page"},{"location":"interface/algebra/#Base.rand-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(LieGroup{ùîΩ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ})}}","page":"Lie algebra","title":"Base.rand","text":"rand(::LieGroup; vector_at=nothing, œÉ=1.0, kwargs...)\nrand(::LieAlgebra; œÉ=1.0, kwargs...)\nrand!(::LieGroup, gX; vector_at=nothing, kwargs...)\nrand!(::LieAlgebra, X; œÉ=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#LieGroups.base_lie_group-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(LieGroup{ùîΩ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ})}}","page":"Lie algebra","title":"LieGroups.base_lie_group","text":"base_lie_group(ùî§::LieAlgebra)\n\nReturn the base_lie_group of the given LieAlgebra belongs to.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#LieGroups.lie_bracket!-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(LieGroup{ùîΩ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ})}, Any, Any, Any}","page":"Lie algebra","title":"LieGroups.lie_bracket!","text":"lie_bracket!(ùî§::LieAlgebra, X, Y)\nlie_bracket!(ùî§::LieAlgebra, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g which fulfills\n\nXX = 0 for all X  mathfrak g\nThe Jacobi identity X YZ = XYZ = Y XZ holds for all X Y Z  mathfrak g.\n\nThe computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#LieGroups.lie_bracket-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(LieGroup{ùîΩ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ})}, Any, Any}","page":"Lie algebra","title":"LieGroups.lie_bracket","text":"lie_bracket!(ùî§::LieAlgebra, X, Y)\nlie_bracket!(ùî§::LieAlgebra, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g which fulfills\n\nXX = 0 for all X  mathfrak g\nThe Jacobi identity X YZ = XYZ = Y XZ holds for all X Y Z  mathfrak g.\n\nThe computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.base_manifold-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(LieGroup{ùîΩ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ})}}","page":"Lie algebra","title":"ManifoldsBase.base_manifold","text":"base_manifold(ùî§::LieAlgebra)\n\nReturn the base_manifold the LieGroup of the given LieAlgebra is based on.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.get_coordinates","page":"Lie algebra","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(ùî§::LieAlgebra, X::T, B::AbstractBasis)\nget_coordinates!(ùî§::LieAlgebra, c, X::T, B::AbstractBasis)\n\nReturn the vector of coordinates to the decomposition of X with respect to an AbstractBasis of the LieAlgebra ùî§. The operation can be performed in-place of c.\n\nBy default this function requires that identity_element(G, T) is available and calls the corresponding get_coordinates function of the Riemannian manifold the Lie group is build on.\n\nThe inverse operation is get_vector.\n\nSee also vee.\n\n\n\n\n\n","category":"function"},{"location":"interface/algebra/#ManifoldsBase.get_coordinates!","page":"Lie algebra","title":"ManifoldsBase.get_coordinates!","text":"get_coordinates(ùî§::LieAlgebra, X::T, B::AbstractBasis)\nget_coordinates!(ùî§::LieAlgebra, c, X::T, B::AbstractBasis)\n\nReturn the vector of coordinates to the decomposition of X with respect to an AbstractBasis of the LieAlgebra ùî§. The operation can be performed in-place of c.\n\nBy default this function requires that identity_element(G, T) is available and calls the corresponding get_coordinates function of the Riemannian manifold the Lie group is build on.\n\nThe inverse operation is get_vector.\n\nSee also vee.\n\n\n\n\n\n","category":"function"},{"location":"interface/algebra/#ManifoldsBase.get_vector","page":"Lie algebra","title":"ManifoldsBase.get_vector","text":"get_vector(G::LieGroup, c, B::AbstractBasis; kwargs...)\nget_vector(ùî§::LieAlgebra, c, B::AbstractBasis; kwargs...)\nget_vector!(G::LieGroup, X::T, c, B::AbstractBasis; kwargs...)\nget_vector!(ùî§::LieAlgebra, X::T, c, B::AbstractBasis; kwargs...)\n\nReturn the vector corresponding to a set of coefficients in an AbstractBasis of the LieAlgebra ùî§. Since all tangent vectors are assumed to be represented in the Lie algebra, both signatures are equivalent. The operation can be performed in-place of a tangent vector X of type ::T.\n\nBy default this function requires identity_element(G) and calls the corresponding get_vector function of the Riemannian manifold the Lie group is build on.\n\nThe inverse operation is get_coordinates.\n\nKeyword arguments\n\ntangent_vector_type specify the tangent vector type to use for the allocating variants.\n\nSee also hat\n\n\n\n\n\n","category":"function"},{"location":"interface/algebra/#ManifoldsBase.get_vector!","page":"Lie algebra","title":"ManifoldsBase.get_vector!","text":"get_vector(G::LieGroup, c, B::AbstractBasis; kwargs...)\nget_vector(ùî§::LieAlgebra, c, B::AbstractBasis; kwargs...)\nget_vector!(G::LieGroup, X::T, c, B::AbstractBasis; kwargs...)\nget_vector!(ùî§::LieAlgebra, X::T, c, B::AbstractBasis; kwargs...)\n\nReturn the vector corresponding to a set of coefficients in an AbstractBasis of the LieAlgebra ùî§. Since all tangent vectors are assumed to be represented in the Lie algebra, both signatures are equivalent. The operation can be performed in-place of a tangent vector X of type ::T.\n\nBy default this function requires identity_element(G) and calls the corresponding get_vector function of the Riemannian manifold the Lie group is build on.\n\nThe inverse operation is get_coordinates.\n\nKeyword arguments\n\ntangent_vector_type specify the tangent vector type to use for the allocating variants.\n\nSee also hat\n\n\n\n\n\n","category":"function"},{"location":"interface/algebra/#ManifoldsBase.hat!-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(LieGroup{ùîΩ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ})}, Any, Any}","page":"Lie algebra","title":"ManifoldsBase.hat!","text":"hat(G::LieAlgebra, c)\nhat(G::LieAlgebra, c, T::Type)\nhat!(G::LieAlgebra, X::T, c)\n\nCompute the hat map ()^  mathcal V  ùî§ that maps a vector of coordinates mathbfc  mathcal V, to a tangent vector X  mathfrak g. The coefficients are given with respect to a specific basis to a tangent vector in the Lie algebra\n\nX = sum_imathcal I c_iB_i\n\nwhere  B_i _imathcal I is a basis of the Lie algebra and mathcal I a corresponding index set, which is usually mathcal I= 1ldotsn . Then mathcal V = ‚Ñù^n.\n\nFor the allocating variant, you can specify the type T of the tangent vector to obtain, in case there are different representations. The first signature produces the default representation.\n\nThe computation can be performed in-place of X. The inverse of hat is vee. Technically, hat is a specific case of get_vector and is implemented using the DefaultLieAlgebraOrthogonalBasis.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.hat-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(LieGroup{ùîΩ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ})}, Any}","page":"Lie algebra","title":"ManifoldsBase.hat","text":"hat(G::LieAlgebra, c)\nhat(G::LieAlgebra, c, T::Type)\nhat!(G::LieAlgebra, X::T, c)\n\nCompute the hat map ()^  mathcal V  ùî§ that maps a vector of coordinates mathbfc  mathcal V, to a tangent vector X  mathfrak g. The coefficients are given with respect to a specific basis to a tangent vector in the Lie algebra\n\nX = sum_imathcal I c_iB_i\n\nwhere  B_i _imathcal I is a basis of the Lie algebra and mathcal I a corresponding index set, which is usually mathcal I= 1ldotsn . Then mathcal V = ‚Ñù^n.\n\nFor the allocating variant, you can specify the type T of the tangent vector to obtain, in case there are different representations. The first signature produces the default representation.\n\nThe computation can be performed in-place of X. The inverse of hat is vee. Technically, hat is a specific case of get_vector and is implemented using the DefaultLieAlgebraOrthogonalBasis.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.is_point-Union{Tuple{T}, Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(LieGroup{ùîΩ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ})}, T}} where T","page":"Lie algebra","title":"ManifoldsBase.is_point","text":"is_point(ùî§::LieAlgebra, X; kwargs...)\n\nCheck whether X is a valid point on the Lie Algebra ùî§. This falls back to checking whether X is a valid point on the tangent space at the identity_element(G) on the base_manifold(G) on the LieGroup of ùî§\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.vee!-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(LieGroup{ùîΩ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ})}, Any, Any}","page":"Lie algebra","title":"ManifoldsBase.vee!","text":"vee(ùî§::LieAlgebra, X)\nvee!(ùî§::LieAlgebra, c, X)\n\nCompute the vee map ()^ mathfrak g  mathcal V that maps a tangent vector X from the LieAlgebra \\mathfrak g to its coordinates with respect to the DefaultLieAlgebraOrthogonalBasis basis in the Lie algebra\n\nX = sum_imathcal I c_iB_i\n\nwhere  B_i _imathcal I is a basis of the Lie algebra and mathcal I a corresponding index set, which is usually mathcal I= 1ldotsn . Then mathcal V = ‚Ñù^n\n\nThe computation can be performed in-place of c. The inverse of vee is hat. Technically, vee is a specific case of get_coordinates and is implemented using the DefaultLieAlgebraOrthogonalBasis.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.vee-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(LieGroup{ùîΩ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ})}, Any}","page":"Lie algebra","title":"ManifoldsBase.vee","text":"vee(ùî§::LieAlgebra, X)\nvee!(ùî§::LieAlgebra, c, X)\n\nCompute the vee map ()^ mathfrak g  mathcal V that maps a tangent vector X from the LieAlgebra \\mathfrak g to its coordinates with respect to the DefaultLieAlgebraOrthogonalBasis basis in the Lie algebra\n\nX = sum_imathcal I c_iB_i\n\nwhere  B_i _imathcal I is a basis of the Lie algebra and mathcal I a corresponding index set, which is usually mathcal I= 1ldotsn . Then mathcal V = ‚Ñù^n\n\nThe computation can be performed in-place of c. The inverse of vee is hat. Technically, vee is a specific case of get_coordinates and is implemented using the DefaultLieAlgebraOrthogonalBasis.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.zero_vector-Union{Tuple{O}, Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s20\", M} where {var\"#s20\"<:O, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Type}} where {ùîΩ, O<:AbstractGroupOperation}","page":"Lie algebra","title":"ManifoldsBase.zero_vector","text":"zero_vector(ùî§::LieAlgebra)\nzero_vector(ùî§::LieAlgebra, T::Type)\nzero_vector!(ùî§::LieAlgebra, X::T)\n\nGenerate a zero_vector of type T in the LieAlgebra ùî§ of the LieGroup G. By default this calls zero_vector on the manifold of G at the identity_element(G,T)\n\nFor the allocating variant the type T of the zero vector can be specified.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#Random.rand!-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(LieGroup{ùîΩ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ})}, Any}","page":"Lie algebra","title":"Random.rand!","text":"rand(::LieGroup; vector_at=nothing, œÉ=1.0, kwargs...)\nrand(::LieAlgebra; œÉ=1.0, kwargs...)\nrand!(::LieGroup, gX; vector_at=nothing, kwargs...)\nrand!(::LieAlgebra, X; œÉ=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#Internal-functions-and-macros","page":"Lie algebra","title":"Internal functions and macros","text":"","category":"section"},{"location":"interface/algebra/","page":"Lie algebra","title":"Lie algebra","text":"LieGroups.@default_lie_algebra_fallbacks","category":"page"},{"location":"interface/algebra/#LieGroups.@default_lie_algebra_fallbacks","page":"Lie algebra","title":"LieGroups.@default_lie_algebra_fallbacks","text":"default_lie_algebra_fallbacks(TG, TF, Op, TV, Xfield::Symbol)\n\nIntroduce default fallbacks for all basic functions on Lie algebras, for Lie group of type TG with number system TF, an group operation Op, tangent vectors of type TV, with forwarding to fields Xfield and tangent vector functions\n\n\n\n\n\n","category":"macro"},{"location":"interface/algebra/#Literature","page":"Lie algebra","title":"Literature","text":"","category":"section"},{"location":"interface/algebra/","page":"Lie algebra","title":"Lie algebra","text":"J.¬†Hilgert and K.-H.¬†Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\n","category":"page"},{"location":"groups/unitary_group/#The-unitary-group","page":"Unitary group","title":"The unitary group","text":"","category":"section"},{"location":"groups/unitary_group/","page":"Unitary group","title":"Unitary group","text":"UnitaryGroup","category":"page"},{"location":"groups/unitary_group/#LieGroups.UnitaryGroup","page":"Unitary group","title":"LieGroups.UnitaryGroup","text":"UnitaryGroup{T}\n\nThe special orthogonal group mathrmU(n) is the Lie group consisting of the MatrixMultiplicationGroupOperation on the manifold of rotations UnitaryMatrices with absolute value of the determinant equal to one.\n\nConstructor\n\nUnitaryGroup(n::Int; kwargs...)\n\nGenerate unitary group mathrmU(n). All keyword arguments in kwargs... are passed on to Rotations as well.\n\n\n\n\n\n","category":"type"},{"location":"groups/unitary_group/","page":"Unitary group","title":"Unitary group","text":"For this Lie group, several implementations are already covered by the defaults in the generic (matrix) multiplication operation. Besides that the following methods are implemented:","category":"page"},{"location":"groups/unitary_group/","page":"Unitary group","title":"Unitary group","text":"Modules = [LieGroups]\nPages = [\"groups/unitary.jl\"]\nOrder = [:function]","category":"page"},{"location":"groups/unitary_group/#Utility-functions-and-constants","page":"Unitary group","title":"Utility functions and constants","text":"","category":"section"},{"location":"groups/unitary_group/","page":"Unitary group","title":"Unitary group","text":"LieGroups.CommonUnitarySubGroup","category":"page"},{"location":"groups/unitary_group/#LieGroups.CommonUnitarySubGroup","page":"Unitary group","title":"LieGroups.CommonUnitarySubGroup","text":"CommonUnitarySubGroup{ùîΩ,T}\n\nA constant that allows to refer to several subgroups of mathrmU(n) for implementations where\n\ncertain subgroups real/complex share a common implementation, e.g. for the same sizes T usually via TypeParameter\ncertain functions are the same for all sizes T as long as the field ùîΩ is the same\n\n\n\n\n\n","category":"type"},{"location":"groups/semidirect_product_group/#The-semidirect-product-Lie-group","page":"Semidirect product group","title":"The semidirect product Lie group","text":"","category":"section"},{"location":"groups/semidirect_product_group/","page":"Semidirect product group","title":"Semidirect product group","text":"Modules = [LieGroups]\nPages = [\"groups/semidirect_product_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/semidirect_product_group/#LieGroups.LeftSemidirectProductGroupOperation","page":"Semidirect product group","title":"LieGroups.LeftSemidirectProductGroupOperation","text":"LeftSemidirectProductGroupOperation{O1,O2,A} <: SemiDirectProductGroupOperation{O1,O2,A}\n\nA struct to model a semidirect Lie group product.\n\nLet (mathcal N ) and (mathcal H ) be two Lie groups with group operations  and , respectively, as well as a group action œÉ mathcal Hmathcal N  mathcal N, cf AbstractLeftGroupActionType.\n\nWe use here as well use the notation œÉ_h mathcal N  mathcal N as a family of maps on mathcal N\n\nThen we define a group operation  on the product manifold mathcal Nmathcal H by\n\n    (h_1n_1)  (h_2n_2) = (h_1  h_2 œÉ_h_2(n_1)  n_2)\n\nSee [HN12, Definition 9.2.22], second definition for more details.\n\nConstructor\n\nLeftSemidirectProductGroupOperation(\n    op1::AbstractGroupOperation,\n    op2::AbstractGroupOperation,\n    action::AbstractGroupActionType\n)\n\nParameters\n\nop1::AbstractGroupOperation: The group operation  on mathcal H\nop2::AbstractGroupOperation: The group operation  on mathcal N\naction::AbstractGroupActionType The group action œÉ of mathcal H on mathcal N\n\n\n\n\n\n","category":"type"},{"location":"groups/semidirect_product_group/#LieGroups.RightSemidirectProductGroupOperation","page":"Semidirect product group","title":"LieGroups.RightSemidirectProductGroupOperation","text":"RightSemidirectProductGroupOperation{O1,O2,A} <: SemiDirectProductGroupOperation{O1,O2,A}\n\nA struct to model a right semidirect Lie group product.\n\nLet (mathcal N ) and (mathcal H ) be two Lie groups with group operations  and , respectively, as well as a group action œÉ mathcal Hmathcal N  mathcal N, cf AbstractGroupActionType.\n\nWe use here as well use the notation œÉ_h mathcal N  mathcal N as a family of maps on mathcal N\n\nThen we define a group operation  on the product manifold mathcal Nmathcal H by\n\n    (n_1h_1)  (n_2h_2) = (n_1  œÉ_h_1(n_2) h_1  h_2)\n\nSee [HN12, Definition 9.2.22], first definition for more details.\n\nConstructor\n\nRightSemidirectProductGroupOperation(\n    op1::AbstractGroupOperation,\n    op2::AbstractGroupOperation,\n    action::AbstractGroupActionType\n)\n\nParameters\n\nop1::AbstractGroupOperation: The group operation  on mathcal N\nop2::AbstractGroupOperation: The group operation  on mathcal H\naction::AbstractGroupActionType: The group action œÉ of mathcal H on mathcal N\n\n\n\n\n\n","category":"type"},{"location":"groups/semidirect_product_group/#LieGroups.SemiDirectProductGroupOperation","page":"Semidirect product group","title":"LieGroups.SemiDirectProductGroupOperation","text":"SemiDirectProductGroupOperation{\n    O1<:AbstractGroupOperation,\n    O2<:AbstractGroupOperation,\n    A<:AbstractGroupActionType\n} <: AbstractProductGroupOperation\n\nAn abstract type for all semdirect product group operations.\n\n\n\n\n\n","category":"type"},{"location":"groups/semidirect_product_group/#Base.inv-Union{Tuple{M}, Tuple{Op}, Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, Op, M}, Any}} where {ùîΩ, Op<:LieGroups.SemiDirectProductGroupOperation, M<:ManifoldsBase.ProductManifold}","page":"Semidirect product group","title":"Base.inv","text":"inv(SDPG::LieGroup{ùîΩ,Op,M}, g) where {ùîΩ,Op<:SemiDirectProductGroupOperation,M<:ProductManifold}\n\nCompute the inverse element of an element g = (g_1 g_2) given by\n\ng^-1 = (g_1^-1 œÉ_g_1^-1g_2)\n\nfor the left variant and\n\ng^-1 = (œÉ_g_2^-1 g_1 g_2^-1)\n\nfor the right variant, respectively. See also [HN12, Proof of Lemma 2.2.3].\n\n\n\n\n\n","category":"method"},{"location":"groups/semidirect_product_group/#LieGroups.:‚ãâ-Tuple{LieGroup, LieGroup}","page":"Semidirect product group","title":"LieGroups.:‚ãâ","text":"L1 ‚ãâ L2\n‚ãâ(L1, L2)\n\nFor two LieGroups L1, L2, generate the LeftSemidirectProductLieGroup(L1, L2), where the corresponding default_left_action(L1, L2) is used.\n\n\n\n\n\n","category":"method"},{"location":"groups/semidirect_product_group/#LieGroups.:‚ãä-Tuple{LieGroup, LieGroup}","page":"Semidirect product group","title":"LieGroups.:‚ãä","text":"L1 ‚ãä L2\n‚ãä(L1, L2)\n\nFor two LieGroups L1, L2, generate the RightSemidirectProductLieGroup(L1, L2), where the corresponding default_right_action(L1, L2) is used.\n\n\n\n\n\n","category":"method"},{"location":"groups/semidirect_product_group/#LieGroups.LeftSemidirectProductLieGroup","page":"Semidirect product group","title":"LieGroups.LeftSemidirectProductLieGroup","text":"LeftSemidirectProductLieGroup(\n    N::LieGroup, H::LieGroup, action::AbstractGroupActionType=default_left_action(N, H)\n)\n\nGenerate the semidirect product Lie Group mathcal G = N  H for an AbstractLeftGroupActionType using the LeftSemidirectProductGroupOperation for the group operation definition as well as [HN12, Definition 9.2.22], second definition, for more details.\n\nThe short form N‚ãâH can be used if the corresponding default_left_action(N,H) is the one you want to use.\n\n\n\n\n\n","category":"function"},{"location":"groups/semidirect_product_group/#LieGroups.RightSemidirectProductLieGroup","page":"Semidirect product group","title":"LieGroups.RightSemidirectProductLieGroup","text":"RightSemidirectProductLieGroup(\n    N::LieGroup, H::LieGroup, action::AbstractGroupActionType=default_right_action(N,H)\n)\n\nGenerate the semidirect product Lie Group mathcal G = N  H for an AbstractLeftGroupActionType using the RightSemidirectProductGroupOperation for the group operation definition as well as [HN12, Definition 9.2.22], first definition, for more details.\n\nThe short form N‚ãäH can be used if the corresponding default_right_action(N,H) is the one you want to use.\n\n\n\n\n\n","category":"function"},{"location":"groups/semidirect_product_group/#Manifolds.compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, LeftSemidirectProductGroupOperation, <:ManifoldsBase.ProductManifold}, Any, Any}} where ùîΩ","page":"Semidirect product group","title":"Manifolds.compose","text":"compose(L::LieGroup{ùîΩ,LeftSemidirectProductGroupOperation}, g, h)\n\nCompute the group operation  on the semidirect product Lie group L = G  H, that is for g = (g_1h_1), h = (g_2h_2) with g_1g_2  G, h_1h_2  H this computes\n\n    (g_1h_1)  (g_2h_2) = (g_1  g_2 h_1  œÉ_g_1(h_2))\n\nwhere  denotes the group operation on L,  and  those on G and H, respectively, and œÉ is the group action specified by the AbstractGroupActionType within the LeftSemidirectProductLieGroup  L.\n\n\n\n\n\n","category":"method"},{"location":"groups/semidirect_product_group/#Manifolds.compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, RightSemidirectProductGroupOperation, <:ManifoldsBase.ProductManifold}, Any, Any}} where ùîΩ","page":"Semidirect product group","title":"Manifolds.compose","text":"compose(L::LieGroup{ùîΩ,RightSemidirectProductGroupOperation}, g, h)\n\nCompute the group operation  on the semidirect product Lie group L = G  H, that is for g = (g_1h_1), h = (g_2h_2) with g_1g_2  G, h_1h_2  H this computes\n\n    (g_1h_1)  (g_2h_2) = (g_1  œÉ_h_1(g_2) h_1  h_2)\n\nwhere  denotes the group operation on L,  and  those on G and H, respectively, and œÉ is the group action specified by the AbstractGroupActionType within the RightSemidirectProductLieGroup L.\n\n\n\n\n\n","category":"method"},{"location":"groups/general_linear/#The-general-linear-group","page":"General Linear","title":"The general linear group","text":"","category":"section"},{"location":"groups/general_linear/","page":"General Linear","title":"General Linear","text":"Modules = [LieGroups]\nPages = [\"groups/general_linear_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/general_linear/#LieGroups.GeneralLinearGroup","page":"General Linear","title":"LieGroups.GeneralLinearGroup","text":"GeneralLinearGroup{ùîΩ,T}\n\nThe general linear group mathrmGL(n) is the set of all invertible matrices\n\nmathrmGL(n) = bigl g  ùîΩ^nn big mathrmdet(p)  0bigr \nqquad ùîΩ   ‚Ñù ‚ÑÇ \n\nequipped with the MatrixMultiplicationGroupOperation as the group operation.\n\nThe set of invertible matrices is a Riemannian manifold, since it inherits its structure from the embedding as an open subset of the space of matrices ‚Ñù^nn.\n\nConstructor\n\nGeneralLinearGroup(n::Int; field=‚Ñù, kwargs...)\n\nGenerate the general linear group  group on ùîΩ^nn. All keyword arguments in kwargs... are passed on to InvertibleMatrices.\n\n\n\n\n\n","category":"type"},{"location":"groups/general_linear/#Base.exp-Tuple{GeneralLinearGroup, Any}","page":"General Linear","title":"Base.exp","text":"exp(::GeneralLinearGroup, X)\nexp!(::GeneralLinearGroup, g, X)\n\nCompute the Lie group exponential on the GeneralLinearGroup, which is given by the matrix exponential\n\nexp X = sum_k=0^ frac1kX^k\n\nsee also [HN12, Example 9.2.3 (b)]\n\n\n\n\n\n","category":"method"},{"location":"groups/general_linear/#ManifoldsBase.exp!-Tuple{GeneralLinearGroup, Any, Any}","page":"General Linear","title":"ManifoldsBase.exp!","text":"exp(::GeneralLinearGroup, X)\nexp!(::GeneralLinearGroup, g, X)\n\nCompute the Lie group exponential on the GeneralLinearGroup, which is given by the matrix exponential\n\nexp X = sum_k=0^ frac1kX^k\n\nsee also [HN12, Example 9.2.3 (b)]\n\n\n\n\n\n","category":"method"},{"location":"groups/#An-overview-of-Lie-groups","page":"List of Lie groups","title":"An overview of Lie groups","text":"","category":"section"},{"location":"groups/#Alphabetical-list-of-Lie-groups","page":"List of Lie groups","title":"Alphabetical list of Lie groups","text":"","category":"section"},{"location":"groups/","page":"List of Lie groups","title":"List of Lie groups","text":"Group Manifold  Comment\nGeneralLinearGroup InvertibleMatrices * \nHeisenbergGroup HeisenbergMatrices * \nOrthogonalGroup OrthogonalMatrices * This can be interpreted as all rotations and reflections.\nSpecialEuclideanGroup Rotations‚ãâEuclidean ‚àò Analogously you can also use a ‚ãä if you prefer tuples (t,R) having the rotation matrix in the second component\nSpecialOrthogonalGroup Rotations * \nSpecialUnitaryGroup GeneralUnitaryMatrices * \nTranslationGroup Euclidean + \nUnitaryGroup UnitaryMatrices * ","category":"page"},{"location":"groups/power_group/#The-power-Lie-group","page":"Power group","title":"The power Lie group","text":"","category":"section"},{"location":"groups/power_group/","page":"Power group","title":"Power group","text":"Modules = [LieGroups]\nPages = [\"groups/power_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/power_group/#LieGroups.PowerGroupOperation","page":"Power group","title":"LieGroups.PowerGroupOperation","text":"PowerGroupOperation{O<:AbstractGroupOperation} <: AbstractGroupOperation\n\nA struct do model a that a certain group operation is applied element-wise on a PowerManifold.\n\nConstructor\n\nPowerGroupOperation(o::AbstractGroupOperation)\n\n\n\n\n\n","category":"type"},{"location":"groups/power_group/#LieGroups.PowerLieGroup-Tuple{ManifoldsBase.AbstractManifold, Vararg{Any}}","page":"Power group","title":"LieGroups.PowerLieGroup","text":"PowerLieGroup(G::LieGroup, args...; kwargs...)\n(G::LieGroup)^(n::Integer) = PowerLieGroup(G, n)\n\nGenerate the LieGroup of the n-th power of a Lie group G or manifold M. If passed a Lie group G, the group operation on the PowerLieGroup is the same as on G, but applied elementwise. Internally, the corresponding PowerGroupOperation is created. If you pass a manifold M, you have to provide the corresponding PowerGroupOperation yourself.\n\nBot the arguments args... as well as the keyword arguments kwargs... are passed on to the constructor of the PowerManifold. This especially includes the size of the manifold and allows to specify a NestedPowerRepresentation.\n\n\n\n\n\n","category":"method"},{"location":"groups/power_group/","page":"Power group","title":"Power group","text":"On power Lie groups, all functions work element-wise, so for their formulae, check the corresponding single Lie group for details.","category":"page"},{"location":"groups/heisenberg_group/#The-Heisenberg-group","page":"Heisenberg","title":"The Heisenberg group","text":"","category":"section"},{"location":"groups/heisenberg_group/","page":"Heisenberg","title":"Heisenberg","text":"Modules = [LieGroups]\nPages = [\"groups/heisenberg_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/heisenberg_group/#LieGroups.HeisenbergGroup","page":"Heisenberg","title":"LieGroups.HeisenbergGroup","text":"HeisenbergGroup{T}\n\nThe HeisenbergGroup(n) is the group of (n+2)(n+2) matrices, see also [BP08] or Heisenberg group where T specifies the eltype of the matrix entries.\n\nbeginpmatrix 1  mathbfa^mathrmT  c mathbf0_n  I_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix\n\nwhere I_n is the nn unit matrix, mathbfa mathbfb  ‚Ñù^n are vectors of length n, mathbf0_n is the zero vector of length n, and c  ‚Ñù is a real number. The group operation is matrix multiplication.\n\nThe Lie algebra consists of the elements\n\nbeginpmatrix 0  mathbfa^mathrmT  c mathbf0_n  Z_n  mathbfb 0  mathbf0_n^mathrmT  0endpmatrix\n\nwhere additionally Z_n denotes the nn zero matrix.\n\n\n\n\n\n","category":"type"},{"location":"groups/heisenberg_group/#Base.exp-Tuple{HeisenbergGroup, Any, Any}","page":"Heisenberg","title":"Base.exp","text":"exp(G::HeisenbergGroup, g, X)\n\nExponential map on the HeisenbergGroup G with the left-invariant metric.\n\nWe denote by g a point on the Heisenberg group and by X a vector from the Lie algebra. These are of the form\n\ng = beginpmatrix 1  mathbfa^mathrmT  c mathbf0_n  I_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix\nqquad\nX = beginpmatrix 0  mathbfd^mathrmT  f mathbf0_n  Z_n  mathbfe 0  mathbf0_n^mathrmT  0endpmatrix\n\nwhere I_n is the nn unit matrix, Z_n is the nn zero matrix, mathbfa mathbfb mathbfd mathbfe  ‚Ñù^n are vectors of length n, mathbf0_n is the zero vector of length n, and cf  ‚Ñù are real numbers.\n\nThen the formula reads\n\nexp_g(X) =\nbeginpmatrix 1  (mathbfa+mathbfd)^mathrmT  c+f+frac12mathbfd^mathrmTmathbfe + mathbfa^mathrmTmathbfe mathbf0_n  I_n  mathbfb+mathbfe 0  mathbf0_n^mathrmT  1endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#Base.exp-Tuple{HeisenbergGroup, Any}","page":"Heisenberg","title":"Base.exp","text":"exp(G::HeisenbergGroup, X)\nexp!(G::HeisenbergGroup, g, X)\n\nCompute the Lie group exponential for the HeisenbergGroup G of the vector X.\n\nFor X = beginpmatrix 0  mathbfa^mathrmT  c mathbf0_n  Z_n  mathbfb 0  mathbf0_n^mathrmT  0endpmatrix from the Lie algebra of the Heisenberg group, where mathbfa mathbfb  ‚Ñù^n vectors of length n, mathbf0_n is the zero vector of length n, c  ‚Ñù, and Z_n denotes the nn zero matrix.\n\nThen the\n\nexp_mathcal G(X) =\nbeginpmatrix 1  mathbfa^mathrmT  c + frac12mathbfa^mathrmTmathbfb mathbf0_n  I_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix\n\nwhere I_n is the nn unit matrix.\n\nThis can be computed in-place of the Lie group element g.\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#Base.log-Tuple{HeisenbergGroup, Any, Any}","page":"Heisenberg","title":"Base.log","text":"log(G::HeisenbergGroup, g, h)\n\nCompute the logarithmic map on the HeisenbergGroup group.\n\nWe denote two points g h from the Heisenberg by\n\ng = beginpmatrix 1  mathbfa^mathrmT  c mathbf0_n  I_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix\nqquad\nh = beginpmatrix 1  mathbfd^mathrmT  f mathbf0_n  I_n  mathbfe 0  mathbf0_n^mathrmT  1endpmatrix\n\nwhere I_n is the nn unit matrix, mathbfa mathbfb mathbfd mathbfe  ‚Ñù^n are vectors of length n, mathbf0_n is the zero vector of length n, and cf  ‚Ñù are real numbers.\n\nThen formula reads\n\nlog_g(h) = beginpmatrix 0  (mathbfd-mathbfq)^mathrmT  f - c + mathbfa^mathrmTmathbfb - mathbfd^mathrmTmathbfe - frac12(mathbfd-mathbfa)^mathrmT(mathbfe-mathbfb) mathbf0_n  Z_n  mathbfe - mathbfb 0  mathbf0_n^mathrmT  0endpmatrix\n\nwhere additionally Z_n denotes the nn zero matrix.\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#Base.log-Tuple{HeisenbergGroup, Any}","page":"Heisenberg","title":"Base.log","text":"log(G::HeisenbergGroup, g)\nlog!(G::HeisenbergGroup, X, g)\n\nCompute the Lie group logarithm for the HeisenbergGroup G.\n\nFor g = beginpmatrix 1  mathbfa^mathrmT  c mathbf0_n  I_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix from the Lie algebra of the Heisenberg group, where mathbfa mathbfb  ‚Ñù^n vectors of length n, mathbf0_n is the zero vector of length n, c  ‚Ñù, and I_n is the nn unit matrix.\n\nThen the\n\nlog_mathcal G(g) =\nbeginpmatrix 1  mathbfa^mathrmT  c - frac12mathbfa^mathrmTmathbfb mathbf0_n  Z_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix\n\nwhere Z_n denotes the nn zero matrix.\n\nThis can be computed in-place of the Lie algebra vector X.\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#ManifoldsBase.injectivity_radius-Tuple{HeisenbergGroup}","page":"Heisenberg","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(G::HeisenbergGroup)\n\nReturn the injectivity radius on the HeisenbergGroup G, which is .\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#Literature","page":"Heisenberg","title":"Literature","text":"","category":"section"},{"location":"groups/heisenberg_group/","page":"Heisenberg","title":"Heisenberg","text":"E.¬†Biny and S.¬†Pods. The Geometry of Heisenberg Groups: With Applications in Signal Theory, Optics, Quantization, and Field Quantization (American Mathematical Society, 2008).\n\n\n\n","category":"page"},{"location":"groups/product_group/#The-product-Lie-group","page":"Product group","title":"The product Lie group","text":"","category":"section"},{"location":"groups/product_group/","page":"Product group","title":"Product group","text":"Modules = [LieGroups]\nPages = [\"groups/product_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/product_group/#LieGroups.AbstractProductGroupOperation","page":"Product group","title":"LieGroups.AbstractProductGroupOperation","text":"AbstractProductGroupOperation <: AbstractGroupOperation\n\nAn abstract type to model group operations on a product manifold\n\n\n\n\n\n","category":"type"},{"location":"groups/product_group/#LieGroups.ProductGroupOperation","page":"Product group","title":"LieGroups.ProductGroupOperation","text":"ProductGroupOperation{O<:NTuple{N,AbstractGroupOperation} where N} <: AbstractProductGroupOperation\n\nA struct do model a tuple of group operations, one for each factor of a product group, that together forms a new group operation.\n\nAccess to the single operations can be done by pgo[i].\n\nConstructor\n\nProductGroupOperation(o::AbstractGroupOperation...)\n√ó(o::AbstractGroupOperation...) = ProductGroupOperation(o...)\n\n\n\n\n\n","category":"type"},{"location":"groups/product_group/#LieGroups.ProductLieGroup-Tuple{LieGroup, LieGroup}","page":"Product group","title":"LieGroups.ProductLieGroup","text":"ProductLieGroup(G, H, ...)\n\nReturn the LieGroup of the product of Lie groups G and H.\n\nAlternatively, the short hand G √ó H can be used.\n\n\n\n\n\n","category":"method"},{"location":"groups/product_group/#LinearAlgebra.cross-Tuple{Vararg{AbstractGroupOperation}}","page":"Product group","title":"LinearAlgebra.cross","text":"cross(O1::AbstractGroupOperation, O2::AbstractGroupOperation)\nO1 √ó O2\nO1 √ó O2 √ó O3 √ó ...\n\nReturn the ProductGroupOperation For two AbstractGroupOperation` O1 and O2, where for the case that one of them is a ProductGroupOperation itself, the other is either prepended (if O1 is a product) or appended (if O2 is). If both are product operations, they are combined into one, keeping the order of operations.\n\nFor the case that more than two are concatenated with √ó this is iterated.\n\n\n\n\n\n","category":"method"},{"location":"groups/product_group/#LinearAlgebra.cross-Tuple{Vararg{LieGroup}}","page":"Product group","title":"LinearAlgebra.cross","text":"cross(G::LieGroup, H::LieGroup)\nG √ó H\nG1 √ó G2 √ó G3 √ó ...\n\nReturn the ProductLieGroup For two LieGroups G and H, where for the case that one of them is a ProductLieGroup itself, the other is either prepended (if H is a product) or appended (if G is). If both are product Lie groups, they are combined into one, keeping the order of operations.\n\nFor the case that more than two are concatenated with √ó this is iterated.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#The-special-orthogonal-group","page":"Special orthogonal group","title":"The special orthogonal group","text":"","category":"section"},{"location":"groups/special_orthogonal_group/","page":"Special orthogonal group","title":"Special orthogonal group","text":"SpecialOrthogonalGroup","category":"page"},{"location":"groups/special_orthogonal_group/#LieGroups.SpecialOrthogonalGroup","page":"Special orthogonal group","title":"LieGroups.SpecialOrthogonalGroup","text":"SpecialOrthogonalGroup{T}\n\nThe special orthogonal group mathrmSO(n) is the Lie group consisting of the MatrixMultiplicationGroupOperation on the manifold of rotations Rotations.\n\nConstructor\n\nSpecialOrthogonalGroup(n::Int; kwargs...)\n\nGenerate  special orthogonal group mathrmSO(n). All keyword arguments in kwargs... are passed on to Rotations as well.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_orthogonal_group/","page":"Special orthogonal group","title":"Special orthogonal group","text":"For this Lie group, several implementations are already covered by the defaults in the generic (matrix) multiplication operation.","category":"page"},{"location":"groups/special_orthogonal_group/#Functions","page":"Special orthogonal group","title":"Functions","text":"","category":"section"},{"location":"groups/special_orthogonal_group/","page":"Special orthogonal group","title":"Special orthogonal group","text":"Modules = [LieGroups]\nPages = [\"groups/special_orthogonal_group.jl\"]\nOrder = [:function]","category":"page"},{"location":"groups/special_orthogonal_group/#Base.exp-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any}","page":"Special orthogonal group","title":"Base.exp","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, these simplify for the case of 22 matrices to X=beginpmatrix 0  -Œ± Œ±  0endpmatrix, for some Œ±‚Ñù.\n\nTheir exponential is\n\nexp_mathcal G(X) =  beginpmatrix cos(Œ±)  -sin(Œ±) sin(Œ±)  cos(Œ±)endpmatrix\n\nThis result can be computed in-place of g.\n\nNote that since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#Base.exp-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any}","page":"Special orthogonal group","title":"Base.exp","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, the 33 skew symmetric matrices are of the form\n\n    X = beginpmatrix 0  -c  b c  0  -a -b  a  0endpmatrix\n\nfor some a b c  ‚Ñù. To compute the exponential, the Rodrigues' rotation formula can be used. With Œ± = sqrta^2+b^2+c^2 = frac1sqrt2lVert X rVert_ we obtain for Œ±  0\n\nexp_mathcal G(X) = I_3 + fracsinŒ±X + frac(1 - cos)Œ±^2X^2\n\nand \\exp{\\mathcal G}(X) = I3`` otherwise.\n\nThis result can be computed in-place of g.\n\nNote that since mathrmSO(3) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#Base.exp-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any}","page":"Special orthogonal group","title":"Base.exp","text":"exp(G, e, X)\nexp!(G, e, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSimilar to the 33 case, an efficient computation is provided, adapted from [GX02], [AR13] with a few numerical stabilisations.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#Base.log-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any}","page":"Special orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nFor the two-dimensional case, any rotation matrix g can be represented as beginpmatrix cos(Œ±)  -sin(Œ±) sin(Œ±)  cos(Œ±)endpmatrix. For the SpecialOrthogonalGroup, g might also include reflections.\n\nThe logarithm is then\n\nlog_mathcal G(g) =  beginpmatrix 0  Œ± -Œ±  0endpmatrix\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#Base.log-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any}","page":"Special orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nHere, exp_mathcal G(X) = g is inverted using the Rodrigues' rotation formula\n\nexp_mathcal G(X) = I_3 + fracsinŒ±X + frac(1 - cos)Œ±^2X^2\n\nFor Œ±   0 œÄ  we obtain X from the observation that\n\nmathrmtr(g) = 1 + 2cos(Œ±)\nqquadtext and qquad\nfrac12(g-g^mathrmT) = sin(Œ±)X\n\nFor Œ± = 0 we have g = I_3 and X = 0.\n\nFor Œ± = œÄ we have to solve X^2 = frac12(g-I_3), where X is skew-symmetric and hence we have to solve for three unknowns.\n\nlog_mathcal G(g) = X\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(3) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#Base.log-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any}","page":"Special orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nThe implementation is based on a generalized variant of the Rodrigues' like formula. For details, see [GX02, Section 3].\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.exp!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, these simplify for the case of 22 matrices to X=beginpmatrix 0  -Œ± Œ±  0endpmatrix, for some Œ±‚Ñù.\n\nTheir exponential is\n\nexp_mathcal G(X) =  beginpmatrix cos(Œ±)  -sin(Œ±) sin(Œ±)  cos(Œ±)endpmatrix\n\nThis result can be computed in-place of g.\n\nNote that since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.exp!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, the 33 skew symmetric matrices are of the form\n\n    X = beginpmatrix 0  -c  b c  0  -a -b  a  0endpmatrix\n\nfor some a b c  ‚Ñù. To compute the exponential, the Rodrigues' rotation formula can be used. With Œ± = sqrta^2+b^2+c^2 = frac1sqrt2lVert X rVert_ we obtain for Œ±  0\n\nexp_mathcal G(X) = I_3 + fracsinŒ±X + frac(1 - cos)Œ±^2X^2\n\nand \\exp{\\mathcal G}(X) = I3`` otherwise.\n\nThis result can be computed in-place of g.\n\nNote that since mathrmSO(3) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.exp!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, e, X)\nexp!(G, e, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSimilar to the 33 case, an efficient computation is provided, adapted from [GX02], [AR13] with a few numerical stabilisations.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.get_coordinates!-Tuple{SpecialOrthogonalGroup, Any, Identity{MatrixMultiplicationGroupOperation}, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Special orthogonal group","title":"ManifoldsBase.get_coordinates!","text":"get_coordinates(ùî§::OrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates(G::SpecialOrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::OrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::SpecialOrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the vector of coordinates c  ‚Ñù^d from the Lie algebra tangent vector X  ùî¨(n) of the OrthogonalGroup O(n) in the DefaultLieAlgebraOrthogonalBasis, where d is the dimension of the Lie algebra. This is also the version used in vee.\n\nFor O(2) there is only one coefficient Œ± in the basis beginpmatrix 0  -Œ± Œ±  0endpmatrix, which is returned as c = (Œ±)^mathrmT.\n\nA usual basis representation of ``ùî¨(3) is given by\n\n    X = beginpmatrix 0  -Œ≥  Œ≤ Œ≥  0  -Œ± -Œ≤  Œ±  0endpmatrix\n\nhence the coordinate vector is c = (Œ± Œ≤ Œ≥)^mathrmT  ‚Ñù^3.\n\nFor n ‚â• 4the lower triangular part is added toc` row-wise.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.get_coordinates-Tuple{SpecialOrthogonalGroup, Identity{MatrixMultiplicationGroupOperation}, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Special orthogonal group","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(ùî§::OrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates(G::SpecialOrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::OrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::SpecialOrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the vector of coordinates c  ‚Ñù^d from the Lie algebra tangent vector X  ùî¨(n) of the OrthogonalGroup O(n) in the DefaultLieAlgebraOrthogonalBasis, where d is the dimension of the Lie algebra. This is also the version used in vee.\n\nFor O(2) there is only one coefficient Œ± in the basis beginpmatrix 0  -Œ± Œ±  0endpmatrix, which is returned as c = (Œ±)^mathrmT.\n\nA usual basis representation of ``ùî¨(3) is given by\n\n    X = beginpmatrix 0  -Œ≥  Œ≤ Œ≥  0  -Œ± -Œ≤  Œ±  0endpmatrix\n\nhence the coordinate vector is c = (Œ± Œ≤ Œ≥)^mathrmT  ‚Ñù^3.\n\nFor n ‚â• 4the lower triangular part is added toc` row-wise.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.get_vector!-Tuple{SpecialOrthogonalGroup, Any, Identity{MatrixMultiplicationGroupOperation}, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Special orthogonal group","title":"ManifoldsBase.get_vector!","text":"get_vector(G::OrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector(G::SpecialOrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::OrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::SpecialOrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the tangent vector X  ùî¨(n) based on a vector of coordinates c  ‚Ñù^d, where d is the dimension of the Lie algebra of the OrthogonalGroup O(n) and the coordinates are with respect to the DefaultLieAlgebraOrthogonalBasis. This is also the version used in hat.\n\nFor O(2) there is only one coefficient ``c = (Œ±)^mathrmT and hence X = beginpmatrix 0  -Œ± Œ±  0endpmatrix is returned.\n\nFor n=3 a usual representtion turns c = (Œ± Œ≤ Œ≥)^mathrmT  ‚Ñù^3 into\n\n    X = beginpmatrix 0  -Œ≥  Œ≤ Œ≥  0  -Œ± -Œ≤  Œ±  0endpmatrix\n\nhence the coordinate vector is .\n\nFor n ‚â• 4` all further coefficients are used to fill up the following rows of the lower triangular part ‚Äì which determines the upper triangular part due to skew-symmetry\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.get_vector-Tuple{SpecialOrthogonalGroup, Identity{MatrixMultiplicationGroupOperation}, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Special orthogonal group","title":"ManifoldsBase.get_vector","text":"get_vector(G::OrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector(G::SpecialOrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::OrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::SpecialOrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the tangent vector X  ùî¨(n) based on a vector of coordinates c  ‚Ñù^d, where d is the dimension of the Lie algebra of the OrthogonalGroup O(n) and the coordinates are with respect to the DefaultLieAlgebraOrthogonalBasis. This is also the version used in hat.\n\nFor O(2) there is only one coefficient ``c = (Œ±)^mathrmT and hence X = beginpmatrix 0  -Œ± Œ±  0endpmatrix is returned.\n\nFor n=3 a usual representtion turns c = (Œ± Œ≤ Œ≥)^mathrmT  ‚Ñù^3 into\n\n    X = beginpmatrix 0  -Œ≥  Œ≤ Œ≥  0  -Œ± -Œ≤  Œ±  0endpmatrix\n\nhence the coordinate vector is .\n\nFor n ‚â• 4` all further coefficients are used to fill up the following rows of the lower triangular part ‚Äì which determines the upper triangular part due to skew-symmetry\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.log!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nFor the two-dimensional case, any rotation matrix g can be represented as beginpmatrix cos(Œ±)  -sin(Œ±) sin(Œ±)  cos(Œ±)endpmatrix. For the SpecialOrthogonalGroup, g might also include reflections.\n\nThe logarithm is then\n\nlog_mathcal G(g) =  beginpmatrix 0  Œ± -Œ±  0endpmatrix\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.log!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nHere, exp_mathcal G(X) = g is inverted using the Rodrigues' rotation formula\n\nexp_mathcal G(X) = I_3 + fracsinŒ±X + frac(1 - cos)Œ±^2X^2\n\nFor Œ±   0 œÄ  we obtain X from the observation that\n\nmathrmtr(g) = 1 + 2cos(Œ±)\nqquadtext and qquad\nfrac12(g-g^mathrmT) = sin(Œ±)X\n\nFor Œ± = 0 we have g = I_3 and X = 0.\n\nFor Œ± = œÄ we have to solve X^2 = frac12(g-I_3), where X is skew-symmetric and hence we have to solve for three unknowns.\n\nlog_mathcal G(g) = X\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(3) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.log!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nThe implementation is based on a generalized variant of the Rodrigues' like formula. For details, see [GX02, Section 3].\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#The-orthogonal-group","page":"Orthogonal group","title":"The orthogonal group","text":"","category":"section"},{"location":"groups/orthogonal_group/","page":"Orthogonal group","title":"Orthogonal group","text":"OrthogonalGroup","category":"page"},{"location":"groups/orthogonal_group/#LieGroups.OrthogonalGroup","page":"Orthogonal group","title":"LieGroups.OrthogonalGroup","text":"OrthogonalGroup{T}\n\nThe orthogonal group mathrmO(n) is the Lie group consisting of the MatrixMultiplicationGroupOperation on the manifold of rotations OrthogonalMatrices.\n\nConstructor\n\nOrthogonalGroup(n::Int; kwargs...)\n\nGenerate  orthogonal group mathrmO(n). All keyword arguments in kwargs... are passed on to OrthogonalMatrices as well.\n\n\n\n\n\n","category":"type"},{"location":"groups/orthogonal_group/","page":"Orthogonal group","title":"Orthogonal group","text":"For this Lie group, several implementations are already covered by the defaults in the generic (matrix) multiplication operation.","category":"page"},{"location":"groups/orthogonal_group/#Functions","page":"Orthogonal group","title":"Functions","text":"","category":"section"},{"location":"groups/orthogonal_group/","page":"Orthogonal group","title":"Orthogonal group","text":"Modules = [LieGroups]\nPages = [\"groups/orthogonal_group.jl\"]\nOrder = [:function]","category":"page"},{"location":"groups/orthogonal_group/#Base.exp-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any}","page":"Orthogonal group","title":"Base.exp","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, these simplify for the case of 22 matrices to X=beginpmatrix 0  -Œ± Œ±  0endpmatrix, for some Œ±‚Ñù.\n\nTheir exponential is\n\nexp_mathcal G(X) =  beginpmatrix cos(Œ±)  -sin(Œ±) sin(Œ±)  cos(Œ±)endpmatrix\n\nThis result can be computed in-place of g.\n\nNote that since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Base.exp-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any}","page":"Orthogonal group","title":"Base.exp","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, the 33 skew symmetric matrices are of the form\n\n    X = beginpmatrix 0  -c  b c  0  -a -b  a  0endpmatrix\n\nfor some a b c  ‚Ñù. To compute the exponential, the Rodrigues' rotation formula can be used. With Œ± = sqrta^2+b^2+c^2 = frac1sqrt2lVert X rVert_ we obtain for Œ±  0\n\nexp_mathcal G(X) = I_3 + fracsinŒ±X + frac(1 - cos)Œ±^2X^2\n\nand \\exp{\\mathcal G}(X) = I3`` otherwise.\n\nThis result can be computed in-place of g.\n\nNote that since mathrmSO(3) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Base.exp-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any}","page":"Orthogonal group","title":"Base.exp","text":"exp(G, e, X)\nexp!(G, e, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSimilar to the 33 case, an efficient computation is provided, adapted from [GX02], [AR13] with a few numerical stabilisations.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Base.log-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any}","page":"Orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nFor the two-dimensional case, any rotation matrix g can be represented as beginpmatrix cos(Œ±)  -sin(Œ±) sin(Œ±)  cos(Œ±)endpmatrix. For the SpecialOrthogonalGroup, g might also include reflections.\n\nThe logarithm is then\n\nlog_mathcal G(g) =  beginpmatrix 0  Œ± -Œ±  0endpmatrix\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Base.log-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any}","page":"Orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nHere, exp_mathcal G(X) = g is inverted using the Rodrigues' rotation formula\n\nexp_mathcal G(X) = I_3 + fracsinŒ±X + frac(1 - cos)Œ±^2X^2\n\nFor Œ±   0 œÄ  we obtain X from the observation that\n\nmathrmtr(g) = 1 + 2cos(Œ±)\nqquadtext and qquad\nfrac12(g-g^mathrmT) = sin(Œ±)X\n\nFor Œ± = 0 we have g = I_3 and X = 0.\n\nFor Œ± = œÄ we have to solve X^2 = frac12(g-I_3), where X is skew-symmetric and hence we have to solve for three unknowns.\n\nlog_mathcal G(g) = X\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(3) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Base.log-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any}","page":"Orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nThe implementation is based on a generalized variant of the Rodrigues' like formula. For details, see [GX02, Section 3].\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.exp!-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, these simplify for the case of 22 matrices to X=beginpmatrix 0  -Œ± Œ±  0endpmatrix, for some Œ±‚Ñù.\n\nTheir exponential is\n\nexp_mathcal G(X) =  beginpmatrix cos(Œ±)  -sin(Œ±) sin(Œ±)  cos(Œ±)endpmatrix\n\nThis result can be computed in-place of g.\n\nNote that since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.exp!-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, the 33 skew symmetric matrices are of the form\n\n    X = beginpmatrix 0  -c  b c  0  -a -b  a  0endpmatrix\n\nfor some a b c  ‚Ñù. To compute the exponential, the Rodrigues' rotation formula can be used. With Œ± = sqrta^2+b^2+c^2 = frac1sqrt2lVert X rVert_ we obtain for Œ±  0\n\nexp_mathcal G(X) = I_3 + fracsinŒ±X + frac(1 - cos)Œ±^2X^2\n\nand \\exp{\\mathcal G}(X) = I3`` otherwise.\n\nThis result can be computed in-place of g.\n\nNote that since mathrmSO(3) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.exp!-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, e, X)\nexp!(G, e, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSimilar to the 33 case, an efficient computation is provided, adapted from [GX02], [AR13] with a few numerical stabilisations.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.get_coordinates!-Tuple{ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, OrthogonalGroup{T}, Identity{MatrixMultiplicationGroupOperation}} where T, Any, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Orthogonal group","title":"ManifoldsBase.get_coordinates!","text":"get_coordinates(ùî§::OrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates(G::SpecialOrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::OrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::SpecialOrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the vector of coordinates c  ‚Ñù^d from the Lie algebra tangent vector X  ùî¨(n) of the OrthogonalGroup O(n) in the DefaultLieAlgebraOrthogonalBasis, where d is the dimension of the Lie algebra. This is also the version used in vee.\n\nFor O(2) there is only one coefficient Œ± in the basis beginpmatrix 0  -Œ± Œ±  0endpmatrix, which is returned as c = (Œ±)^mathrmT.\n\nA usual basis representation of ``ùî¨(3) is given by\n\n    X = beginpmatrix 0  -Œ≥  Œ≤ Œ≥  0  -Œ± -Œ≤  Œ±  0endpmatrix\n\nhence the coordinate vector is c = (Œ± Œ≤ Œ≥)^mathrmT  ‚Ñù^3.\n\nFor n ‚â• 4the lower triangular part is added toc` row-wise.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.get_coordinates-Tuple{ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, OrthogonalGroup{T}, Identity{MatrixMultiplicationGroupOperation}} where T, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Orthogonal group","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(ùî§::OrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates(G::SpecialOrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::OrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::SpecialOrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the vector of coordinates c  ‚Ñù^d from the Lie algebra tangent vector X  ùî¨(n) of the OrthogonalGroup O(n) in the DefaultLieAlgebraOrthogonalBasis, where d is the dimension of the Lie algebra. This is also the version used in vee.\n\nFor O(2) there is only one coefficient Œ± in the basis beginpmatrix 0  -Œ± Œ±  0endpmatrix, which is returned as c = (Œ±)^mathrmT.\n\nA usual basis representation of ``ùî¨(3) is given by\n\n    X = beginpmatrix 0  -Œ≥  Œ≤ Œ≥  0  -Œ± -Œ≤  Œ±  0endpmatrix\n\nhence the coordinate vector is c = (Œ± Œ≤ Œ≥)^mathrmT  ‚Ñù^3.\n\nFor n ‚â• 4the lower triangular part is added toc` row-wise.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.get_vector!-Tuple{ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, OrthogonalGroup{T}, Identity{MatrixMultiplicationGroupOperation}} where T, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Orthogonal group","title":"ManifoldsBase.get_vector!","text":"get_vector(G::OrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector(G::SpecialOrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::OrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::SpecialOrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the tangent vector X  ùî¨(n) based on a vector of coordinates c  ‚Ñù^d, where d is the dimension of the Lie algebra of the OrthogonalGroup O(n) and the coordinates are with respect to the DefaultLieAlgebraOrthogonalBasis. This is also the version used in hat.\n\nFor O(2) there is only one coefficient ``c = (Œ±)^mathrmT and hence X = beginpmatrix 0  -Œ± Œ±  0endpmatrix is returned.\n\nFor n=3 a usual representtion turns c = (Œ± Œ≤ Œ≥)^mathrmT  ‚Ñù^3 into\n\n    X = beginpmatrix 0  -Œ≥  Œ≤ Œ≥  0  -Œ± -Œ≤  Œ±  0endpmatrix\n\nhence the coordinate vector is .\n\nFor n ‚â• 4` all further coefficients are used to fill up the following rows of the lower triangular part ‚Äì which determines the upper triangular part due to skew-symmetry\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.get_vector-Tuple{ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, OrthogonalGroup{T}, Identity{MatrixMultiplicationGroupOperation}} where T, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Orthogonal group","title":"ManifoldsBase.get_vector","text":"get_vector(G::OrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector(G::SpecialOrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::OrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::SpecialOrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the tangent vector X  ùî¨(n) based on a vector of coordinates c  ‚Ñù^d, where d is the dimension of the Lie algebra of the OrthogonalGroup O(n) and the coordinates are with respect to the DefaultLieAlgebraOrthogonalBasis. This is also the version used in hat.\n\nFor O(2) there is only one coefficient ``c = (Œ±)^mathrmT and hence X = beginpmatrix 0  -Œ± Œ±  0endpmatrix is returned.\n\nFor n=3 a usual representtion turns c = (Œ± Œ≤ Œ≥)^mathrmT  ‚Ñù^3 into\n\n    X = beginpmatrix 0  -Œ≥  Œ≤ Œ≥  0  -Œ± -Œ≤  Œ±  0endpmatrix\n\nhence the coordinate vector is .\n\nFor n ‚â• 4` all further coefficients are used to fill up the following rows of the lower triangular part ‚Äì which determines the upper triangular part due to skew-symmetry\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.log!-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nFor the two-dimensional case, any rotation matrix g can be represented as beginpmatrix cos(Œ±)  -sin(Œ±) sin(Œ±)  cos(Œ±)endpmatrix. For the SpecialOrthogonalGroup, g might also include reflections.\n\nThe logarithm is then\n\nlog_mathcal G(g) =  beginpmatrix 0  Œ± -Œ±  0endpmatrix\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.log!-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nHere, exp_mathcal G(X) = g is inverted using the Rodrigues' rotation formula\n\nexp_mathcal G(X) = I_3 + fracsinŒ±X + frac(1 - cos)Œ±^2X^2\n\nFor Œ±   0 œÄ  we obtain X from the observation that\n\nmathrmtr(g) = 1 + 2cos(Œ±)\nqquadtext and qquad\nfrac12(g-g^mathrmT) = sin(Œ±)X\n\nFor Œ± = 0 we have g = I_3 and X = 0.\n\nFor Œ± = œÄ we have to solve X^2 = frac12(g-I_3), where X is skew-symmetric and hence we have to solve for three unknowns.\n\nlog_mathcal G(g) = X\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(3) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.log!-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nThe implementation is based on a generalized variant of the Rodrigues' like formula. For details, see [GX02, Section 3].\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Utility-functions","page":"Orthogonal group","title":"Utility functions","text":"","category":"section"},{"location":"groups/orthogonal_group/","page":"Orthogonal group","title":"Orthogonal group","text":"LieGroups.angles_4d_skew_sym_matrix\nLieGroups.cos_angles_4d_rotation_matrix\nLieGroups.log_safe!\nLieGroups.usinc_from_cos","category":"page"},{"location":"groups/orthogonal_group/#LieGroups.angles_4d_skew_sym_matrix","page":"Orthogonal group","title":"LieGroups.angles_4d_skew_sym_matrix","text":"angles_4d_skew_sym_matrix(A)\n\nThe Lie algebra ùî∞ùî¨(4) of OrthogonalGroup(4) in ‚Ñù^44, consists of 44 skew-symmetric matrices. The unique imaginary components of their eigenvalues are the angles of the two plane rotations. This function computes these more efficiently than eigvals.\n\nBy convention, the returned values are sorted in decreasing order. See also cos_angles_4d_rotation_matrix.\n\n\n\n\n\n","category":"function"},{"location":"groups/orthogonal_group/#LieGroups.cos_angles_4d_rotation_matrix","page":"Orthogonal group","title":"LieGroups.cos_angles_4d_rotation_matrix","text":"cos_angles_4d_rotation_matrix(R)\n\n4D rotations can be described by two orthogonal planes that are unchanged by the action of the rotation (vectors within a plane rotate only within the plane). The cosines of the two angles Œ±Œ≤ of rotation about these planes may be obtained from the distinct real parts of the eigenvalues of the rotation matrix. This function computes these more efficiently by solving the system\n\nbeginaligned cosŒ± + cosŒ≤ = frac12mathrmtr(R) cosŒ± cosŒ≤ = frac18mathrmtr(R)^2 - frac116mathrmtr((R - R^T)^2) - 1endaligned\n\nBy convention, the returned values are sorted in decreasing order. See also angles_4d_skew_sym_matrix.\n\n\n\n\n\n","category":"function"},{"location":"groups/orthogonal_group/#LieGroups.log_safe!","page":"Orthogonal group","title":"LieGroups.log_safe!","text":"log_safe!(y, x)\n\nCompute the matrix logarithm of x. If the eltype of y is real, then the imaginary part of x is ignored, and a DomainError is raised if real(x) has no real logarithm.\n\n\n\n\n\n","category":"function"},{"location":"groups/orthogonal_group/#LieGroups.usinc_from_cos","page":"Orthogonal group","title":"LieGroups.usinc_from_cos","text":"usinc_from_cos(x::Real)\n\nUnnormalized version of sinc function, i.e. mathrmusinc(Œ∏) = fracsin(Œ∏)Œ∏, computed from x = cos(Œ∏).\n\n\n\n\n\n","category":"function"},{"location":"groups/special_unitary_group/#The-special-unitary-group","page":"Special unitary group","title":"The special unitary group","text":"","category":"section"},{"location":"groups/special_unitary_group/","page":"Special unitary group","title":"Special unitary group","text":"SpecialUnitaryGroup","category":"page"},{"location":"groups/special_unitary_group/#LieGroups.SpecialUnitaryGroup","page":"Special unitary group","title":"LieGroups.SpecialUnitaryGroup","text":"SpecialUnitaryGroup{T}\n\nThe special orthogonal group mathrmSO(n) is the Lie group consisting of the MatrixMultiplicationGroupOperation on the manifold of rotations GeneralUnitaryMatrices with determinant one.\n\nConstructor\n\nSpecialUnitaryGroup(n::Int; kwargs...)\n\nGenerate special unitary group mathrmSO(n). All keyword arguments in kwargs... are passed on to Rotations as well.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_unitary_group/","page":"Special unitary group","title":"Special unitary group","text":"For this Lie group, several implementations are already covered by the defaults in the generic (matrix) multiplication operation.","category":"page"},{"location":"#LieGroups.jl","page":"Home","title":"LieGroups.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the Documentation of LieGroups.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = LieGroups","category":"page"},{"location":"","page":"Home","title":"Home","text":"LieGroups.LieGroups","category":"page"},{"location":"#LieGroups.LieGroups","page":"Home","title":"LieGroups.LieGroups","text":"LieGroups.jl: Lie groups and Lie algebras in Julia.\n\nThe package is named after the Norwegian mathematician Marius Sophus Lie (1842‚Äì1899).\n\nüìö Documentation: juliamanifolds.github.io/LieGroups.jl/\nüì¶ Repository: github.com/JuliaManifolds/LieGroups.jl\nüí¨ Discussions: github.com/JuliaManifolds/LieGroups.jl/discussions\nüéØ Issues: github.com/JuliaManifolds/LieGroups.jl/issues\n\n\n\n\n\n","category":"module"},{"location":"groups/translation_group/#The-Lie-group-of-translations-on-a-Euclidean-space","page":"Translation group","title":"The Lie group of translations on a Euclidean space","text":"","category":"section"},{"location":"groups/translation_group/","page":"Translation group","title":"Translation group","text":"TranslationGroup","category":"page"},{"location":"groups/translation_group/#LieGroups.TranslationGroup","page":"Translation group","title":"LieGroups.TranslationGroup","text":"TranslationGroup{ùîΩ,T}\n\nThe translation group mathcal T(n) is Lie group consisting of the AdditionGroupOperation on some Euclidean space.\n\nConstructor\n\nTranslationGroup(n‚ÇÅ,...,n·µ¢; kwargs...)\n\nGenerate the translation group on ùîΩ^n‚ÇÅn·µ¢ = Euclidean(n‚ÇÅ,...,n·µ¢; field=ùîΩ), which is isomorphic to the group itself. All keyword arguments in kwargs... are passed on to Euclidean as well\n\nWe denote the Lie algebra of mathcal T(n) by mathfrak t(n).\n\n\n\n\n\n","category":"type"},{"location":"groups/translation_group/","page":"Translation group","title":"Translation group","text":"For this Lie group, all implementations are already covered by the defaults in the generic addition operation.","category":"page"},{"location":"notation/#Notation-on-Lie-groups","page":"Notation","title":"Notation on Lie groups","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"In this package,the notation introduced in Manifolds.jl Notation is used with the following additional parts.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Symbol Description Also used Comment\n a group operation  \nc_gmathcal G  mathcal G the conjugation map (with g)  \nmathrme identity element of a group  \nexp_mathcal G(X) The Lie group exponential function  \nexp_g(X) The Lie group exponential map (w.r.t. a Cartan Schouten connection)  \ng h k elements on a (Lie) group. Sometimes called points. g_1 g_2  \nmathfrak g a Lie algebra  \nmathcalG a Lie group  \nŒª_g mathcal G  mathcal G the left group operation map Œª_g(h) = gh  \nlog_mathcal G(g) The Lie group logarithmic function  \nlog_g(h) The Lie group logarithmic map (w.r.t. a Cartan Schouten connection)  \nœÅ_g mathcal G  mathcal G the right group operation map œÅ_g(h) = hg  \nœÉ mathcal G  mathcal M a left group action  œÉ_g(p) to emphasize a fixed group element\nœÑ mathcal M  mathcal G a right group action œÉ_mathrmR œÑ_g(p) to emphasize a fixed group element","category":"page"}]
}
