var documenterSearchIndex = {"docs":
[{"location":"tutorials/transition/#Transition-from-GroupManifolds-in-Manifolds.jl","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds in Manifolds.jl","text":"","category":"section"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"One predecessor of LieGroups.jl are the GroupManifolds in Manifolds.jl. While this package provides the same features, one reason for a new package is, that a “restart” offers the opportunity to put the main focus for the functions in this package really on Lie groups.","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"This tutorial provides an overview of the necessary changes to your code if you based it on the predecessor.","category":"page"},{"location":"tutorials/transition/#Table-of-function-names-and-its-successors","page":"Transition from GroupManifolds","title":"Table of function names and its successors","text":"","category":"section"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"The following table lists all functions related to GroupManifolds and their new names or replacements here in LieGroups.jl. In this code G always refers to the GroupManifold in the first column and the LieGroup in the second. Lie group elements (points) are always g,h, Lie algebra elements (vectors) always X, Y.","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"New functions and types in this package are only mentioned, if they are worth a comment and if something changed.","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"The list is alphabetical, but first lists types, then functions","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"Manifolds.jl LieGroups.jl Comment\nAdditionOperation AdditionGroupOperation \nLeftForwardAction LeftGroupOperationAction \nLeftBackwardAction InverseRightGroupOperationAction note that this is now also aa AbstractLeftGroupActionType\n LieAlgebra(G) new alias to emphasize its manifold- and vector structure as well as for a few dispatch methods.\nGroupManifold(M, op) LieGroup(M, op) \nPowerGroup(M) PowerLieGroup(G,n) The main change is, that the constructor now requires a Lie group to build the power Lie group; This also allows for G^n. The other two former constructors for nested and nested-replacing are no longer necessary. PowerLieGroup behaves exactly the same as PowerManifold.\nProductGroup(M) ProductLieGroup(G, H) The main change is, that the constructor now requires two Lie groups to build their product. This also allows for the short hand G×H to generate this product.\nSemidirectProductGroup(G, H, a) LeftSemidirectProductLieGroup(G, H, a) While this staid the same, there is now also the default_left_action(G,H). When this agrees with a you can use the short hand G⋉H to generate this semidirect product. Analogously there now also exists the RightSemidirectProductLieGroup(G,H) withdefault_left_action(G,H) that allows for the short cut G⋊H\nRightBackwardAction RightGroupOperationAction \nRightForwardAction InverseLeftGroupOperationAction note that this is an AbstractRightGroupActionType\nadjoint adjoint now implemented with a default, when you provide diff_conjugate!.\napply_diff diff_apply modifiers (diff) come first, consistent with ManifoldsDiff.jl\napply_diff_group diff_group_apply modifiers (diff/group) come first, consistent with ManifoldsDiff.jl\n conjugate, diff_conjugate a new function to model c_g mathcal G  mathcal G given by c_g(h) = ghg^-1\ndifferential_exp_argument_lie_approx - Scheduled for update and renaming. Though available in ManifoldDiff.jl for GroupManifolds, that will move to differential_exp_argument_approx instead, since exp_lie changed to now just exp.\nexp(G, g, X) exp(base_manifold(G), g, X) the previous defaults whenever not agreeing with the Riemannian one can now be accessed on the internal manifold\nexp_inv(G, g, X) exp(G, g, X) the exponential map invariant to the group operation is the default on Lie groups here\nexp_lie(G, X) exp(G, X) the (matrix/Lie group) exponential\ninverse_translate(G, g, h, c) inv_left_compose(G, g, h), inv_right_compose(G, g, h) compute g^-1h and gh^-1, resp.\ninverse_translate_diff(G, g, h, X, LeftForwardAction()) - discontinued, use diff_left_compose(G, inv(G,g), h)\ninverse_translate_diff(G, g, h, X, RightBackwardAction()) - discontinued, use diff_left_compose(G, h, inv(G,g))\nlog(G, g, h) log(base_manifold(G), g, h) you can now access the previous defaults on the internal manifold whenever they do not agree with the invariant one\nlog_inv(G, g, h) log(G, g, h) the logarithmic map invariant to the group operation is the default on Lie groups here\nlog_lie(G, g) log(G, g) the (matrix/Lie group) logarithm\nswitch_direction(A) inv(A) switches from an action to its inverse action (formerly the direction forward/backward, sometimes even left/right, do not confuse with the side left/right).\nswitch_side(A) switch(A) switches from a left action to its corresponding right action.\ntranslate(G, g, h) compose(G, g, h) unified to compose\ntranslate_diff(G, g, X, c) diff_left_compose(G, g, h, X), diff_right_compose(G, g, h, X) for compose gh the functions now specify whether the derivative is taken w.r.t. to the left (g) or right (h) argument\nVeeOrthogonalBasis DefaultLieAlgebraOrthogonalBasis ","category":"page"},{"location":"tutorials/transition/#Further-notable-changes","page":"Transition from GroupManifolds","title":"Further notable changes","text":"","category":"section"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"In general the default for tangent vectors is now to represent them in the LieAlgebra, which obtains its own name now, though defined as a constant of a certain tangent space.\nIn accordance with point 1., the GeneralLinearGroup (formerly GeneralLinear) switched to using its Lie algebra to represent tangent vectors.\nFormerly, both a power manifold of Lie groups as a manifold as well as a Lie group of a power manifold as a Lie group were possible. This is unified to just defining G^n as the Lie group on the power manifold with the element-wise group operation.\nFormerly, product manifolds were stored as a ProductManifold of Lie groups and an indicator for the group operation, that the direct product should be used. This is switched to internally only store a ProductManifold as well as a (new) ProductGroupOperation that specifies one group operation for every factor.\nThe last two points achieve one unified modelling aspect of Lie groups: they are now always a manifold M together with a group operation op, but a Lie group does not store another Lie group (or product of them) internally with one common type they share, a LieGroup.","category":"page"},{"location":"references/#Literature","page":"References","title":"Literature","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"This is all literature mentioned / referenced in the LieGroups.jl documentation. You can find a small reference section at the end of every documentation page that contains the corresponding references as well.","category":"page"},{"location":"references/","page":"References","title":"References","text":"D. Andrica and R.-A. Rohan. Computing the Rodrigues coefficients of the exponential map of the Lie groups of matrices. Balkan Journal of Geometry and Its Applications 18, 1–10 (2013).\n\n\n\nE. Biny and S. Pods. The Geometry of Heisenberg Groups: With Applications in Signal Theory, Optics, Quantization, and Field Quantization (American Mathematical Society, 2008).\n\n\n\nJ. Gallier and D. Xu. Computing exponentials of skew-symmetric matrices and logarithms of orthogonal matrices. International Journal of Robotics and Automation 17, 1–11 (2002).\n\n\n\nM. B. Giles. Collected Matrix Derivative Results for Forward and Reverse Mode Algorithmic Differentiation. In: Advances in Automatic Differentiation, Lecture Notes in Computational Science and Engineering, edited by C. H. Bischof, H. M. Bücker, P. Hovland, U. Naumann and J. Utke (Springer, Berlin, Heidelberg, 2008); pp. 35–44.\n\n\n\nJ. Hilgert and K.-H. Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\nJ. Solà, J. Deray and D. Atchuthan. A micro Lie theory for state estimation in robotics (Dec 2021), arXiv:1812.01537 [cs.RO], arXiv: 1812.01537.\n\n\n\n","category":"page"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"EditURL = \"https://github.com/JuliaManifolds/LieGroups.jl/blob/main/CONTRIBUTING.md\"","category":"page"},{"location":"contributing/#Contributing-to-LieGroups.jl","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"First, thanks for taking the time to contribute. We appreciate and welcome any contribution.","category":"page"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"The following is a set of guidelines to LieGroups.jl.","category":"page"},{"location":"contributing/#Table-of-contents","page":"Contributing to LieGroups.jl","title":"Table of contents","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Contributing to LieGroups.jl     - Table of Contents\nHow to just ask a question\nHow to file an issue\nHow to contribute\nCode style","category":"page"},{"location":"contributing/#How-to-just-ask-a-question","page":"Contributing to LieGroups.jl","title":"How to just ask a question","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"You can most easily reach the developers in the Julia Slack channel #manifolds. You can apply for the Julia Slack workspace here if you haven't joined yet. You can also ask your question on discourse.julialang.org.","category":"page"},{"location":"contributing/#How-to-file-an-issue","page":"Contributing to LieGroups.jl","title":"How to file an issue","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"If you found a bug or want to propose a feature, please open an issue in within the GitHub repository.","category":"page"},{"location":"contributing/#How-to-contribute","page":"Contributing to LieGroups.jl","title":"How to contribute","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Currently most details are still work-in-progress. Feel free to contribute ideas, features you would like to see, Lie groups you want to have or would like to contribute, or any other idea for LieGroups.jl. For these, use either the discussions or issues in the GitHub repository","category":"page"},{"location":"contributing/#Code-style","page":"Contributing to LieGroups.jl","title":"Code style","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Please follow the documentation guidelines from the Julia documentation as well as Blue Style. Run JuliaFormatter.jl on the repository running using JuliaFormatter; format(\".\") on the main folder of the project.","category":"page"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Please follow a few internal conventions:","category":"page"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Include the mathematical formulae for any implemented function if a closed form exists.\nDefine a Lie group, a Lie group action, or a Lie algebra in its own file. Include all related functions in the same file\nan alphabetical order of functions in every file is preferable.\nThe preceding implies that the mutating variant of a function follows the non-mutating variant.\nDocument both the allocating and the mutating variants of a function. To avoid duplication, attach one doc string defined before both functions and attach it to both.\nThere should be no dangling = signs.\nAdd a newline between things of different types (struct/method/const).\nAdd a newline between methods for different functions (including allocating/mutating variants).\nPrefer to have no newline between methods for the same function; when reasonable, merge the documentation strings.\nAll import/using/include should be in the main module file.\nAvoid using import and use the explicit full name, like Base.exp, when implementing functions, that extend functions of other packages.\nif possible provide both mathematical formulae and literature references using DocumenterCitations.jl and BibTeX where possible\nAlways document all input variables and keyword arguments","category":"page"},{"location":"groups/special_euclidean_group/#The-special-Euclidean-group","page":"Special Euclidean group","title":"The special Euclidean group","text":"","category":"section"},{"location":"groups/special_euclidean_group/","page":"Special Euclidean group","title":"Special Euclidean group","text":"SpecialEuclideanGroup","category":"page"},{"location":"groups/special_euclidean_group/#LieGroups.SpecialEuclideanGroup","page":"Special Euclidean group","title":"LieGroups.SpecialEuclideanGroup","text":"SpecialEuclideanGroup{T}\n\nThe special Euclidean group mathrmSE(n) = mathrmSO(n)  mathcal T(n) is the Lie group consisting of the LeftSemidirectProductGroupOperation of the SpecialOrthogonalGroup and the TranslationGroup together with the GroupOperationAction{LeftGroupOperationAction}.\n\nTo be precise, the group operation is defined on mathrmSO(n)  mathcal T(n) as follows:\n\n(r_1 t_1)  (r_2 t_2) = (r_1r_2 t_1 + r_1t_2)\n\nwhere r_1r_2  mathrmSO(n) and t_1t_2  mathcal T(n)\n\nAnalogously you can write this on elements of mathrmSO(n)  mathcal T(n) as\n\n(t_1 r_1)  (t_2 r_2) = (t_1 + r_1s_2 r_1r_2)\n\nBoth these cases can be represented in a single matrix in affine form\n\ng = beginpmatrix r  t mathbf0_n^mathrmT  1endpmatrix\nqquad r  mathrmSO(n) t  mathcal T(n)\n\nwhere mathbf0_n  ℝ^n denotes the vector containing zeros.\n\nWe refer also in general to elements on mathrmSE(n) as g and their rotation and translation components as r and t, respectively.\n\nConstructor\n\nSpecialEuclideanGroup(n::Int; variant=:left, kwargs...)\nSpecialOrthogonalGroup(n; kwargs...) ⋉ TranslationGroup(n; kwargs...)\nTranslationGroup(n; kwargs...) ⋊ SpecialOrthogonalGroup(n; kwargs...)\n\nGenerate special Euclidean group mathrmSE(n) = mathrmSO(n)  mathcal T(n), where the first constructor is equivalent to the second.\n\nAll keyword arguments in kwargs... are passed on to Rotations as well.\n\nThe default representation for mathrmSE(n) is the affine form. Alternatively you can use the ArrayPartition from RecursiveArrayTools.jl to work on (rt). or for mathcal T(n)  mathrmSO(n) using the ArrayPartitions (tr); which corresponds to setting variant=:right in the first constructor.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_euclidean_group/#Representation-of-points-and-tangent-vectors","page":"Special Euclidean group","title":"Representation of points and tangent vectors","text":"","category":"section"},{"location":"groups/special_euclidean_group/","page":"Special Euclidean group","title":"Special Euclidean group","text":"SpecialEuclideanMatrixPoint\nSpecialEuclideanMatrixTangentVector\nSpecialEuclideanProductPoint\nSpecialEuclideanProductTangentVector","category":"page"},{"location":"groups/special_euclidean_group/#LieGroups.SpecialEuclideanMatrixPoint","page":"Special Euclidean group","title":"LieGroups.SpecialEuclideanMatrixPoint","text":"SpecialEuclideanMatrixPoint <: AbstractLieGroupPoint\n\nrepresent a point on some LieGroup by an affine matrix.\n\nbeginpmatrix M  v mathbf0_n^mathrmT  1endpmatrix  ℝ^(n+1)(n+1)\nqquad M  ℝ^nn v  mathcal T(n)\n\nwhere mathbf0_n  ℝ^n denotes the vector containing zeros.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_euclidean_group/#LieGroups.SpecialEuclideanMatrixTangentVector","page":"Special Euclidean group","title":"LieGroups.SpecialEuclideanMatrixTangentVector","text":"SpecialEuclideanMatrixTangentVector <: AbstractLieAlgebraTangentVector\n\nrepresent a tangent vector on some LieGroup by a matrix of the form\n\nbeginpmatrix M  v mathbf0_n^mathrmT  0endpmatrix  ℝ^(n+1)(n+1)\nqquad M  ℝ^nn v  mathcal T(n)\n\nwhere mathbf0_n  ℝ^n denotes the vector containing zeros.\n\nWhile this tangent vector itself is not an affine matrix itself, it can be used for the Lie algebra of the affine group\n\n\n\n\n\n","category":"type"},{"location":"groups/special_euclidean_group/#LieGroups.SpecialEuclideanProductPoint","page":"Special Euclidean group","title":"LieGroups.SpecialEuclideanProductPoint","text":"SpecialEuclideanProductPoint <: AbstractLieGroupPoint\n\nRepresent a point on a Lie group (explicitly) as a point that consists of components\n\n\n\n\n\n","category":"type"},{"location":"groups/special_euclidean_group/#LieGroups.SpecialEuclideanProductTangentVector","page":"Special Euclidean group","title":"LieGroups.SpecialEuclideanProductTangentVector","text":"SpecialEuclideanProductTangentVector <: AbstractLieAlgebraTangentVector\n\nRepresent a point on a Lie algebra (explicitly) as a tangent vector that consists of components.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_euclidean_group/#Specific-functions","page":"Special Euclidean group","title":"Specific functions","text":"","category":"section"},{"location":"groups/special_euclidean_group/","page":"Special Euclidean group","title":"Special Euclidean group","text":"Modules = [LieGroups]\nPages = [\"groups/special_euclidean_group.jl\"]\nOrder = [:function]","category":"page"},{"location":"groups/special_euclidean_group/#Base.exp-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{2}}, ℝ}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}, Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{2}}, ℝ}}}}}, Any}","page":"Special Euclidean group","title":"Base.exp","text":"exp(G::SpecialEuclidean, X)\nexp!(G::SpecialEuclidean, g, X)\n\nCompute the Lie group exponential function on the SpecialEuclideanGroup G=mathrmSE(2) using a TypeParameter{Tuple{2}} for dispatch.\n\nThe Lie algebra vector X = (Y v)  mathfrak se(2) consists of a rotation component Y  mathfrak so(2) and a translation component v  mathfrak t(2), so we can use vee on mathrmSO(2) to obtain the angle of rotation α (or alternatively using sqrt2α = lVert Y rVert_)\n\nFor α  0 define\n\nU_α = fracsinααI_2 + frac1-cosαα^2Y\n\nand U_0 = I_2, where I_2 is the identity matrix.\n\nThen the result g=(Rt) is given by\n\nR = exp_mathrmSO(2)Y  mathrmSO(2)\nquad\ntext and \nquad\nt = U_αv  mathcal T(2)\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.exp-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ℝ}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ℝ}}}}}, Any}","page":"Special Euclidean group","title":"Base.exp","text":"exp(G::SpecialEuclidean, X)\nexp!(G::SpecialEuclidean, g, X)\n\nCompute the Lie group exponential function on the SpecialEuclideanGroup G=mathrmSE(3) using a TypeParameter{Tuple{3}} for dispatch.\n\nSince X = (Y v)  mathfrak se(3) consists of a rotation component Y  mathfrak se(3) and a translation component v  mathfrak t(3), we can use vee on mathrmSO(3) computing the coefficients norm to obtain the angle of rotation α (or alternatively using sqrt2α = lVert Y rVert_).\n\nFor α  0 define\n\nU_α = I_3 + frac1-cosαα^2Y + fracα-sinαα^3Y^2\n\nand U_0 = I_3, where I_2 is the identity matrix.\n\nThen the result g=(Rt) is given by\n\nR = exp_mathrmSO(3)Y  mathrmSO(3)\nquad\ntext and \nquad\nt = U_αv  mathcal T(3)\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.getindex-Tuple{Union{Identity, SpecialEuclideanMatrixPoint, SpecialEuclideanProductPoint}, Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{T, ℝ}, Manifolds.Rotations{T}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{T}, Manifolds.Euclidean{T, ℝ}}}}} where T, Union{Int64, Symbol}}","page":"Special Euclidean group","title":"Base.getindex","text":"g[G::SpecialEuclideanGroup,s]\ngetindex(g, G::SpecialEuclideanGroup, s)\nX[𝔤,s]\ngetindex(g, 𝔤, s)\n\nAccess sub-parts of a SpecialEuclideanGroup G or its Lie algebra 𝔤. where s can be an index :Rotation, :Translation to access the single parts. Use : to access all submanifold components as a unified tuple.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.getindex-Tuple{Union{SpecialEuclideanMatrixTangentVector, SpecialEuclideanProductTangentVector}, ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, <:SpecialEuclideanGroup{T} where T, Identity{var\"#s126\"}} where var\"#s126\"<:(Union{var\"#s20\", var\"#s19\"} where {var\"#s20\"<:(LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}), var\"#s19\"<:(RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction})}), Colon}","page":"Special Euclidean group","title":"Base.getindex","text":"g[G::SpecialEuclideanGroup,s]\ngetindex(g, G::SpecialEuclideanGroup, s)\nX[𝔤,s]\ngetindex(g, 𝔤, s)\n\nAccess sub-parts of a SpecialEuclideanGroup G or its Lie algebra 𝔤. where s can be an index :Rotation, :Translation to access the single parts. Use : to access all submanifold components as a unified tuple.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.getindex-Tuple{Union{SpecialEuclideanMatrixTangentVector, SpecialEuclideanProductTangentVector}, ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, <:SpecialEuclideanGroup{T} where T, Identity{var\"#s126\"}} where var\"#s126\"<:(Union{var\"#s20\", var\"#s19\"} where {var\"#s20\"<:(LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}), var\"#s19\"<:(RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction})}), Union{Int64, Symbol}}","page":"Special Euclidean group","title":"Base.getindex","text":"g[G::SpecialEuclideanGroup,s]\ngetindex(g, G::SpecialEuclideanGroup, s)\nX[𝔤,s]\ngetindex(g, 𝔤, s)\n\nAccess sub-parts of a SpecialEuclideanGroup G or its Lie algebra 𝔤. where s can be an index :Rotation, :Translation to access the single parts. Use : to access all submanifold components as a unified tuple.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.inv-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{T, ℝ}, Manifolds.Rotations{T}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{T}, Manifolds.Euclidean{T, ℝ}}}}} where T, Any}","page":"Special Euclidean group","title":"Base.inv","text":"inv(G::SpecialEuclideanGroup, g)\ninv(G::SpecialEuclideanGroup, h, g)\n\nCompute the inverse element of a g  mathrmSE(n) from the SpecialEuclideanGroup(n).\n\nIn affine form, g = beginpmatrix r  t mathbf0_n^mathrmT  1endpmatrix, where mathbf0_n  ℝ^n denotes the vector containing zeros.\n\nThe inverse reads\n\ng^-1 = beginpmatrix r^mathrmT  -r^mathrmTt mathbf0_n^mathrmT  1endpmatrix\n\nThis computation can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.log-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{2}}, ℝ}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}, Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{2}}, ℝ}}}}}, Any}","page":"Special Euclidean group","title":"Base.log","text":"log(G::SpecialEuclidean, g)\nlog!(G::SpecialEuclidean, X, g)\n\nCompute the Lie group logarithm function on the SpecialEuclideanGroup G=mathrmSE(2), and G uses a TypeParameter{Tuple{2}} for dispatch.\n\nSince g=(Rt)  mathrmSE(2) consists of a rotation component R  mathrmSO(2) and a translation component t  mathcal T(2), we first compute Y = log_mathrmSO(2)R. Then we can use vee on mathrmSO(2) to obtain the angle of rotation α (or alternatively using sqrt2α = lVert Y rVert_)\n\nFor α  0 define\n\nV_α = fracα2 beginpmatrix fracsinα1-cosα  1 -1  fracsinα1-cosαendpmatrix\n\nand V_0 = I_2, where I_2 is the identity matrix. Note that this is the inverse of U_α as given in the group exponential\n\nThen the result X = (Y v)  mathfrak se(2) is given by Y  mathfrak so(2) as computed above and\n\nv = V_αr  mathcal T(2)\n\nwhere v is computed in-place without setting up V_α\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.log-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ℝ}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ℝ}}}}}, Any}","page":"Special Euclidean group","title":"Base.log","text":"log(G::SpecialEuclidean, g)\nlog!(G::SpecialEuclidean, X, g)\n\nCompute the Lie group logarithm function on the SpecialEuclideanGroup G=mathrmSE(3), where e is the Identity on mathrmSE(3) G uses a TypeParameter{Tuple{3}} for dispatch.\n\nSince g=(Rt)  mathrmSE(3) consists of a rotation component R  mathrmSO(3) and a translation component t  mathcal T(2), we first compute Y = log_mathrmSO(3)R. Then we can use vee on mathrmSO(3) to obtain the angle of rotation α (or alternatively using sqrt2α = lVert Y rVert_)\n\nFor α  0 define\n\nV_α = I_3 - frac12Y + β Y^2 quadtext where  β = frac1α^2 - frac1 + cos(α)2αsin(α)\n\nand V_0 = I_3, where I_3 is the identity matrix. Note that this is the inverse of U_α as given in the group exponential\n\nThen the result X = (Y v)  mathfrak se(3) is given by Y  mathfrak so(3) as computed above and v = V_α t  mathfrak t(3).\n\nThis result can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.default_left_action-Tuple{SpecialOrthogonalGroup, TranslationGroup}","page":"Special Euclidean group","title":"LieGroups.default_left_action","text":"default_left_action(G::SpecialOrthogonalGroup, ::TranslationGroup)\n\nReturn the default left action for the special Euclidean group mathrmSO(n)  mathcal T(n), that is the GroupOperationAction(LeftGroupOperationAction(G.op)).\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.default_right_action-Tuple{TranslationGroup, SpecialOrthogonalGroup}","page":"Special Euclidean group","title":"LieGroups.default_right_action","text":"default_right_action(::TranslationGroup, G::SpecialOrthogonalGroup)\n\nReturn the default right action for the special Euclidean group, that is the GroupOperationAction(LeftGroupOperationAction(G.op)).\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.init_constants!-Tuple{ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, <:SpecialEuclideanGroup{T} where T, Identity{var\"#s126\"}} where var\"#s126\"<:(Union{var\"#s20\", var\"#s19\"} where {var\"#s20\"<:(LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}), var\"#s19\"<:(RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction})}), AbstractMatrix}","page":"Special Euclidean group","title":"LieGroups.init_constants!","text":"init_constants!(G::SpecialEuclidean, g)\ninit_Constants!(𝔰𝔢::LieAlgebra{ℝ, SpecialEuclideanGroupOperation, SpecialEuclidean}, X)\n\nInitialize the constant elements of g or X.\n\nThe matrix representation of gmathrmSE(n) has a last row, that contains zeros, besides the diagonal element, which is g_n+1n+1 = 1.\n\nThe matrix representation of Xmathfrak se(n) has a last row that contains zeros.\n\nthis function sets these entries accordingly.\n\nPer default for other representations, this function does not change entries for them.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.init_constants!-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{T, ℝ}, Manifolds.Rotations{T}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{T}, Manifolds.Euclidean{T, ℝ}}}}} where T, AbstractMatrix}","page":"Special Euclidean group","title":"LieGroups.init_constants!","text":"init_constants!(G::SpecialEuclidean, g)\ninit_Constants!(𝔰𝔢::LieAlgebra{ℝ, SpecialEuclideanGroupOperation, SpecialEuclidean}, X)\n\nInitialize the constant elements of g or X.\n\nThe matrix representation of gmathrmSE(n) has a last row, that contains zeros, besides the diagonal element, which is g_n+1n+1 = 1.\n\nThe matrix representation of Xmathfrak se(n) has a last row that contains zeros.\n\nthis function sets these entries accordingly.\n\nPer default for other representations, this function does not change entries for them.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.inv!-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{T, ℝ}, Manifolds.Rotations{T}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{T}, Manifolds.Euclidean{T, ℝ}}}}} where T, AbstractMatrix, AbstractMatrix}","page":"Special Euclidean group","title":"LieGroups.inv!","text":"inv(G::SpecialEuclideanGroup, g)\ninv(G::SpecialEuclideanGroup, h, g)\n\nCompute the inverse element of a g  mathrmSE(n) from the SpecialEuclideanGroup(n).\n\nIn affine form, g = beginpmatrix r  t mathbf0_n^mathrmT  1endpmatrix, where mathbf0_n  ℝ^n denotes the vector containing zeros.\n\nThe inverse reads\n\ng^-1 = beginpmatrix r^mathrmT  -r^mathrmTt mathbf0_n^mathrmT  1endpmatrix\n\nThis computation can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#ManifoldsBase.exp!-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ℝ}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ℝ}}}}}, AbstractMatrix, AbstractMatrix}","page":"Special Euclidean group","title":"ManifoldsBase.exp!","text":"exp(G::SpecialEuclidean, X)\nexp!(G::SpecialEuclidean, g, X)\n\nCompute the Lie group exponential function on the SpecialEuclideanGroup G=mathrmSE(3) using a TypeParameter{Tuple{3}} for dispatch.\n\nSince X = (Y v)  mathfrak se(3) consists of a rotation component Y  mathfrak se(3) and a translation component v  mathfrak t(3), we can use vee on mathrmSO(3) computing the coefficients norm to obtain the angle of rotation α (or alternatively using sqrt2α = lVert Y rVert_).\n\nFor α  0 define\n\nU_α = I_3 + frac1-cosαα^2Y + fracα-sinαα^3Y^2\n\nand U_0 = I_3, where I_2 is the identity matrix.\n\nThen the result g=(Rt) is given by\n\nR = exp_mathrmSO(3)Y  mathrmSO(3)\nquad\ntext and \nquad\nt = U_αv  mathcal T(3)\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#ManifoldsBase.exp!-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{var\"#s127\", ℝ}, Manifolds.Rotations{var\"#s127\"}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{var\"#s127\"}, Manifolds.Euclidean{var\"#s127\", ℝ}}}}} where var\"#s127\"<:ManifoldsBase.TypeParameter{Tuple{2}}, AbstractMatrix, AbstractMatrix}","page":"Special Euclidean group","title":"ManifoldsBase.exp!","text":"exp(G::SpecialEuclidean, X)\nexp!(G::SpecialEuclidean, g, X)\n\nCompute the Lie group exponential function on the SpecialEuclideanGroup G=mathrmSE(2) using a TypeParameter{Tuple{2}} for dispatch.\n\nThe Lie algebra vector X = (Y v)  mathfrak se(2) consists of a rotation component Y  mathfrak so(2) and a translation component v  mathfrak t(2), so we can use vee on mathrmSO(2) to obtain the angle of rotation α (or alternatively using sqrt2α = lVert Y rVert_)\n\nFor α  0 define\n\nU_α = fracsinααI_2 + frac1-cosαα^2Y\n\nand U_0 = I_2, where I_2 is the identity matrix.\n\nThen the result g=(Rt) is given by\n\nR = exp_mathrmSO(2)Y  mathrmSO(2)\nquad\ntext and \nquad\nt = U_αv  mathcal T(2)\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#ManifoldsBase.log!-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{2}}, ℝ}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}, Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{2}}, ℝ}}}}}, AbstractMatrix, AbstractMatrix}","page":"Special Euclidean group","title":"ManifoldsBase.log!","text":"log(G::SpecialEuclidean, g)\nlog!(G::SpecialEuclidean, X, g)\n\nCompute the Lie group logarithm function on the SpecialEuclideanGroup G=mathrmSE(2), and G uses a TypeParameter{Tuple{2}} for dispatch.\n\nSince g=(Rt)  mathrmSE(2) consists of a rotation component R  mathrmSO(2) and a translation component t  mathcal T(2), we first compute Y = log_mathrmSO(2)R. Then we can use vee on mathrmSO(2) to obtain the angle of rotation α (or alternatively using sqrt2α = lVert Y rVert_)\n\nFor α  0 define\n\nV_α = fracα2 beginpmatrix fracsinα1-cosα  1 -1  fracsinα1-cosαendpmatrix\n\nand V_0 = I_2, where I_2 is the identity matrix. Note that this is the inverse of U_α as given in the group exponential\n\nThen the result X = (Y v)  mathfrak se(2) is given by Y  mathfrak so(2) as computed above and\n\nv = V_αr  mathcal T(2)\n\nwhere v is computed in-place without setting up V_α\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#ManifoldsBase.log!-Tuple{Union{LieGroup{ℝ, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ℝ}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}}}}, LieGroup{ℝ, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{ℝ, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ℝ}}}}}, AbstractMatrix, AbstractMatrix}","page":"Special Euclidean group","title":"ManifoldsBase.log!","text":"log(G::SpecialEuclidean, g)\nlog!(G::SpecialEuclidean, X, g)\n\nCompute the Lie group logarithm function on the SpecialEuclideanGroup G=mathrmSE(3), where e is the Identity on mathrmSE(3) G uses a TypeParameter{Tuple{3}} for dispatch.\n\nSince g=(Rt)  mathrmSE(3) consists of a rotation component R  mathrmSO(3) and a translation component t  mathcal T(2), we first compute Y = log_mathrmSO(3)R. Then we can use vee on mathrmSO(3) to obtain the angle of rotation α (or alternatively using sqrt2α = lVert Y rVert_)\n\nFor α  0 define\n\nV_α = I_3 - frac12Y + β Y^2 quadtext where  β = frac1α^2 - frac1 + cos(α)2αsin(α)\n\nand V_0 = I_3, where I_3 is the identity matrix. Note that this is the inverse of U_α as given in the group exponential\n\nThen the result X = (Y v)  mathfrak se(3) is given by Y  mathfrak so(3) as computed above and v = V_α t  mathfrak t(3).\n\nThis result can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/getstarted/#Get-Started-with-LieGroups.jl","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"🚀 Get Started with LieGroups.jl","title":"🚀 Get Started with LieGroups.jl","text":"In this tutorial, we aim to present how to get started with LieGroups.jl.","category":"page"},{"location":"interface/operations/#An-interface-for-Lie-group-operations","page":"Group operation","title":"An interface for Lie group operations","text":"","category":"section"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"AbstractGroupOperation\nIdentity","category":"page"},{"location":"interface/operations/#LieGroups.AbstractGroupOperation","page":"Group operation","title":"LieGroups.AbstractGroupOperation","text":"AbstractGroupOperation\n\nRepresent a type of group operation for a LieGroup mathcal G, that is a smooth binary operation   mathcal G  mathcal G  mathcal G on elements of a Lie group mathcal G.\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#LieGroups.Identity","page":"Group operation","title":"LieGroups.Identity","text":"Identity{O<:AbstractGroupOperation}\n\nRepresent the group identity element e  mathcal G on a LieGroup mathcal G with AbstractGroupOperation of type O.\n\nSimilar to the philosophy that points are agnostic of their group at hand, the identity does not store the group mathcal G it belongs to. However it depends on the type of the AbstractGroupOperation used.\n\nSee also identity_element on how to obtain the corresponding AbstractManifoldPoint or array representation.\n\nConstructors\n\nIdentity(::LieGroup{𝔽,O}) where {𝔽,O<:AbstractGroupOperation}\nIdentity(o::AbstractGroupOperation)\nIdentity(::Type{AbstractGroupOperation})\n\ncreate the identity of the corresponding subtype O<:AbstractGroupOperation\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"You can combine some specific group operations with one of several manifolds to form a Lie group. You can still define the corresponding functions generically for all groups with this group operation regardless of the manifold. The following sections collect these.","category":"page"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"an AdditionGroupOperation","category":"page"},{"location":"interface/operations/#addition-operation-sec","page":"Group operation","title":"Additive group operation","text":"","category":"section"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"Modules = [LieGroups]\nPages = [\"addition_operation.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"interface/operations/#LieGroups.AdditionGroupOperation","page":"Group operation","title":"LieGroups.AdditionGroupOperation","text":"AdditionGroupOperation <: AbstractGroupOperation\n\nA group operation that is realised introducing defaults that fall back to + and - being overloaded, for example _compose(G::LieGroup{𝔽,AdditionGroupOperation}, a, b) = a + b\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#Base.exp-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any}} where 𝔽","page":"Group operation","title":"Base.exp","text":"exp(G::LieGroup{𝔽,AdditionGroupOperation}, X)\nexp!(G::LieGroup{𝔽,AdditionGroupOperation}, g, X)\n\nCompute the Lie group exponential on a LieGroup with an AdditionGroupOperation. This can be computed in-place of g.\n\nSince e is just the zero-element with respect to the corresponding +, the formula reads g=0+X=X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.inv-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any}} where 𝔽","page":"Group operation","title":"Base.inv","text":"inv(G::LieGroup{𝔽,AdditionGroupOperation}, g)\ninv!(G::LieGroup{𝔽,AdditionGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for the AdditionGroupOperation simplifies to -g. This can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.log-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any}} where 𝔽","page":"Group operation","title":"Base.log","text":"log(G::LieGroup{𝔽,AdditionGroupOperation}, g)\nlog!(G::LieGroup{𝔽,AdditionGroupOperation}, X, g)\n\nCompute the Lie group logarithm on a LieGroup with an AdditionGroupOperation. This can be computed in-place of X.\n\nSince e is just the zero-element with respect to the corresponding +, the formula reads X=g-0=g.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.compose!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.compose!","text":"compose(G::LieGroup{𝔽,AdditionGroupOperation}, g, h)\ncompose!(G::LieGroup{𝔽,AdditionGroupOperation}, k, g, h)\n\nCompute the group operation composition of g and h with respect to the AdditionGroupOperation on G, which falls back to calling g+h, where + is assumed to be overloaded accordingly.\n\nThis can be computed in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Vararg{Any, 4}}} where 𝔽","page":"Group operation","title":"LieGroups.diff_conjugate!","text":"diff_conjugate(G::LieGroup{𝔽,AdditionGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{𝔽,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjutage c_g(h) = ghg^-1 = g+h-g = h, which simplifies for AdditionGroupOperation to D(c_g(h))X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.diff_conjugate","text":"diff_conjugate(G::LieGroup{𝔽,AdditionGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{𝔽,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjutage c_g(h) = ghg^-1 = g+h-g = h, which simplifies for AdditionGroupOperation to D(c_g(h))X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.diff_inv!","text":"diff_inv(G::LieGroup{𝔽,AdditionGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{𝔽,AdditionGroupOperation}, Y, g, X)\n\nCompute the differential of the inverse operation ι_mathcal G(g) = g^-1 = -g, which simplifies for AdditionGroupOperation to Dι_mathcal G(g)X = -X\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.diff_inv","text":"diff_inv(G::LieGroup{𝔽,AdditionGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{𝔽,AdditionGroupOperation}, Y, g, X)\n\nCompute the differential of the inverse operation ι_mathcal G(g) = g^-1 = -g, which simplifies for AdditionGroupOperation to Dι_mathcal G(g)X = -X\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Vararg{Any, 4}}} where 𝔽","page":"Group operation","title":"LieGroups.diff_left_compose!","text":"diff_left_compose(G::LieGroup{𝔽,AdditionGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{𝔽,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the left group multiplication λ_g(h) = gh, which simplifies for AdditionGroupOperation to Dλ_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.diff_left_compose","text":"diff_left_compose(G::LieGroup{𝔽,AdditionGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{𝔽,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the left group multiplication λ_g(h) = gh, which simplifies for AdditionGroupOperation to Dλ_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Vararg{Any, 4}}} where 𝔽","page":"Group operation","title":"LieGroups.diff_right_compose!","text":"diff_right_compose(G::LieGroup{𝔽,AdditionGroupOperation}, h, g, X)\ndiff_right_compose!(G::LieGroup{𝔽,AdditionGroupOperation}, Y, h, g, X)\n\nCompute the differential of the right group multiplication ρ_g(h) = hg, which simplifies for AdditionGroupOperation to Dρ_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.diff_right_compose","text":"diff_right_compose(G::LieGroup{𝔽,AdditionGroupOperation}, h, g, X)\ndiff_right_compose!(G::LieGroup{𝔽,AdditionGroupOperation}, Y, h, g, X)\n\nCompute the differential of the right group multiplication ρ_g(h) = hg, which simplifies for AdditionGroupOperation to Dρ_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.identity_element!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any}} where 𝔽","page":"Group operation","title":"LieGroups.identity_element!","text":"identity_element(G::LieGroup{𝔽,AdditionGroupOperation})\nidentity_element!(G::LieGroup{𝔽,AdditionGroupOperation}, e)\n\nReturn the a point representation of the Identity, which for the AdditionGroupOperation is the zero element or array.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.inv!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.inv!","text":"inv(G::LieGroup{𝔽,AdditionGroupOperation}, g)\ninv!(G::LieGroup{𝔽,AdditionGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for the AdditionGroupOperation simplifies to -g. This can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket!-Union{Tuple{𝔽}, Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{AdditionGroupOperation}} where G<:(LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}), Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.lie_bracket!","text":"lie_bracket!(𝔤::LieAlgebra{𝔽,AdditionGroupOperation}, X, Y)\nlie_bracket!(𝔤::LieAlgebra{𝔽,AdditionGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the AdditionGroupOperation simplifies to the corresponding zero_vector. The computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket-Union{Tuple{𝔽}, Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{AdditionGroupOperation}} where G<:(LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}), Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.lie_bracket","text":"lie_bracket!(𝔤::LieAlgebra{𝔽,AdditionGroupOperation}, X, Y)\nlie_bracket!(𝔤::LieAlgebra{𝔽,AdditionGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the AdditionGroupOperation simplifies to the corresponding zero_vector. The computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Manifolds.compose-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any}} where 𝔽","page":"Group operation","title":"Manifolds.compose","text":"compose(G::LieGroup{𝔽,AdditionGroupOperation}, g, h)\ncompose!(G::LieGroup{𝔽,AdditionGroupOperation}, k, g, h)\n\nCompute the group operation composition of g and h with respect to the AdditionGroupOperation on G, which falls back to calling g+h, where + is assumed to be overloaded accordingly.\n\nThis can be computed in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Manifolds.identity_element-Union{Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}}, Tuple{𝔽}} where 𝔽","page":"Group operation","title":"Manifolds.identity_element","text":"identity_element(G::LieGroup{𝔽,AdditionGroupOperation})\nidentity_element!(G::LieGroup{𝔽,AdditionGroupOperation}, e)\n\nReturn the a point representation of the Identity, which for the AdditionGroupOperation is the zero element or array.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.exp!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any}} where 𝔽","page":"Group operation","title":"ManifoldsBase.exp!","text":"exp(G::LieGroup{𝔽,AdditionGroupOperation}, X)\nexp!(G::LieGroup{𝔽,AdditionGroupOperation}, g, X)\n\nCompute the Lie group exponential on a LieGroup with an AdditionGroupOperation. This can be computed in-place of g.\n\nSince e is just the zero-element with respect to the corresponding +, the formula reads g=0+X=X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.log!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any}} where 𝔽","page":"Group operation","title":"ManifoldsBase.log!","text":"log(G::LieGroup{𝔽,AdditionGroupOperation}, g)\nlog!(G::LieGroup{𝔽,AdditionGroupOperation}, X, g)\n\nCompute the Lie group logarithm on a LieGroup with an AdditionGroupOperation. This can be computed in-place of X.\n\nSince e is just the zero-element with respect to the corresponding +, the formula reads X=g-0=g.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#multiplication-operation-sec","page":"Group operation","title":"Multiplication group operation","text":"","category":"section"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"Modules = [LieGroups]\nPages = [\"multiplication_operation.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"interface/operations/#LieGroups.AbstractMultiplicationGroupOperation","page":"Group operation","title":"LieGroups.AbstractMultiplicationGroupOperation","text":"AbstractMultiplicationGroupOperation <: AbstractGroupOperation\n\nA group operation that is realised introducing defaults that fall back to * being overloaded, for example _compose(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, a, b) = a * b\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#LieGroups.MatrixMultiplicationGroupOperation","page":"Group operation","title":"LieGroups.MatrixMultiplicationGroupOperation","text":"AbstractMultiplicationGroupOperation <: AbstractMultiplicationGroupOperation\n\nA group operation that is realised by a matrix multiplication.\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#Base.exp-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, MatrixMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any}} where 𝔽","page":"Group operation","title":"Base.exp","text":"exp(G::LieGroup{𝔽,MatrixMultiplicationGroupOperation}, X)\nexp!(G::LieGroup{𝔽,MatrixMultiplicationGroupOperation}, g, X)\n\nCompute the Lie group exponential on a LieGroup with a MatrixMultiplicationGroupOperation, which simplifies to the matrix exponential.\n\nThis can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.inv-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any}} where 𝔽","page":"Group operation","title":"Base.inv","text":"inv(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperationroupOperation}, g)\ninv!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for an AbstractMultiplicationGroupOperation simplifies to the multiplicative inverse g^-1. This can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.log-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, MatrixMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any}} where 𝔽","page":"Group operation","title":"Base.log","text":"log(G::LieGroup{𝔽,MatrixMultiplicationGroupOperation}, g)\nlog!(G::LieGroup{𝔽,MatrixMultiplicationGroupOperation}, X, g)\n\nCompute the Lie group logarithm on a LieGroup with a MatrixMultiplicationGroupOperation, which simplifies to the matrix logarithm.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.compose!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.compose!","text":"compose(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g, h)\ncompose!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, k, g, h)\n\nCompute the group operation composition of g and h with respect to an AbstractMultiplicationGroupOperation on G, which falls back to calling g*h, where * is assumed to be overloaded accordingly.\n\nThis can be computed in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s19\", M} where {var\"#s19\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Vararg{Any, 4}}} where 𝔽","page":"Group operation","title":"LieGroups.diff_conjugate!","text":"diff_conjugate(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1 = ghg^-1, which simplifies for an AbstractMultiplicationGroupOperation to D(c_g(h))X = gXg^-1.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.diff_conjugate","text":"diff_conjugate(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1 = ghg^-1, which simplifies for an AbstractMultiplicationGroupOperation to D(c_g(h))X = gXg^-1.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s19\", M} where {var\"#s19\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.diff_inv!","text":"diff_inv(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, Y, g, X)\n\nCompute the value of differential Dι_mathcal G(g)X of matrix inversion ι_mathcal G(g) = g^-1 at X  𝔤 in the LieAlgebra 𝔤 of the LieGroup G.\n\nThe formula is given by\n\nDι_mathcal G(g)X = -g^mathrmTXg^-1\n\nwhich stems from using the differential of the inverse from [Gil08] given by D(g^-1)X = -g^-1Xg^-1 composed with the push forward of the left composition Dλ_mathrme(g)X = gX mapping from the Liea algebra into the tangent space at g, and its adjoint D^*λ_mathrme(g)X = g^mathrmTX. Then we get g^mathrmT(g^-1(gX)g^-1) which simplifies to -g^mathrmTXg^-1 from above.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.diff_inv","text":"diff_inv(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, Y, g, X)\n\nCompute the value of differential Dι_mathcal G(g)X of matrix inversion ι_mathcal G(g) = g^-1 at X  𝔤 in the LieAlgebra 𝔤 of the LieGroup G.\n\nThe formula is given by\n\nDι_mathcal G(g)X = -g^mathrmTXg^-1\n\nwhich stems from using the differential of the inverse from [Gil08] given by D(g^-1)X = -g^-1Xg^-1 composed with the push forward of the left composition Dλ_mathrme(g)X = gX mapping from the Liea algebra into the tangent space at g, and its adjoint D^*λ_mathrme(g)X = g^mathrmTX. Then we get g^mathrmT(g^-1(gX)g^-1) which simplifies to -g^mathrmTXg^-1 from above.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s19\", M} where {var\"#s19\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Vararg{Any, 4}}} where 𝔽","page":"Group operation","title":"LieGroups.diff_left_compose!","text":"diff_left_compose(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the left group multiplication λ_g(h) = gh, which simplifies for an AbstractMultiplicationGroupOperation to Dλ_g(h)X = gX.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.diff_left_compose","text":"diff_left_compose(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the left group multiplication λ_g(h) = gh, which simplifies for an AbstractMultiplicationGroupOperation to Dλ_g(h)X = gX.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s19\", M} where {var\"#s19\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Vararg{Any, 4}}} where 𝔽","page":"Group operation","title":"LieGroups.diff_right_compose!","text":"diff_right_compose(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, h, g, X)\ndiff_right_compose!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, Y, h, g, X)\n\nCompute the differential of the right group multiplication ρ_g(h) = hg, which simplifies for an AbstractMultiplicationGroupOperation to Dρ_g(h)X = Xg.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.diff_right_compose","text":"diff_right_compose(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, h, g, X)\ndiff_right_compose!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, Y, h, g, X)\n\nCompute the differential of the right group multiplication ρ_g(h) = hg, which simplifies for an AbstractMultiplicationGroupOperation to Dρ_g(h)X = Xg.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.identity_element!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any}} where 𝔽","page":"Group operation","title":"LieGroups.identity_element!","text":"identity_element(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation})\nidentity_element!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, e)\n\nReturn the a point representation of the Identity, which for an AbstractMultiplicationGroupOperation is the one-element or identity array.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.inv!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s19\", M} where {var\"#s19\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.inv!","text":"inv(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperationroupOperation}, g)\ninv!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for an AbstractMultiplicationGroupOperation simplifies to the multiplicative inverse g^-1. This can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket!-Union{Tuple{𝔽}, Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{MatrixMultiplicationGroupOperation}} where G<:(LieGroup{𝔽, MatrixMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}), Any, Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.lie_bracket!","text":"lie_bracket(::LieGroup{𝔽,MatrixMultiplicationGroupOperation}, X, Y)\nlie_bracket!(::LieGroup{𝔽,MatrixMultiplicationGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the MatrixMultiplicationGroupOperation yields the commutator bracket\n\nX Y = XY-YX\n\nThe computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket-Union{Tuple{𝔽}, Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{MatrixMultiplicationGroupOperation}} where G<:(LieGroup{𝔽, MatrixMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}), Any, Any}} where 𝔽","page":"Group operation","title":"LieGroups.lie_bracket","text":"lie_bracket(::LieGroup{𝔽,MatrixMultiplicationGroupOperation}, X, Y)\nlie_bracket!(::LieGroup{𝔽,MatrixMultiplicationGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the MatrixMultiplicationGroupOperation yields the commutator bracket\n\nX Y = XY-YX\n\nThe computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Manifolds.compose-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}, Any, Any}} where 𝔽","page":"Group operation","title":"Manifolds.compose","text":"compose(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, g, h)\ncompose!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, k, g, h)\n\nCompute the group operation composition of g and h with respect to an AbstractMultiplicationGroupOperation on G, which falls back to calling g*h, where * is assumed to be overloaded accordingly.\n\nThis can be computed in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Manifolds.identity_element-Union{Tuple{LieGroup{𝔽, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{𝔽}}}, Tuple{𝔽}} where 𝔽","page":"Group operation","title":"Manifolds.identity_element","text":"identity_element(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation})\nidentity_element!(G::LieGroup{𝔽,<:AbstractMultiplicationGroupOperation}, e)\n\nReturn the a point representation of the Identity, which for an AbstractMultiplicationGroupOperation is the one-element or identity array.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.exp!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, MatrixMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any}} where 𝔽","page":"Group operation","title":"ManifoldsBase.exp!","text":"exp(G::LieGroup{𝔽,MatrixMultiplicationGroupOperation}, X)\nexp!(G::LieGroup{𝔽,MatrixMultiplicationGroupOperation}, g, X)\n\nCompute the Lie group exponential on a LieGroup with a MatrixMultiplicationGroupOperation, which simplifies to the matrix exponential.\n\nThis can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.log!-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, MatrixMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{𝔽}, Any, Any}} where 𝔽","page":"Group operation","title":"ManifoldsBase.log!","text":"log(G::LieGroup{𝔽,MatrixMultiplicationGroupOperation}, g)\nlog!(G::LieGroup{𝔽,MatrixMultiplicationGroupOperation}, X, g)\n\nCompute the Lie group logarithm on a LieGroup with a MatrixMultiplicationGroupOperation, which simplifies to the matrix logarithm.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Literature","page":"Group operation","title":"Literature","text":"","category":"section"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"M. B. Giles. Collected Matrix Derivative Results for Forward and Reverse Mode Algorithmic Differentiation. In: Advances in Automatic Differentiation, Lecture Notes in Computational Science and Engineering, edited by C. H. Bischof, H. M. Bücker, P. Hovland, U. Naumann and J. Utke (Springer, Berlin, Heidelberg, 2008); pp. 35–44.\n\n\n\n","category":"page"},{"location":"about/#About-LieGroups.jl","page":"About","title":"About LieGroups.jl","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"LieGroups.jl is a “spin-off” from `Manifolds.jl, where GroupManifolds where implemented around 2021. Around the same time, Yueh-Hua Tu started a package LieGroups.jl, which was continued than here with a full rewrite to use the manifolds from Manifolds.jl.","category":"page"},{"location":"interface/actions/#An-Interface-for-Lie-group-actions","page":"Group action","title":"An Interface for Lie group actions","text":"","category":"section"},{"location":"interface/actions/","page":"Group action","title":"Group action","text":"Modules = [LieGroups]\nPages = [\"group_action_interface.jl\"]\nOrder = [:type]","category":"page"},{"location":"interface/actions/#LieGroups.AbstractGroupActionType","page":"Group action","title":"LieGroups.AbstractGroupActionType","text":"AbstractGroupActionType\n\nAn abstract supertype for group action types, which are used within a GroupAction.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.AbstractLeftGroupActionType","page":"Group action","title":"LieGroups.AbstractLeftGroupActionType","text":"AbstractLeftGroupActionType <: AbstractGroupActionType\n\nA type representing a (smooth) group action σ mathcal G  mathcal M  mathcal M of a LieGroup mathcal G acting (from the left) on an AbstractManifold mathcal M. with the following properties\n\nσ(mathrme p) = p holds for all p  mathcal M\nσ(g σ(h p)) = σ(gh p) holds for all gh  mathcal G, p  mathcal M\n\nwhere  denotes the group operation of the LieGroup mathcal G. See also [HN12, Definition 9.1.11].\n\nThe type of action can be seen a bit better when writing the action as a family σ_g(p): we obtain from the second property as\n\n  σ_g(σ_h(p)) = σ_gh(p)\n\nand see that g appears on the left.\n\nTo emphasize the side the group operation is acting from, we sometimes write σ^mathrmL. If the action is clear from context we write σ(g p) = g  p.\n\nOne notable example of a left action is the inverse of an action of AbstractRightGroupActionType σ^mathrmR, which is given by τ_g = (σ^mathrmR_g)^-1 = σ^mathrmR_g^-1. We obtain\n\nτ_g(τ_h(p))\n= σ^mathrmR_g^-1(σ^mathrmR_h^-1(p))\n= σ^mathrmR_h^-1g^-1(p)\n= σ^mathrmR_(gh)^-1(p)\nτ_gh(p)\n\nnote: Note\nIn function definitions we follow the idea of the family of actions and use the order (M, g, p) in function signatures.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.AbstractRightGroupActionType","page":"Group action","title":"LieGroups.AbstractRightGroupActionType","text":"AbstractRightGroupActionType <: AbstractGroupActionType\n\nA type representing a (smooth) group action σ mathcal M  mathcal G  mathcal M of a LieGroup mathcal G acting (from the right) on an AbstractManifold mathcal M. with the following properties\n\nσ(p mathrme) = p holds for all p  mathcal M\nσ(σ(p g) h) = σ(p gh) holds for all gh  mathcal G, p  mathcal M\n\nwhere  denotes the group operation of the LieGroup mathcal G. See also [HN12, Remark 9.1.12].\n\nThe type of action can be seen a bit better when writing the action as a family σ_g(p): we obtain from the second property as\n\n  σ_g(σ_h(p)) = σ_hg(p)\n\nand see that g appears on the right.\n\nTo emphasize the side the group operation is acting from, we sometimes write σ^mathrmR. If the action is clear from context we write σ(p g) = p  g.\n\nOne notable example of a right action is the inverse of an action of  AbstractLeftGroupActionType σ^mathrmL, which is given by τ_g = (σ^mathrmL_g)^-1 = σ^mathrmL_g^-1. We obtain\n\nτ_g(τ_h(p))\n= σ^mathrmL_g^-1(σ^mathrmL_h^-1(p))\n= σ^mathrmL_g^-1h^-1(p)\n= σ^mathrmL_(hg)^-1(p)\nτ_hg(p)\n\nnote: Note\nIn function definitions we follow the idea of the family of actions and use the order (M, g, p) in function signatures.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.GroupAction","page":"Group action","title":"LieGroups.GroupAction","text":"GroupAction{T<:GroupActionType, L<:LieGroup, M<:AbstractManifold}\n\nSpecify a group action of AbstractGroupActionType T of a LieGroup G acting on M.\n\nLet mathcal M be a AbstractManifold and mathcal G be a LieGroup with group operation .\n\nA (smooth) action of the group mathcal G on the manifold mathcal M is a map\n\nσ mathcal G  mathcal M  mathcal M\n\nwith the properties\n\nσ(mathrme p) = p holds for all p  mathcal M\nσ(g σ(h p)) = σ(gh p) holds for all gh  mathcal G, p  mathcal M\n\nFields\n\ntype::T: The type of the group action.\ngroup::L: The group acting.\nmanifold::M: The manifold the group acts upon.\n\nSee [HN12, Section 9.1.3] for more details.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#Functions-for-Lie-group-actions","page":"Group action","title":"Functions for Lie group actions","text":"","category":"section"},{"location":"interface/actions/","page":"Group action","title":"Group action","text":"Modules = [LieGroups]\nPages = [\"group_action_interface.jl\"]\nOrder = [:function]","category":"page"},{"location":"interface/actions/#Base.inv-Tuple{AbstractGroupActionType}","page":"Group action","title":"Base.inv","text":"inv(::AbstractGroupActionType)\n\nreturn the inverse group operation action, that is, use the type representing the inverse operation.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Base.inv-Tuple{GroupAction}","page":"Group action","title":"Base.inv","text":" inv(A::GroupAction{T})\n\nReturn the GroupAction representing the inverse of an GroupAction of AbstractGroupActionType T. This is usually done by returning the group action with the inverse type of T.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.base_lie_group-Tuple{GroupAction}","page":"Group action","title":"LieGroups.base_lie_group","text":"base_lie_group(A::GroupAction)\n\nReturn the LieGroup of the GroupAction specifying the action.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.default_left_action-Tuple{LieGroup, ManifoldsBase.AbstractManifold}","page":"Group action","title":"LieGroups.default_left_action","text":"default_left_action(G::LieGroup, M::AbstractManifold)\n\nReturn the default left action for a Lie group G acting on a manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.default_right_action-Tuple{LieGroup, ManifoldsBase.AbstractManifold}","page":"Group action","title":"LieGroups.default_right_action","text":"default_right_action(G::LieGroup, M::AbstractManifold)\n\nReturn the default right action for a Lie group G acting on a manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.diff_apply!-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"LieGroups.diff_apply!","text":"diff_apply(A::GroupAction{T, L, M}, g, p, X)\ndiff_apply!(A::GroupAction{T, L, M}, Y, g, p, X)\n\nCompute the differential D_p σ_g(p) T_pmathcal M  T_σ_g(p)mathcal M, where for a left group action we have σ_g(p) = σ(gp), for a right action σ_g(p) = σ(p g).\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.diff_apply-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"LieGroups.diff_apply","text":"diff_apply(A::GroupAction{T, L, M}, g, p, X)\ndiff_apply!(A::GroupAction{T, L, M}, Y, g, p, X)\n\nCompute the differential D_p σ_g(p) T_pmathcal M  T_σ_g(p)mathcal M, where for a left group action we have σ_g(p) = σ(gp), for a right action σ_g(p) = σ(p g).\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.diff_group_apply!-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"LieGroups.diff_group_apply!","text":"diff_group_apply(A::GroupAction{T, L, M}, g, p, X)\ndiff_group_apply!(A::GroupAction{T, L, M}, Y, g, p, X)\n\nCompute the differential D_g σ_g(p) mathfrak g  mathfrak g, where we use the short hand notation σ_p(g) = σ(gp) for a left action, and for a right action σ_p(g) = σ(p g).\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.diff_group_apply-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"LieGroups.diff_group_apply","text":"diff_group_apply(A::GroupAction{T, L, M}, g, p, X)\ndiff_group_apply!(A::GroupAction{T, L, M}, Y, g, p, X)\n\nCompute the differential D_g σ_g(p) mathfrak g  mathfrak g, where we use the short hand notation σ_p(g) = σ(gp) for a left action, and for a right action σ_p(g) = σ(p g).\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{AbstractGroupActionType}","page":"Group action","title":"LieGroups.switch","text":"switch(T::AbstractGroupActionType)\n\nReturn the object representing an AbstractGroupActionType related to a group operation action that switched the side, that is it turns a left action type into its corresponding right action type.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{GroupAction}","page":"Group action","title":"LieGroups.switch","text":" switch(A::GroupAction{T})\n\nReturn the group operation action representing the similar GroupAction of AbstractGroupActionType T but acting from the other side. It switches left to right and vice versa. This is done by returning the group action with the “switched” type of T.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Manifolds.apply!-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"Manifolds.apply!","text":"apply(A::GroupAction{T, L, M}, g, p)\napply!(A::GroupAction{T, L, M}, q, g, p)\n\nApply the group action induced by g  mathcal G to p  mathcal M, where the kind of group action is indicated by the AbstractGroupActionType T. This can be performed in-place of q.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Manifolds.apply-Tuple{GroupAction, Any, Any}","page":"Group action","title":"Manifolds.apply","text":"apply(A::GroupAction{T, L, M}, g, p)\napply!(A::GroupAction{T, L, M}, q, g, p)\n\nApply the group action induced by g  mathcal G to p  mathcal M, where the kind of group action is indicated by the AbstractGroupActionType T. This can be performed in-place of q.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#ManifoldsBase.base_manifold-Tuple{GroupAction}","page":"Group action","title":"ManifoldsBase.base_manifold","text":"base_manifold(A::GroupAction)\n\nReturn the AbstractManifold the group action acts upon.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Generic-Lie-group-actions","page":"Group action","title":"Generic Lie group actions","text":"","category":"section"},{"location":"interface/actions/","page":"Group action","title":"Group action","text":"Modules = [LieGroups]\nPages = [\"group_operation_action.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"interface/actions/#LieGroups.InverseLeftGroupOperationAction","page":"Group action","title":"LieGroups.InverseLeftGroupOperationAction","text":"InverseLeftGroupOperationAction <: AbstractRightGroupActionType\n\nA type for the AbstractLeftGroupActionType when acting on the group itself given by the inverse of a LeftGroupOperationAction σ_h as\n\nτ_h(g) coloneqq σ_h^-1(g) = σ(h^-1g) = h^-1g\n\nNote that while in naming it is the inverse of the left action, it's properties yield that is is an AbstractRightGroupActionType, since\n\nτ_g(τ_h(p))\n= σ^mathrmL_g^-1(σ^mathrmL_h^-1(p))\n= σ^mathrmL_g^-1h^-1(p)\n= σ^mathrmL_(hg)^-1(p)\nτ_hg(p)\n\nfor its inverse (σ_h)^-1 see InverseLeftGroupOperationAction.\n\nnote: Note\nSome literature also calls this by itself the right group operation action.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.InverseRightGroupOperationAction","page":"Group action","title":"LieGroups.InverseRightGroupOperationAction","text":"InverseRightGroupOperationAction <: AbstractLeftGroupActionType\n\nA type for the AbstractLeftGroupActionType when acting on the group itself given by the inverse of a RightGroupOperationAction σ_h as\n\nτ_h(g) coloneqq σ_h^-1(g) = σ(h^-1g) = gh^-1\n\nNote that while in naming it is the inverse of the right action, it's properties yield that is is an AbstractLeftGroupActionType, since\n\nτ_g(τ_h(p))\n= σ^mathrmR_g^-1(σ^mathrmR_h^-1(p))\n= σ^mathrmR_h^-1g^-1(p)\n= σ^mathrmR_(gh)^-1(p)\nτ_gh(p)\n\nfor its inverse (σ_h)^-1 see InverseLeftGroupOperationAction.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.LeftGroupOperationAction","page":"Group action","title":"LieGroups.LeftGroupOperationAction","text":"LeftGroupOperationAction <: AbstractLeftGroupActionType\n\nA type for the AbstractLeftGroupActionType when acting on the group itself from the left, that is\n\nσ_h(g) = σ(hg) = hg\n\nfor its inverse (σ_h)^-1 see InverseLeftGroupOperationAction.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.RightGroupOperationAction","page":"Group action","title":"LieGroups.RightGroupOperationAction","text":"RightGroupOperationAction <: AbstractRightGroupActionType\n\nA type for the AbstractLeftGroupActionType when acting on the group itself from the right.\n\nσ_h(g) = σ(hg) = gh\n\nfor its inverse (σ_h)^-1 see InverseRightGroupOperationAction.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#Base.inv-Tuple{InverseLeftGroupOperationAction}","page":"Group action","title":"Base.inv","text":"inv(::InverseLeftGroupOperationAction)\n\nReturn the inverse of the InverseLeftGroupOperationAction, that is the LeftGroupOperationAction.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Base.inv-Tuple{InverseRightGroupOperationAction}","page":"Group action","title":"Base.inv","text":"inv(::InverseRightGroupOperationAction)\n\nReturn the inverse of the InverseRightGroupOperationAction, that is the RightGroupOperationAction.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Base.inv-Tuple{LeftGroupOperationAction}","page":"Group action","title":"Base.inv","text":"inv(::LeftGroupOperationAction)\n\nReturn the inverse of the LeftGroupOperationAction, that is the InverseLeftGroupOperationAction.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Base.inv-Tuple{RightGroupOperationAction}","page":"Group action","title":"Base.inv","text":"inv(::RightGroupOperationAction)\n\nReturn the inverse of the RightGroupOperationAction, that is the InverseRightGroupOperationAction.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.GroupOperationAction-Tuple{AbstractGroupActionType, LieGroup}","page":"Group action","title":"LieGroups.GroupOperationAction","text":"GroupOperationAction(action::AbstractGroupActionType, group::LieGroup)\n\nReturn a GroupAction for an AbstractGroupActionType action representing the group operation as an action of the group on itself.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{InverseLeftGroupOperationAction}","page":"Group action","title":"LieGroups.switch","text":"switch(::InverseLeftGroupOperationAction)\n\nReturn the InverseRightGroupOperationAction, that is, turns σ_g = g^-1h into τ_g(h) = hg^-1\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{InverseRightGroupOperationAction}","page":"Group action","title":"LieGroups.switch","text":"switch(::InverseRightGroupOperationAction)\n\nReturn the InverseLeftGroupOperationAction, that is, turns σ_g = hg^-1 into τ_g(h) = g^-1h\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{LeftGroupOperationAction}","page":"Group action","title":"LieGroups.switch","text":"switch(::LeftGroupOperationAction)\n\nReturn the RightGroupOperationAction, that is, turns σ_g = gh into τ_g(h) = hg\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{RightGroupOperationAction}","page":"Group action","title":"LieGroups.switch","text":"switch(::RightGroupOperationAction)\n\nReturn the LeftGroupOperationAction, that is, turns σ_g = hg into τ_g(h) = gh\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Literature","page":"Group action","title":"Literature","text":"","category":"section"},{"location":"interface/actions/","page":"Group action","title":"Group action","text":"J. Hilgert and K.-H. Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\n","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"EditURL = \"https://github.com/JuliaManifolds/LieGroups.jl/blob/main/NEWS.md\"","category":"page"},{"location":"news/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"All notable Changes to the Julia package LieGroups.jl will be documented in this file.","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"news/#[0.1.0]-–-unreleased","page":"Changelog","title":"[0.1.0] – unreleased","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Everything denoted by “formerly” refers to the previous name in Manifolds.jl.","category":"page"},{"location":"news/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"LieAlgebra\nLieGroup (formerly GroupManifold) as well as the concrete groups\nTranslationGroup\nSpecialEuclideanGroup (formerly SpecialEuclidean) including\nSpecialEuclideanMatrixPoint and SpecialEuclideanMatrixTangentVector when representing thepoints as affine (abstract) matrices\nSpecialEuclideanProductPoint and SpecialEuclideanProductTangentVector when representing them in a product structure, e.g. as an ArrayPartition from RecursiveArrayTools.\nneither of those types is necessary, besides for conversion between both. The product representation differs for the left and right semidirect product, while the affine matrix variant does not.\nSpecialOrthogonalGroup (formerly SpecialOrthogonal)\nSpecialUnitaryGroup (formerly SpecialUnitary)\nOrthogonalGroup (formerly Orthogonal)\nUnitaryGroup (formerly Unitary)\nGeneralLinearGroup (formerly GeneralLinear)\nHeisenbergGroup\nLeftSemidirectProductLieGroup (formerly SemidirectProductGroup)\n⋉ (alias for LeftSemidirectProductGroupOperation when a default_left_action(G,H) is defined for the two groups)\nPowerLieGroup (formerly PowerGroup)\nPowerGroupOperation to internally avoid ambiguities. Since the constructor always expects a Lie group, this is only necessary internally\nProductLieGroup (formerly ProductGroup)\nRightSemidirectProductLieGroup\n⋊ (alias for RightSemidirectProductGroupOperation when a default_right_action(G,H) is defined for the two groups)\nAbstractGroupOperation as well as its concrete subtypes\nAdditionGroupOperation (formerly AdditionOperation)\nMatrixMultiplicationGroupOperation (formerly MultiplicationOperation)\nPowerGroupOperation (formerly the Lie group was stored inside a power manifold)\nProductGroupOperation (formerly the Lie groups were stored inside a product manifold)\nLeftSemidirectProductGroupOperation (this was formerly only implicitly stored in the SemidirectProductGroup)\nRightSemidirectProductGroupOperation\nAbstractGroupActionType with its 2 specific (new) abstract subtypes\nAbstractLeftGroupActionType\nAbstractRightGroupActionType\nFor the group operation actions there are now\nLeftGroupOperationAction (formerly LeftForwardAction)\nRightGroupOperationAction (formerly RightBackwardAction)\nInverseLeftGroupOperationAction (formerly RightForwardAction)\nInverseRightGroupOperationAction (formerly LeftBackwardAction)\nDefaultLieAlgebraOrthogonalBasis (replaces VeeOrthogonalBasis, which is still available in ManifoldsBase.jl)\nAbstractLieGroupPoint and AbstractLieAlgebraTangentVector as abstract types to introduce point and Lie algebra tangent vector representations\nIdentity\napplyand apply!\nbase_manifold to access the manifold within a Lie group\ncompose and compose!\nconjugate and conjugate!\ndiff_apply, diff_apply!, diff_group_apply, and diff_group_apply! (formerly apply_diff_[group][!])\ndiff_conjugate and diff_conjugate!\ndiff_left_compose, diff_left_compose!, diff_right_compose, diff_right_compose! (formerly translate_diff with different sides)\nexp(G::LieGroup, g, X) and exp!(G::LieGroup, h, g, X) (formerly exp_inv and exp_inv!)\nexp(G::LieGroup, X) and exp!(G::LieGroup, h, X) (formerly exp_lie and exp_lie!)\nhat and hat!, with slightly different signatures, since the base point is omitted.\nidentity_element and identity_element!\ninv and inv! (inv(::AbstractGroupAction) was formerly switch_direction)\ninv_left_compose, inv_left_compose! and inv_right_compose, inv_right_compose! (these functions correspond to inverse_translate with corresponding direction and side)\nis_identity\nlie_bracket and lie_bracket!\njacobian_conjugate (formerly adjoint_matrix, which is now a special case of this)\nlog(G::LieGroup, g, h) and log!(G::LieGroup, X, g, h) (formerly log_inv and log_inv!)\nlog(G::LieGroup, ::Identity, g) and log!(G::LieGroup, X, ::Identity, g) (formerly log_lie and log_lie!)\nswitch (formerly switch_side)\nvee and vee!, with slightly different signatures, since the base point is omitted.","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Compared to Manifolds.jl","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"all translate functions are not implemented here, since you can just use compose. The differentials are implemented as listed above with respect to both left and right argument of compose\nall inverse_apply functions are not implemented here, since it is recommended to use apply(inv(A), g, p) as a replacement.","category":"page"},{"location":"news/#[0.0.3]-–-unreleased","page":"Changelog","title":"[0.0.3] – unreleased","text":"","category":"section"},{"location":"news/#Added-2","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Finishes most of the work on the interface for the LieGroup type and the new LieAlgebra type.\nFinishes a generic implementation of a SemiDirectProductGroupOperation\nAll details will be detailed in the next release","category":"page"},{"location":"news/#Old-Changelog-pre-0.0.3","page":"Changelog","title":"Old Changelog pre 0.0.3","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Two previous releases where done by Yueh-Hua Tu in 2022 before he was so kind to transfer the development to the JuliaManifolds GitHub organisation.","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"All notable changes to this project will be documented in this file.","category":"page"},{"location":"news/#[0.0.2]","page":"Changelog","title":"[0.0.2]","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"fix SE{3} and add jacobian\ndefine dof and dim for Lie algebra and jacobian of inv\nadd action for SE{N}\nadd se3_location example","category":"page"},{"location":"interface/group/#An-interface-for-Lie-groups","page":"Lie group","title":"An interface for Lie groups","text":"","category":"section"},{"location":"interface/group/","page":"Lie group","title":"Lie group","text":"LieGroup\nAbstractLieAlgebraTangentVector\nAbstractLieGroupPoint","category":"page"},{"location":"interface/group/#LieGroups.LieGroup","page":"Lie group","title":"LieGroups.LieGroup","text":"LieGroup{𝔽, O<:AbstractGroupOperation, M<:AbstractManifold{𝔽}} <: AbstractManifold{𝔽}\n\nRepresent a Lie Group mathcal G.\n\nA Lie Group mathcal G is a group endowed with the structure of a manifold such that the group operations  mathcal Gmathcal G  mathcal G, see compose and the inverse operation ^-1 mathcal G  mathcal G, see inv are smooth, see for example [HN12, Definition 9.1.1].\n\nLie groups are named after the Norwegian mathematician Marius Sophus Lie (1842–1899).\n\nFields\n\nmanifold: an AbstractManifold mathcal M\nop: an AbstractGroupOperation  on that manifold\n\nConstructor\n\nLieGroup(M::AbstractManifold, op::AbstractGroupOperation)\n\nGenerate a Lie group based on a manifold M and a group operation op, where vectors by default are stored in the Lie Algebra.\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#LieGroups.AbstractLieAlgebraTangentVector","page":"Lie group","title":"LieGroups.AbstractLieAlgebraTangentVector","text":"AbstractLieAlgebraTangentVector <: ManifoldsBase.AbstractTangentVector\n\nAn abstract type for a tangent vector represented in a LieAlgebra.\n\nWhile an tangent vectors are usually kept untyped for flexibility, it might be necessary to distinguish different types of points, for example\n\nfor complicated representations that require a struct\n\n@ semantic verification\n\nwhen there exist different representations\n\nBy sub-typing the AbstractManifoldPoint, this follows the same idea as in ManifoldsBase.jl.\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#LieGroups.AbstractLieGroupPoint","page":"Lie group","title":"LieGroups.AbstractLieGroupPoint","text":"AbstractLieGroupPoint <: ManifoldsBase.AbstractManifoldPoint end\n\nAn abstract type for a point on a LieGroup. While an points and tangent vectors are usually kept untyped for flexibility, it might be necessary to distinguish different types of points, for example\n\nfor complicated representations that require a struct\nsemantic verification\nwhen there exist different representations\n\nBy sub-typing the AbstractManifoldPoint, this follows the same idea as in ManifoldsBase.jl.\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#Functions-on-Lie-groups","page":"Lie group","title":"Functions on Lie groups","text":"","category":"section"},{"location":"interface/group/","page":"Lie group","title":"Lie group","text":"Modules = [LieGroups]\nPages = [\"src/interface.jl\"]\nOrder = [:function]","category":"page"},{"location":"interface/group/#Base.adjoint-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"Base.adjoint","text":"adjoint(G::LieGroup, g, X)\nadjoint!(G::LieGroup, Y, g, X)\n\nCompute the adjoint mathrmAd(g) mathfrak g  mathfrak g, which is defined as the differential diff_conjugate of the conjugate c_g(h) = ghg^-1 evaluated at the Identity h=mathrme. The operation can be performed in-place of Y.\n\n  mathrmAd(g)X = D c_g(mathrme) X qquad X  mathfrak g\n\nsee [HN12, Section 9.2.3].\n\nOn matrix Lie groups the adjoint reads mathrmAd(g)X = gXg^-1.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.exp-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"Base.exp","text":"exp(G::LieGroup, g, X)\nexp!(G::LieGroup, h, g, X)\n\nCompute the Lie group exponential map for gmathcal G and Xmathfrak g, where mathfrak g denotes the LieAlgebra of mathcal G. It is given by\n\nexp_g X = gexp_mathcal G(X)\n\nwhere X can be scaled by t, the computation can be performed in-place of h, and exp_mathcal G denotes the  Lie group exponential function.\n\nIf g is the Identity the Lie group exponential function exp_mathcal G is computed directly. Implementing the Lie group exponential function introduces a default implementation with the formula above.\n\nnote: Note\nThe Lie group exponential map is usually different from the exponential map with respect to the metric of the underlying Riemannian manifold mathcal M. To access the (Riemannian) exponential map, use exp(base_manifold(G), g, X).\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.exp-Tuple{LieGroup, Any}","page":"Lie group","title":"Base.exp","text":"exp(G::LieGroup, X::T)\nexp!(G::LieGroup, g, X)\n\nCompute the (Lie group) exponential function\n\nexp_mathcal G mathfrak g  mathcal Gqquad exp_mathcal G(X) = γ_X(1)\n\nwhere γ_X is the unique solution of the initial value problem\n\nγ(0) = mathrme quad γ(s) = γ(s)X\n\nSee also [HN12, Definition 9.2.2]. On matrix Lie groups this is the same as the matrix exponential.\n\nThe computation can be performed in-place of g.\n\ninfo: Naming convention\nThere are at least two different objects usually called “exponential” that need to be distinguishedthe (Riemannian) exponential map exp(M, p, X) from ManifoldsBase.jl. This can be accessed here using exp(base_manifold(G), p, X)\nthe exponential map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric exp(G, g, X), which we use as a default within this package\nthe (matrix/Lie group) exponential function exp(G, g) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.inv-Tuple{LieGroup, Any}","page":"Lie group","title":"Base.inv","text":"inv(G::LieGroup, g)\ninv!(G::LieGroup, h, g)\n\nCompute the inverse group element g^-1 with respect to the AbstractGroupOperation  on the LieGroup mathcal G, that is, return the unique element h=g^-1 such that hg=mathrme, where mathrme denotes the Identity.\n\nThis can be done in-place of h, without side effects, that is you can do inv!(G, g, g).\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.isapprox-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"Base.isapprox","text":"isapprox(M::LieGroup, g, h; kwargs...)\n\nCheck if points g and h from LieGroup are approximately equal. this function calls the corresponding isapprox on the AbstractManifold after handling the cases where one or more of the points are the Identity. All keyword argments are passed to this function as well.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.log-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"Base.log","text":"log(G::LieGroup, g, h)\nlog!(G::LieGroup, X, g, h)\n\nCompute the Lie group logarithmic map log_g mathcal G  mathfrak g, where mathfrak g denotes the LieAlgebra of mathcal G. It is given by\n\nlog_g h = log_mathcal G(g^-1h)\n\nwhere log_mathcal G denotes the Lie group logarithmic function The computation can be performed in-place of X.\n\ninfo: Naming convention\nThere are at least two different objects usually called “logarithm” that need to be distinguishedthe (Riemannian) logarithmic map log(M, p, X) from ManifoldsBase.jl\nthe exponential map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric exp(G, g, X), which we use as a default within this package\nthe (matrix/Lie group) exponential function exp(G, g) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.log-Tuple{LieGroup, Any}","page":"Lie group","title":"Base.log","text":"log(G::LieGroup, g, h)\nlog(G::LieGroup, g)\nlog(G::LieGroup, g::Identity, T)\nlog!(G::LieGroup, X::T, g)\n\nCompute the (Lie group) logarithmic function log_mathcal G mathcal G  mathfrak g, which is the inverse of the Lie group exponential function. For the allocating variant, you can specify the type T, when the point argument is the identity and hence does not provide the representation used. The computation can be performed in-place of X::T, which then determines the type.\n\ninfo: Naming convention\nThere are at least two different objects usually called “logarithm” that need to be distinguishedthe (Riemannian) logarithm map log(M, p, q) from ManifoldsBase.jl. This can be accessed here using log(base_manifold(G), p, q).\nthe logarithmic map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric log(G, g, h), which we use as a default within this package\nthe (matrix/Lie group) logarithm function log(G, h) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.rand-Tuple{LieGroup, Type}","page":"Lie group","title":"Base.rand","text":"rand(::LieGroup; vector_at=nothing, σ::Real=1.0, kwargs...)\nrand(::LieGroup, PT::Type; vector_at=nothing, σ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, T::Type; σ::Real=1.0, kwargs...)\nrand!(::LieGroup, gX::PT; vector_at=nothing, σ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, X::T; σ::Real=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\nFor both cases, you can provide the type T for the tangent vector and/or point PT, if you want to generate a random point in a certain representation. For the in-place variants the type is inferred from pX´ andX`, respectively.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.rand-Tuple{LieGroup}","page":"Lie group","title":"Base.rand","text":"rand(::LieGroup; vector_at=nothing, σ::Real=1.0, kwargs...)\nrand(::LieGroup, PT::Type; vector_at=nothing, σ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, T::Type; σ::Real=1.0, kwargs...)\nrand!(::LieGroup, gX::PT; vector_at=nothing, σ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, X::T; σ::Real=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\nFor both cases, you can provide the type T for the tangent vector and/or point PT, if you want to generate a random point in a certain representation. For the in-place variants the type is inferred from pX´ andX`, respectively.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.compose!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.compose!","text":"compose(G::LieGroup, g, h)\ncompose!(G::LieGroup, k, g, h)\n\nPerform the group operation g  h for two g h  mathcal G on the LieGroup G. This can also be done in-place of h.\n\ninfo: Info\nThis function also handles the case where g or/and h are the Identity(G). Since this would lead to ambiguities when implementing a new group operations, this function calls _compose and _compose!, respectively, which is meant for the actual computation of group operations on (non-Identity` but maybe its numerical representation) elements.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.conjugate!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.conjugate!","text":"conjugate(G::LieGroup, g, h)\nconjugate!(G::LieGroup, k, g, h)\n\nCompute the conjugation map c_g mathcal G  mathcal G given by c_g(h) = ghg^-1. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.conjugate-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"LieGroups.conjugate","text":"conjugate(G::LieGroup, g, h)\nconjugate!(G::LieGroup, k, g, h)\n\nCompute the conjugation map c_g mathcal G  mathcal G given by c_g(h) = ghg^-1. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_conjugate!-Tuple{LieGroup, Vararg{Any, 4}}","page":"Lie group","title":"LieGroups.diff_conjugate!","text":"diff_conjugate(G::LieGroup, g, h, X)\ndiff_conjugate!(G::LieGroup, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1, which can be performed in-place of Y.\n\n  D(c_g(h))X qquad X  mathfrak g\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_conjugate-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.diff_conjugate","text":"diff_conjugate(G::LieGroup, g, h, X)\ndiff_conjugate!(G::LieGroup, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1, which can be performed in-place of Y.\n\n  D(c_g(h))X qquad X  mathfrak g\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_inv!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.diff_inv!","text":"diff_inv(G::LieGroup, g, X)\ndiff_inv!(G::LieGroup, Y, g, X)\n\nCompute the differential of the function ι_mathcal G(g) = g^-1, where Dι_mathcal G(g) mathfrak g  mathfrak g. This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_inv-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"LieGroups.diff_inv","text":"diff_inv(G::LieGroup, g, X)\ndiff_inv!(G::LieGroup, Y, g, X)\n\nCompute the differential of the function ι_mathcal G(g) = g^-1, where Dι_mathcal G(g) mathfrak g  mathfrak g. This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_left_compose!-Tuple{LieGroup, Vararg{Any, 4}}","page":"Lie group","title":"LieGroups.diff_left_compose!","text":"diff_left_compose(G::LieGroup, g, h, X)\ndiff_left_compose!(G::LieGroup, Y, g, h, X)\n\nCompute the differential of the left group multiplication λ_g(h) = gh, on the LieGroup G, that is Compute Dλ_g(h)X, X  𝔤. This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_left_compose-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.diff_left_compose","text":"diff_left_compose(G::LieGroup, g, h, X)\ndiff_left_compose!(G::LieGroup, Y, g, h, X)\n\nCompute the differential of the left group multiplication λ_g(h) = gh, on the LieGroup G, that is Compute Dλ_g(h)X, X  𝔤. This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_right_compose!-Tuple{LieGroup, Vararg{Any, 4}}","page":"Lie group","title":"LieGroups.diff_right_compose!","text":"diff_right_compose(G::LieGroup, h, g, X)\ndiff_right_compose!(G::LieGroup, Y, h, g, X)\n\nCompute the differential of the right group multiplication ρ_g(h) = hg, on the LieGroup G, that is Compute Dρ_g(h)X, X  𝔤 This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_right_compose-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.diff_right_compose","text":"diff_right_compose(G::LieGroup, h, g, X)\ndiff_right_compose!(G::LieGroup, Y, h, g, X)\n\nCompute the differential of the right group multiplication ρ_g(h) = hg, on the LieGroup G, that is Compute Dρ_g(h)X, X  𝔤 This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.identity_element!-Tuple{LieGroup, Any}","page":"Lie group","title":"LieGroups.identity_element!","text":"identity_element(G::LieGroup)\nidentity_element(G::LieGroup, T)\nidentity_element!(G::LieGroup, e::T)\n\nReturn a point representation of the Identity on the LieGroup G. By default this representation is the default array or number representation. If there exist several representations, the type T can be used to distinguish between them, and it should be provided for both the AbstractLieGroupPoint as well as the AbstractLieAlgebraTangentVector if they differ, since maybe only one of these types might be available for the second signature.\n\nIt returns the corresponding default representation of e as a point on G. This can be performed in-place of e.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv!-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"LieGroups.inv!","text":"inv(G::LieGroup, g)\ninv!(G::LieGroup, h, g)\n\nCompute the inverse group element g^-1 with respect to the AbstractGroupOperation  on the LieGroup mathcal G, that is, return the unique element h=g^-1 such that hg=mathrme, where mathrme denotes the Identity.\n\nThis can be done in-place of h, without side effects, that is you can do inv!(G, g, g).\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv_left_compose!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.inv_left_compose!","text":"compose(G::LieGroup, g, h)\ncompose!(G::LieGroup, k, g, h)\n\nPerform the group operation g  h for two g h  mathcal G on the LieGroup G. This can also be done in-place of h.\n\ninfo: Info\nThis function also handles the case where g or/and h are the Identity(G). Since this would lead to ambiguities when implementing a new group operations, this function calls _compose and _compose!, respectively, which is meant for the actual computation of group operations on (non-Identity` but maybe its numerical representation) elements.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv_left_compose-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"LieGroups.inv_left_compose","text":"inv_left_compose(G::LieGroup, g, h)\ninv_left_compose!(G::LieGroup, k, g, h)\n\nCompute the inverse of the left group operation λ_g(h) = gh, on the LieGroup G, that is, compute λ_g^-1(h) = g^-1h. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv_right_compose!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.inv_right_compose!","text":"inv_right_compose(G::LieGroup, h, g)\ninv_right_compose!(G::LieGroup, k, h, g)\n\nCompute the inverse of the right group operation ρ_g(h) = hg, on the LieGroup G, that is compute ρ_g^-1(h) = hg^-1. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv_right_compose-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"LieGroups.inv_right_compose","text":"inv_right_compose(G::LieGroup, h, g)\ninv_right_compose!(G::LieGroup, k, h, g)\n\nCompute the inverse of the right group operation ρ_g(h) = hg, on the LieGroup G, that is compute ρ_g^-1(h) = hg^-1. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.jacobian_conjugate","page":"Lie group","title":"LieGroups.jacobian_conjugate","text":"jacobian_conjugate(G::LieGroup, g, h, B::AbstractBasis=DefaultLieAlgebraOrthogonalBasis())\njacobian_conjugate!(G::LieGroup, J, g, h, B::AbstractBasis=DefaultLieAlgebraOrthogonalBasis())\n\nCompute the Jacobian of the conjugate c_g(h) = ghg^-1, with respect to an AbstractBasis.\n\nThis can be seen as a matrix representation of the diff_conjugate D(c_g(h))X with respect to the given basis.\n\nnote: Note\nFor the case that h is the Identity and the relation of D(c_g(h))X to the adjoint mathrmAd(g), the Jacobian then sometimes called “adjoint matrix”, e.g. in [SDA21], when choosing as a basis the DefaultLieAlgebraOrthogonalBasis() that is used for hat and vee.\n\n\n\n\n\n","category":"function"},{"location":"interface/group/#LieGroups.jacobian_conjugate!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.jacobian_conjugate!","text":"jacobian_conjugate(G::LieGroup, g, h, B::AbstractBasis=DefaultLieAlgebraOrthogonalBasis())\njacobian_conjugate!(G::LieGroup, J, g, h, B::AbstractBasis=DefaultLieAlgebraOrthogonalBasis())\n\nCompute the Jacobian of the conjugate c_g(h) = ghg^-1, with respect to an AbstractBasis.\n\nThis can be seen as a matrix representation of the diff_conjugate D(c_g(h))X with respect to the given basis.\n\nnote: Note\nFor the case that h is the Identity and the relation of D(c_g(h))X to the adjoint mathrmAd(g), the Jacobian then sometimes called “adjoint matrix”, e.g. in [SDA21], when choosing as a basis the DefaultLieAlgebraOrthogonalBasis() that is used for hat and vee.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LinearAlgebra.adjoint!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LinearAlgebra.adjoint!","text":"adjoint(G::LieGroup, g, X)\nadjoint!(G::LieGroup, Y, g, X)\n\nCompute the adjoint mathrmAd(g) mathfrak g  mathfrak g, which is defined as the differential diff_conjugate of the conjugate c_g(h) = ghg^-1 evaluated at the Identity h=mathrme. The operation can be performed in-place of Y.\n\n  mathrmAd(g)X = D c_g(mathrme) X qquad X  mathfrak g\n\nsee [HN12, Section 9.2.3].\n\nOn matrix Lie groups the adjoint reads mathrmAd(g)X = gXg^-1.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Manifolds.compose-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"Manifolds.compose","text":"compose(G::LieGroup, g, h)\ncompose!(G::LieGroup, k, g, h)\n\nPerform the group operation g  h for two g h  mathcal G on the LieGroup G. This can also be done in-place of h.\n\ninfo: Info\nThis function also handles the case where g or/and h are the Identity(G). Since this would lead to ambiguities when implementing a new group operations, this function calls _compose and _compose!, respectively, which is meant for the actual computation of group operations on (non-Identity` but maybe its numerical representation) elements.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Manifolds.identity_element-Tuple{LieGroup}","page":"Lie group","title":"Manifolds.identity_element","text":"identity_element(G::LieGroup)\nidentity_element(G::LieGroup, T)\nidentity_element!(G::LieGroup, e::T)\n\nReturn a point representation of the Identity on the LieGroup G. By default this representation is the default array or number representation. If there exist several representations, the type T can be used to distinguish between them, and it should be provided for both the AbstractLieGroupPoint as well as the AbstractLieAlgebraTangentVector if they differ, since maybe only one of these types might be available for the second signature.\n\nIt returns the corresponding default representation of e as a point on G. This can be performed in-place of e.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Manifolds.is_identity-Tuple{LieGroup, Any}","page":"Lie group","title":"Manifolds.is_identity","text":"is_identity(G::LieGroup, q; kwargs...)\n\nCheck whether q is the identity on the LieGroup mathcal G. This means it is either the Identity{O} with the respect to the corresponding AbstractGroupOperation O, or (approximately) the correct point representation.\n\nSee also\n\nidentity_element, identity_element!\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.base_manifold-Tuple{LieGroup}","page":"Lie group","title":"ManifoldsBase.base_manifold","text":"base_manifold(G::LieGroup)\n\nReturn the manifold stored within the LieGroup G.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.exp!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"ManifoldsBase.exp!","text":"exp(G::LieGroup, g, X)\nexp!(G::LieGroup, h, g, X)\n\nCompute the Lie group exponential map for gmathcal G and Xmathfrak g, where mathfrak g denotes the LieAlgebra of mathcal G. It is given by\n\nexp_g X = gexp_mathcal G(X)\n\nwhere X can be scaled by t, the computation can be performed in-place of h, and exp_mathcal G denotes the  Lie group exponential function.\n\nIf g is the Identity the Lie group exponential function exp_mathcal G is computed directly. Implementing the Lie group exponential function introduces a default implementation with the formula above.\n\nnote: Note\nThe Lie group exponential map is usually different from the exponential map with respect to the metric of the underlying Riemannian manifold mathcal M. To access the (Riemannian) exponential map, use exp(base_manifold(G), g, X).\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.exp!-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"ManifoldsBase.exp!","text":"exp(G::LieGroup, X::T)\nexp!(G::LieGroup, g, X)\n\nCompute the (Lie group) exponential function\n\nexp_mathcal G mathfrak g  mathcal Gqquad exp_mathcal G(X) = γ_X(1)\n\nwhere γ_X is the unique solution of the initial value problem\n\nγ(0) = mathrme quad γ(s) = γ(s)X\n\nSee also [HN12, Definition 9.2.2]. On matrix Lie groups this is the same as the matrix exponential.\n\nThe computation can be performed in-place of g.\n\ninfo: Naming convention\nThere are at least two different objects usually called “exponential” that need to be distinguishedthe (Riemannian) exponential map exp(M, p, X) from ManifoldsBase.jl. This can be accessed here using exp(base_manifold(G), p, X)\nthe exponential map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric exp(G, g, X), which we use as a default within this package\nthe (matrix/Lie group) exponential function exp(G, g) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.is_point-Tuple{LieGroup, Any}","page":"Lie group","title":"ManifoldsBase.is_point","text":"is_point(G::LieGroup, g; kwargs...)\n\nCheck whether g is a valid point on the Lie Group G. This falls back to checking whether g is a valid point on the base_manifoldG. unless g is an Identity. Then, it is checked whether it is the identity element corresponding to G.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.log!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"ManifoldsBase.log!","text":"log(G::LieGroup, g, h)\nlog!(G::LieGroup, X, g, h)\n\nCompute the Lie group logarithmic map log_g mathcal G  mathfrak g, where mathfrak g denotes the LieAlgebra of mathcal G. It is given by\n\nlog_g h = log_mathcal G(g^-1h)\n\nwhere log_mathcal G denotes the Lie group logarithmic function The computation can be performed in-place of X.\n\ninfo: Naming convention\nThere are at least two different objects usually called “logarithm” that need to be distinguishedthe (Riemannian) logarithmic map log(M, p, X) from ManifoldsBase.jl\nthe exponential map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric exp(G, g, X), which we use as a default within this package\nthe (matrix/Lie group) exponential function exp(G, g) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.log!-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"ManifoldsBase.log!","text":"log(G::LieGroup, g, h)\nlog(G::LieGroup, g)\nlog(G::LieGroup, g::Identity, T)\nlog!(G::LieGroup, X::T, g)\n\nCompute the (Lie group) logarithmic function log_mathcal G mathcal G  mathfrak g, which is the inverse of the Lie group exponential function. For the allocating variant, you can specify the type T, when the point argument is the identity and hence does not provide the representation used. The computation can be performed in-place of X::T, which then determines the type.\n\ninfo: Naming convention\nThere are at least two different objects usually called “logarithm” that need to be distinguishedthe (Riemannian) logarithm map log(M, p, q) from ManifoldsBase.jl. This can be accessed here using log(base_manifold(G), p, q).\nthe logarithmic map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric log(G, g, h), which we use as a default within this package\nthe (matrix/Lie group) logarithm function log(G, h) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Random.rand!-Tuple{LieGroup, Any}","page":"Lie group","title":"Random.rand!","text":"rand(::LieGroup; vector_at=nothing, σ::Real=1.0, kwargs...)\nrand(::LieGroup, PT::Type; vector_at=nothing, σ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, T::Type; σ::Real=1.0, kwargs...)\nrand!(::LieGroup, gX::PT; vector_at=nothing, σ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, X::T; σ::Real=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\nFor both cases, you can provide the type T for the tangent vector and/or point PT, if you want to generate a random point in a certain representation. For the in-place variants the type is inferred from pX´ andX`, respectively.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Internal-functions-and-macros","page":"Lie group","title":"Internal functions and macros","text":"","category":"section"},{"location":"interface/group/","page":"Lie group","title":"Lie group","text":"LieGroups.CommonUnitarySubAlgebra\nLieGroups.@default_lie_group_fallbacks","category":"page"},{"location":"interface/group/#LieGroups.CommonUnitarySubAlgebra","page":"Lie group","title":"LieGroups.CommonUnitarySubAlgebra","text":"CommonUnitarySubAlgebra{𝔽,T}\n\nA constant that allows to refer to several sub Algebras of mathfrak u(n) for implementations where\n\ncertain sub algebras real/complex share a common implementation, e.g. for the same sizes T usually via TypeParameter\ncertain functions are the same for all sizes T as long as the field 𝔽 is the same\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#LieGroups.@default_lie_group_fallbacks","page":"Lie group","title":"LieGroups.@default_lie_group_fallbacks","text":"default_lie_group_fallbacks(TG, TF, TP, TV, pfield::Symbol, Xfield::Symbol, groupOp)\n\nIntroduce default fallbacks for all basic functions on Lie groups, for Lie group of type TG with group operation Op, points of type TP, tangent vectors of type TV, with forwarding to fields pfield and Xfield for point and tangent vector functions, respectively.\n\n\n\n\n\n","category":"macro"},{"location":"interface/group/#Literature","page":"Lie group","title":"Literature","text":"","category":"section"},{"location":"interface/group/","page":"Lie group","title":"Lie group","text":"J. Hilgert and K.-H. Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\nJ. Solà, J. Deray and D. Atchuthan. A micro Lie theory for state estimation in robotics (Dec 2021), arXiv:1812.01537 [cs.RO], arXiv: 1812.01537.\n\n\n\n","category":"page"},{"location":"interface/algebra/#An-interface-for-Lie-algebras","page":"Lie algebra","title":"An interface for Lie algebras","text":"","category":"section"},{"location":"interface/algebra/","page":"Lie algebra","title":"Lie algebra","text":"LieAlgebra\nDefaultLieAlgebraOrthogonalBasis","category":"page"},{"location":"interface/algebra/#LieGroups.LieAlgebra","page":"Lie algebra","title":"LieGroups.LieAlgebra","text":"LieAlgebra{𝔽, G} <: AbstractManifold{𝔽}\n\nRepresent the Lie algebra mathfrak g, that is a 𝔽 vector space with an associated lie_bracket  mathfrak gmathfrak g  mathfrak g which fulfills\n\nXX = 0 for all X  mathfrak g\nThe Jacobi identity X YZ = XYZ = Y XZ holds for all X Y Z  mathfrak g.\n\nThe Lie algebras considered here are those related to a LieGroup mathcal G, namely the tangent space T_mathrmemathcal G at the Identity, this is internally just a const of the corresponding TangentSpace.\n\nnote: Convention for representing tangent vectors in the Lie algebra\nA vector field mathcal X mathcal G  Tmathcal G, X(g)  T_gmathcal G is called a left-invariant vector field if it satisfiesmathcal X(λ_g(h)) = Dλ_g(h)mathcal X(h) quadtextfor allquad g h  mathcal Gwhere λ_g mathcal G  mathcal G is the left multiplication by g. Hence mathcal X is determined already when X  mathfrak g is given, since mathcal X(g) = Dλ_g(e)X, cf [HN12, Definition 9.1.7].Throughout LieGroups.jl, we use this left-invariant convention to store tangent vectors at points on a Lie group as elements of the corresponding Lie algebra.\n\nConstructor\n\nLieAlgebra(G::LieGroup)\n\nReturn the Lie Algebra belonging to the LieGroup G.\n\n\n\n\n\n","category":"type"},{"location":"interface/algebra/#LieGroups.DefaultLieAlgebraOrthogonalBasis","page":"Lie algebra","title":"LieGroups.DefaultLieAlgebraOrthogonalBasis","text":"DefaultLieAlgebraOrthogonalBasis{𝔽} <: ManifoldsBase.AbstractOrthogonalBasis{𝔽,ManifoldsBase.TangentSpaceType}\n\nSpecify an orthogonal basis for a Lie algebra. This is used as the default within hat and vee.\n\nIf not specifically overwritten/implemented for a Lie group, the DefaultOrthogonalBasis at the identity_element on the `base_manifold acts as a fallback.\n\nnote: Note\nIn order to implement the corresponding get_coordinates and get_vector functions, define get_coordinates_lie(::LieGroup, p, X, B) and get_vector_lie(::LieGroup, p, X, B), resp.\n\n\n\n\n\n","category":"type"},{"location":"interface/algebra/#Functions-on-Lie-algebras","page":"Lie algebra","title":"Functions on Lie algebras","text":"","category":"section"},{"location":"interface/algebra/","page":"Lie algebra","title":"Lie algebra","text":"Modules = [LieGroups]\nPages = [\"src/Lie_algebra/Lie_algebra_interface.jl\"]\nOrder = [:function]","category":"page"},{"location":"interface/algebra/#Base.rand-Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(LieGroup{𝔽, O, M} where M<:ManifoldsBase.AbstractManifold{𝔽})}}","page":"Lie algebra","title":"Base.rand","text":"rand(::LieGroup; vector_at=nothing, σ=1.0, kwargs...)\nrand(::LieAlgebra; σ=1.0, kwargs...)\nrand!(::LieGroup, gX; vector_at=nothing, kwargs...)\nrand!(::LieAlgebra, X; σ=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#LieGroups.base_lie_group-Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(LieGroup{𝔽, O, M} where M<:ManifoldsBase.AbstractManifold{𝔽})}}","page":"Lie algebra","title":"LieGroups.base_lie_group","text":"base_lie_group(𝔤::LieAlgebra)\n\nReturn the base_lie_group of the given LieAlgebra belongs to.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#LieGroups.lie_bracket!-Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(LieGroup{𝔽, O, M} where M<:ManifoldsBase.AbstractManifold{𝔽})}, Any, Any, Any}","page":"Lie algebra","title":"LieGroups.lie_bracket!","text":"lie_bracket!(𝔤::LieAlgebra, X, Y)\nlie_bracket!(𝔤::LieAlgebra, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g which fulfills\n\nXX = 0 for all X  mathfrak g\nThe Jacobi identity X YZ = XYZ = Y XZ holds for all X Y Z  mathfrak g.\n\nThe computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#LieGroups.lie_bracket-Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(LieGroup{𝔽, O, M} where M<:ManifoldsBase.AbstractManifold{𝔽})}, Any, Any}","page":"Lie algebra","title":"LieGroups.lie_bracket","text":"lie_bracket!(𝔤::LieAlgebra, X, Y)\nlie_bracket!(𝔤::LieAlgebra, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g which fulfills\n\nXX = 0 for all X  mathfrak g\nThe Jacobi identity X YZ = XYZ = Y XZ holds for all X Y Z  mathfrak g.\n\nThe computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.base_manifold-Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(LieGroup{𝔽, O, M} where M<:ManifoldsBase.AbstractManifold{𝔽})}}","page":"Lie algebra","title":"ManifoldsBase.base_manifold","text":"base_manifold(𝔤::LieAlgebra)\n\nReturn the base_manifold the LieGroup of the given LieAlgebra is based on.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.get_coordinates","page":"Lie algebra","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(𝔤::LieAlgebra, X::T, B::AbstractBasis)\nget_coordinates!(𝔤::LieAlgebra, c, X::T, B::AbstractBasis)\n\nReturn the vector of coordinates to the decomposition of X with respect to an AbstractBasis of the LieAlgebra 𝔤. The operation can be performed in-place of c.\n\nBy default this function requires that identity_element(G, T) is available and calls the corresponding get_coordinates function of the Riemannian manifold the Lie group is build on.\n\nThe inverse operation is get_vector.\n\nSee also vee.\n\n\n\n\n\n","category":"function"},{"location":"interface/algebra/#ManifoldsBase.get_coordinates!","page":"Lie algebra","title":"ManifoldsBase.get_coordinates!","text":"get_coordinates(𝔤::LieAlgebra, X::T, B::AbstractBasis)\nget_coordinates!(𝔤::LieAlgebra, c, X::T, B::AbstractBasis)\n\nReturn the vector of coordinates to the decomposition of X with respect to an AbstractBasis of the LieAlgebra 𝔤. The operation can be performed in-place of c.\n\nBy default this function requires that identity_element(G, T) is available and calls the corresponding get_coordinates function of the Riemannian manifold the Lie group is build on.\n\nThe inverse operation is get_vector.\n\nSee also vee.\n\n\n\n\n\n","category":"function"},{"location":"interface/algebra/#ManifoldsBase.get_vector","page":"Lie algebra","title":"ManifoldsBase.get_vector","text":"get_vector(G::LieGroup, c, B::AbstractBasis; kwargs...)\nget_vector(𝔤::LieAlgebra, c, B::AbstractBasis; kwargs...)\nget_vector!(G::LieGroup, X::T, c, B::AbstractBasis; kwargs...)\nget_vector!(𝔤::LieAlgebra, X::T, c, B::AbstractBasis; kwargs...)\n\nReturn the vector corresponding to a set of coefficients in an AbstractBasis of the LieAlgebra 𝔤. Since all tangent vectors are assumed to be represented in the Lie algebra, both signatures are equivalent. The operation can be performed in-place of a tangent vector X of type ::T.\n\nBy default this function requires identity_element(G) and calls the corresponding get_vector function of the Riemannian manifold the Lie group is build on.\n\nThe inverse operation is get_coordinates.\n\nKeyword arguments\n\ntangent_vector_type specify the tangent vector type to use for the allocating variants.\n\nSee also hat\n\n\n\n\n\n","category":"function"},{"location":"interface/algebra/#ManifoldsBase.get_vector!","page":"Lie algebra","title":"ManifoldsBase.get_vector!","text":"get_vector(G::LieGroup, c, B::AbstractBasis; kwargs...)\nget_vector(𝔤::LieAlgebra, c, B::AbstractBasis; kwargs...)\nget_vector!(G::LieGroup, X::T, c, B::AbstractBasis; kwargs...)\nget_vector!(𝔤::LieAlgebra, X::T, c, B::AbstractBasis; kwargs...)\n\nReturn the vector corresponding to a set of coefficients in an AbstractBasis of the LieAlgebra 𝔤. Since all tangent vectors are assumed to be represented in the Lie algebra, both signatures are equivalent. The operation can be performed in-place of a tangent vector X of type ::T.\n\nBy default this function requires identity_element(G) and calls the corresponding get_vector function of the Riemannian manifold the Lie group is build on.\n\nThe inverse operation is get_coordinates.\n\nKeyword arguments\n\ntangent_vector_type specify the tangent vector type to use for the allocating variants.\n\nSee also hat\n\n\n\n\n\n","category":"function"},{"location":"interface/algebra/#ManifoldsBase.hat!-Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(LieGroup{𝔽, O, M} where M<:ManifoldsBase.AbstractManifold{𝔽})}, Any, Any}","page":"Lie algebra","title":"ManifoldsBase.hat!","text":"hat(G::LieAlgebra, c)\nhat(G::LieAlgebra, c, T::Type)\nhat!(G::LieAlgebra, X::T, c)\n\nCompute the hat map ()^  mathcal V  𝔤 that maps a vector of coordinates mathbfc  mathcal V, to a tangent vector X  mathfrak g. The coefficients are given with respect to a specific basis to a tangent vector in the Lie algebra\n\nX = sum_imathcal I c_iB_i\n\nwhere  B_i _imathcal I is a basis of the Lie algebra and mathcal I a corresponding index set, which is usually mathcal I= 1ldotsn . Then mathcal V = ℝ^n.\n\nFor the allocating variant, you can specify the type T of the tangent vector to obtain, in case there are different representations. The first signature produces the default representation.\n\nThe computation can be performed in-place of X. The inverse of hat is vee. Technically, hat is a specific case of get_vector and is implemented using the DefaultLieAlgebraOrthogonalBasis.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.hat-Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(LieGroup{𝔽, O, M} where M<:ManifoldsBase.AbstractManifold{𝔽})}, Any}","page":"Lie algebra","title":"ManifoldsBase.hat","text":"hat(G::LieAlgebra, c)\nhat(G::LieAlgebra, c, T::Type)\nhat!(G::LieAlgebra, X::T, c)\n\nCompute the hat map ()^  mathcal V  𝔤 that maps a vector of coordinates mathbfc  mathcal V, to a tangent vector X  mathfrak g. The coefficients are given with respect to a specific basis to a tangent vector in the Lie algebra\n\nX = sum_imathcal I c_iB_i\n\nwhere  B_i _imathcal I is a basis of the Lie algebra and mathcal I a corresponding index set, which is usually mathcal I= 1ldotsn . Then mathcal V = ℝ^n.\n\nFor the allocating variant, you can specify the type T of the tangent vector to obtain, in case there are different representations. The first signature produces the default representation.\n\nThe computation can be performed in-place of X. The inverse of hat is vee. Technically, hat is a specific case of get_vector and is implemented using the DefaultLieAlgebraOrthogonalBasis.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.is_point-Union{Tuple{T}, Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(LieGroup{𝔽, O, M} where M<:ManifoldsBase.AbstractManifold{𝔽})}, T}} where T","page":"Lie algebra","title":"ManifoldsBase.is_point","text":"is_point(𝔤::LieAlgebra, X; kwargs...)\n\nCheck whether X is a valid point on the Lie Algebra 𝔤. This falls back to checking whether X is a valid point on the tangent space at the identity_element(G) on the base_manifold(G) on the LieGroup of 𝔤\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.vee!-Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(LieGroup{𝔽, O, M} where M<:ManifoldsBase.AbstractManifold{𝔽})}, Any, Any}","page":"Lie algebra","title":"ManifoldsBase.vee!","text":"vee(𝔤::LieAlgebra, X)\nvee!(𝔤::LieAlgebra, c, X)\n\nCompute the vee map ()^ mathfrak g  mathcal V that maps a tangent vector X from the LieAlgebra \\mathfrak g to its coordinates with respect to the DefaultLieAlgebraOrthogonalBasis basis in the Lie algebra\n\nX = sum_imathcal I c_iB_i\n\nwhere  B_i _imathcal I is a basis of the Lie algebra and mathcal I a corresponding index set, which is usually mathcal I= 1ldotsn . Then mathcal V = ℝ^n\n\nThe computation can be performed in-place of c. The inverse of vee is hat. Technically, vee is a specific case of get_coordinates and is implemented using the DefaultLieAlgebraOrthogonalBasis.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.vee-Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(LieGroup{𝔽, O, M} where M<:ManifoldsBase.AbstractManifold{𝔽})}, Any}","page":"Lie algebra","title":"ManifoldsBase.vee","text":"vee(𝔤::LieAlgebra, X)\nvee!(𝔤::LieAlgebra, c, X)\n\nCompute the vee map ()^ mathfrak g  mathcal V that maps a tangent vector X from the LieAlgebra \\mathfrak g to its coordinates with respect to the DefaultLieAlgebraOrthogonalBasis basis in the Lie algebra\n\nX = sum_imathcal I c_iB_i\n\nwhere  B_i _imathcal I is a basis of the Lie algebra and mathcal I a corresponding index set, which is usually mathcal I= 1ldotsn . Then mathcal V = ℝ^n\n\nThe computation can be performed in-place of c. The inverse of vee is hat. Technically, vee is a specific case of get_coordinates and is implemented using the DefaultLieAlgebraOrthogonalBasis.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.zero_vector-Union{Tuple{O}, Tuple{𝔽}, Tuple{LieGroup{𝔽, var\"#s20\", M} where {var\"#s20\"<:O, M<:ManifoldsBase.AbstractManifold{𝔽}}, Type}} where {𝔽, O<:AbstractGroupOperation}","page":"Lie algebra","title":"ManifoldsBase.zero_vector","text":"zero_vector(𝔤::LieAlgebra)\nzero_vector(𝔤::LieAlgebra, T::Type)\nzero_vector!(𝔤::LieAlgebra, X::T)\n\nGenerate a zero_vector of type T in the LieAlgebra 𝔤 of the LieGroup G. By default this calls zero_vector on the manifold of G at the identity_element(G,T)\n\nFor the allocating variant the type T of the zero vector can be specified.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#Random.rand!-Tuple{ManifoldsBase.Fiber{𝔽, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {𝔽, O<:AbstractGroupOperation, G<:(LieGroup{𝔽, O, M} where M<:ManifoldsBase.AbstractManifold{𝔽})}, Any}","page":"Lie algebra","title":"Random.rand!","text":"rand(::LieGroup; vector_at=nothing, σ=1.0, kwargs...)\nrand(::LieAlgebra; σ=1.0, kwargs...)\nrand!(::LieGroup, gX; vector_at=nothing, kwargs...)\nrand!(::LieAlgebra, X; σ=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#Internal-functions-and-macros","page":"Lie algebra","title":"Internal functions and macros","text":"","category":"section"},{"location":"interface/algebra/","page":"Lie algebra","title":"Lie algebra","text":"LieGroups.@default_lie_algebra_fallbacks","category":"page"},{"location":"interface/algebra/#LieGroups.@default_lie_algebra_fallbacks","page":"Lie algebra","title":"LieGroups.@default_lie_algebra_fallbacks","text":"default_lie_algebra_fallbacks(TG, TF, Op, TV, Xfield::Symbol)\n\nIntroduce default fallbacks for all basic functions on Lie algebras, for Lie group of type TG with number system TF, an group operation Op, tangent vectors of type TV, with forwarding to fields Xfield and tangent vector functions\n\n\n\n\n\n","category":"macro"},{"location":"interface/algebra/#Literature","page":"Lie algebra","title":"Literature","text":"","category":"section"},{"location":"interface/algebra/","page":"Lie algebra","title":"Lie algebra","text":"J. Hilgert and K.-H. Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\n","category":"page"},{"location":"groups/unitary_group/#The-unitary-group","page":"Unitary group","title":"The unitary group","text":"","category":"section"},{"location":"groups/unitary_group/","page":"Unitary group","title":"Unitary group","text":"UnitaryGroup","category":"page"},{"location":"groups/unitary_group/#LieGroups.UnitaryGroup","page":"Unitary group","title":"LieGroups.UnitaryGroup","text":"UnitaryGroup{T}\n\nThe special orthogonal group mathrmU(n) is the Lie group consisting of the MatrixMultiplicationGroupOperation on the manifold of rotations UnitaryMatrices with absolute value of the determinant equal to one.\n\nConstructor\n\nUnitaryGroup(n::Int; kwargs...)\n\nGenerate unitary group mathrmU(n). All keyword arguments in kwargs... are passed on to Rotations as well.\n\n\n\n\n\n","category":"type"},{"location":"groups/unitary_group/","page":"Unitary group","title":"Unitary group","text":"For this Lie group, several implementations are already covered by the defaults in the generic (matrix) multiplication operation. Besides that the following methods are implemented:","category":"page"},{"location":"groups/unitary_group/","page":"Unitary group","title":"Unitary group","text":"Modules = [LieGroups]\nPages = [\"groups/unitary.jl\"]\nOrder = [:function]","category":"page"},{"location":"groups/unitary_group/#Utility-functions-and-constants","page":"Unitary group","title":"Utility functions and constants","text":"","category":"section"},{"location":"groups/unitary_group/","page":"Unitary group","title":"Unitary group","text":"LieGroups.CommonUnitarySubGroup","category":"page"},{"location":"groups/unitary_group/#LieGroups.CommonUnitarySubGroup","page":"Unitary group","title":"LieGroups.CommonUnitarySubGroup","text":"CommonUnitarySubGroup{𝔽,T}\n\nA constant that allows to refer to several subgroups of mathrmU(n) for implementations where\n\ncertain subgroups real/complex share a common implementation, e.g. for the same sizes T usually via TypeParameter\ncertain functions are the same for all sizes T as long as the field 𝔽 is the same\n\n\n\n\n\n","category":"type"},{"location":"groups/semidirect_product_group/#The-semidirect-product-Lie-group","page":"Semidirect product group","title":"The semidirect product Lie group","text":"","category":"section"},{"location":"groups/semidirect_product_group/","page":"Semidirect product group","title":"Semidirect product group","text":"Modules = [LieGroups]\nPages = [\"groups/semidirect_product_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/semidirect_product_group/#LieGroups.LeftSemidirectProductGroupOperation","page":"Semidirect product group","title":"LieGroups.LeftSemidirectProductGroupOperation","text":"LeftSemidirectProductGroupOperation{O1,O2,A} <: SemiDirectProductGroupOperation{O1,O2,A}\n\nA struct to model a semidirect Lie group product.\n\nLet (mathcal N ) and (mathcal H ) be two Lie groups with group operations  and , respectively, as well as a group action σ mathcal Hmathcal N  mathcal N, cf AbstractLeftGroupActionType.\n\nWe use here as well use the notation σ_h mathcal N  mathcal N as a family of maps on mathcal N\n\nThen we define a group operation  on the product manifold mathcal Nmathcal H by\n\n    (h_1n_1)  (h_2n_2) = (h_1  h_2 σ_h_2(n_1)  n_2)\n\nSee [HN12, Definition 9.2.22], second definition for more details.\n\nConstructor\n\nLeftSemidirectProductGroupOperation(\n    op1::AbstractGroupOperation,\n    op2::AbstractGroupOperation,\n    action::AbstractGroupActionType\n)\n\nParameters\n\nop1::AbstractGroupOperation: The group operation  on mathcal H\nop2::AbstractGroupOperation: The group operation  on mathcal N\naction::AbstractGroupActionType The group action σ of mathcal H on mathcal N\n\n\n\n\n\n","category":"type"},{"location":"groups/semidirect_product_group/#LieGroups.RightSemidirectProductGroupOperation","page":"Semidirect product group","title":"LieGroups.RightSemidirectProductGroupOperation","text":"RightSemidirectProductGroupOperation{O1,O2,A} <: SemiDirectProductGroupOperation{O1,O2,A}\n\nA struct to model a right semidirect Lie group product.\n\nLet (mathcal N ) and (mathcal H ) be two Lie groups with group operations  and , respectively, as well as a group action σ mathcal Hmathcal N  mathcal N, cf AbstractGroupActionType.\n\nWe use here as well use the notation σ_h mathcal N  mathcal N as a family of maps on mathcal N\n\nThen we define a group operation  on the product manifold mathcal Nmathcal H by\n\n    (n_1h_1)  (n_2h_2) = (n_1  σ_h_1(n_2) h_1  h_2)\n\nSee [HN12, Definition 9.2.22], first definition for more details.\n\nConstructor\n\nRightSemidirectProductGroupOperation(\n    op1::AbstractGroupOperation,\n    op2::AbstractGroupOperation,\n    action::AbstractGroupActionType\n)\n\nParameters\n\nop1::AbstractGroupOperation: The group operation  on mathcal N\nop2::AbstractGroupOperation: The group operation  on mathcal H\naction::AbstractGroupActionType: The group action σ of mathcal H on mathcal N\n\n\n\n\n\n","category":"type"},{"location":"groups/semidirect_product_group/#LieGroups.SemiDirectProductGroupOperation","page":"Semidirect product group","title":"LieGroups.SemiDirectProductGroupOperation","text":"SemiDirectProductGroupOperation{\n    O1<:AbstractGroupOperation,\n    O2<:AbstractGroupOperation,\n    A<:AbstractGroupActionType\n} <: AbstractProductGroupOperation\n\nAn abstract type for all semdirect product group operations.\n\n\n\n\n\n","category":"type"},{"location":"groups/semidirect_product_group/#Base.inv-Union{Tuple{M}, Tuple{Op}, Tuple{𝔽}, Tuple{LieGroup{𝔽, Op, M}, Any}} where {𝔽, Op<:LieGroups.SemiDirectProductGroupOperation, M<:ManifoldsBase.ProductManifold}","page":"Semidirect product group","title":"Base.inv","text":"inv(SDPG::LieGroup{𝔽,Op,M}, g) where {𝔽,Op<:SemiDirectProductGroupOperation,M<:ProductManifold}\n\nCompute the inverse element of an element g = (g_1 g_2) given by\n\ng^-1 = (g_1^-1 σ_g_1^-1g_2)\n\nfor the left variant and\n\ng^-1 = (σ_g_2^-1 g_1 g_2^-1)\n\nfor the right variant, respectively. See also [HN12, Proof of Lemma 2.2.3].\n\n\n\n\n\n","category":"method"},{"location":"groups/semidirect_product_group/#LieGroups.:⋉-Tuple{LieGroup, LieGroup}","page":"Semidirect product group","title":"LieGroups.:⋉","text":"L1 ⋉ L2\n⋉(L1, L2)\n\nFor two LieGroups L1, L2, generate the LeftSemidirectProductLieGroup(L1, L2), where the corresponding default_left_action(L1, L2) is used.\n\n\n\n\n\n","category":"method"},{"location":"groups/semidirect_product_group/#LieGroups.:⋊-Tuple{LieGroup, LieGroup}","page":"Semidirect product group","title":"LieGroups.:⋊","text":"L1 ⋊ L2\n⋊(L1, L2)\n\nFor two LieGroups L1, L2, generate the RightSemidirectProductLieGroup(L1, L2), where the corresponding default_right_action(L1, L2) is used.\n\n\n\n\n\n","category":"method"},{"location":"groups/semidirect_product_group/#LieGroups.LeftSemidirectProductLieGroup","page":"Semidirect product group","title":"LieGroups.LeftSemidirectProductLieGroup","text":"LeftSemidirectProductLieGroup(\n    N::LieGroup, H::LieGroup, action::AbstractGroupActionType=default_left_action(N, H)\n)\n\nGenerate the semidirect product Lie Group mathcal G = N  H for an AbstractLeftGroupActionType using the LeftSemidirectProductGroupOperation for the group operation definition as well as [HN12, Definition 9.2.22], second definition, for more details.\n\nThe short form N⋉H can be used if the corresponding default_left_action(N,H) is the one you want to use.\n\n\n\n\n\n","category":"function"},{"location":"groups/semidirect_product_group/#LieGroups.RightSemidirectProductLieGroup","page":"Semidirect product group","title":"LieGroups.RightSemidirectProductLieGroup","text":"RightSemidirectProductLieGroup(\n    N::LieGroup, H::LieGroup, action::AbstractGroupActionType=default_right_action(N,H)\n)\n\nGenerate the semidirect product Lie Group mathcal G = N  H for an AbstractLeftGroupActionType using the RightSemidirectProductGroupOperation for the group operation definition as well as [HN12, Definition 9.2.22], first definition, for more details.\n\nThe short form N⋊H can be used if the corresponding default_right_action(N,H) is the one you want to use.\n\n\n\n\n\n","category":"function"},{"location":"groups/semidirect_product_group/#Manifolds.compose-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, LeftSemidirectProductGroupOperation, <:ManifoldsBase.ProductManifold}, Any, Any}} where 𝔽","page":"Semidirect product group","title":"Manifolds.compose","text":"compose(L::LieGroup{𝔽,LeftSemidirectProductGroupOperation}, g, h)\n\nCompute the group operation  on the semidirect product Lie group L = G  H, that is for g = (g_1h_1), h = (g_2h_2) with g_1g_2  G, h_1h_2  H this computes\n\n    (g_1h_1)  (g_2h_2) = (g_1  g_2 h_1  σ_g_1(h_2))\n\nwhere  denotes the group operation on L,  and  those on G and H, respectively, and σ is the group action specified by the AbstractGroupActionType within the LeftSemidirectProductLieGroup  L.\n\n\n\n\n\n","category":"method"},{"location":"groups/semidirect_product_group/#Manifolds.compose-Union{Tuple{𝔽}, Tuple{LieGroup{𝔽, RightSemidirectProductGroupOperation, <:ManifoldsBase.ProductManifold}, Any, Any}} where 𝔽","page":"Semidirect product group","title":"Manifolds.compose","text":"compose(L::LieGroup{𝔽,RightSemidirectProductGroupOperation}, g, h)\n\nCompute the group operation  on the semidirect product Lie group L = G  H, that is for g = (g_1h_1), h = (g_2h_2) with g_1g_2  G, h_1h_2  H this computes\n\n    (g_1h_1)  (g_2h_2) = (g_1  σ_h_1(g_2) h_1  h_2)\n\nwhere  denotes the group operation on L,  and  those on G and H, respectively, and σ is the group action specified by the AbstractGroupActionType within the RightSemidirectProductLieGroup L.\n\n\n\n\n\n","category":"method"},{"location":"groups/general_linear/#The-general-linear-group","page":"General Linear","title":"The general linear group","text":"","category":"section"},{"location":"groups/general_linear/","page":"General Linear","title":"General Linear","text":"Modules = [LieGroups]\nPages = [\"groups/general_linear_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/general_linear/#LieGroups.GeneralLinearGroup","page":"General Linear","title":"LieGroups.GeneralLinearGroup","text":"GeneralLinearGroup{𝔽,T}\n\nThe general linear group mathrmGL(n) is the set of all invertible matrices\n\nmathrmGL(n) = bigl g  𝔽^nn big mathrmdet(p)  0bigr \nqquad 𝔽   ℝ ℂ \n\nequipped with the MatrixMultiplicationGroupOperation as the group operation.\n\nThe set of invertible matrices is a Riemannian manifold, since it inherits its structure from the embedding as an open subset of the space of matrices ℝ^nn.\n\nConstructor\n\nGeneralLinearGroup(n::Int; field=ℝ, kwargs...)\n\nGenerate the general linear group  group on 𝔽^nn. All keyword arguments in kwargs... are passed on to InvertibleMatrices.\n\n\n\n\n\n","category":"type"},{"location":"groups/general_linear/#Base.exp-Tuple{GeneralLinearGroup, Any}","page":"General Linear","title":"Base.exp","text":"exp(::GeneralLinearGroup, X)\nexp!(::GeneralLinearGroup, g, X)\n\nCompute the Lie group exponential on the GeneralLinearGroup, which is given by the matrix exponential\n\nexp X = sum_k=0^ frac1kX^k\n\nsee also [HN12, Example 9.2.3 (b)]\n\n\n\n\n\n","category":"method"},{"location":"groups/general_linear/#ManifoldsBase.exp!-Tuple{GeneralLinearGroup, Any, Any}","page":"General Linear","title":"ManifoldsBase.exp!","text":"exp(::GeneralLinearGroup, X)\nexp!(::GeneralLinearGroup, g, X)\n\nCompute the Lie group exponential on the GeneralLinearGroup, which is given by the matrix exponential\n\nexp X = sum_k=0^ frac1kX^k\n\nsee also [HN12, Example 9.2.3 (b)]\n\n\n\n\n\n","category":"method"},{"location":"groups/#An-overview-of-Lie-groups","page":"List of Lie groups","title":"An overview of Lie groups","text":"","category":"section"},{"location":"groups/#Alphabetical-list-of-Lie-groups","page":"List of Lie groups","title":"Alphabetical list of Lie groups","text":"","category":"section"},{"location":"groups/","page":"List of Lie groups","title":"List of Lie groups","text":"Group Manifold  Comment\nGeneralLinearGroup InvertibleMatrices * \nHeisenbergGroup HeisenbergMatrices * \nOrthogonalGroup OrthogonalMatrices * This can be interpreted as all rotations and reflections.\nSpecialEuclideanGroup Rotations⋉Euclidean ∘ Analogously you can also use a ⋊ if you prefer tuples (t,R) having the rotation matrix in the second component\nSpecialOrthogonalGroup Rotations * \nSpecialUnitaryGroup GeneralUnitaryMatrices * \nTranslationGroup Euclidean + \nUnitaryGroup UnitaryMatrices * ","category":"page"},{"location":"groups/power_group/#The-power-Lie-group","page":"Power group","title":"The power Lie group","text":"","category":"section"},{"location":"groups/power_group/","page":"Power group","title":"Power group","text":"Modules = [LieGroups]\nPages = [\"groups/power_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/power_group/#LieGroups.PowerGroupOperation","page":"Power group","title":"LieGroups.PowerGroupOperation","text":"PowerGroupOperation{O<:AbstractGroupOperation} <: AbstractGroupOperation\n\nA struct do model a that a certain group operation is applied element-wise on a PowerManifold.\n\nConstructor\n\nPowerGroupOperation(o::AbstractGroupOperation)\n\n\n\n\n\n","category":"type"},{"location":"groups/power_group/#LieGroups.PowerLieGroup-Tuple{ManifoldsBase.AbstractManifold, Vararg{Any}}","page":"Power group","title":"LieGroups.PowerLieGroup","text":"PowerLieGroup(G::LieGroup, args...; kwargs...)\n(G::LieGroup)^(n::Integer) = PowerLieGroup(G, n)\n\nGenerate the LieGroup of the n-th power of a Lie group G or manifold M. If passed a Lie group G, the group operation on the PowerLieGroup is the same as on G, but applied elementwise. Internally, the corresponding PowerGroupOperation is created. If you pass a manifold M, you have to provide the corresponding PowerGroupOperation yourself.\n\nBot the arguments args... as well as the keyword arguments kwargs... are passed on to the constructor of the PowerManifold. This especially includes the size of the manifold and allows to specify a NestedPowerRepresentation.\n\n\n\n\n\n","category":"method"},{"location":"groups/power_group/","page":"Power group","title":"Power group","text":"On power Lie groups, all functions work element-wise, so for their formulae, check the corresponding single Lie group for details.","category":"page"},{"location":"groups/heisenberg_group/#The-Heisenberg-group","page":"Heisenberg","title":"The Heisenberg group","text":"","category":"section"},{"location":"groups/heisenberg_group/","page":"Heisenberg","title":"Heisenberg","text":"Modules = [LieGroups]\nPages = [\"groups/heisenberg_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/heisenberg_group/#LieGroups.HeisenbergGroup","page":"Heisenberg","title":"LieGroups.HeisenbergGroup","text":"HeisenbergGroup{T}\n\nThe HeisenbergGroup(n) is the group of (n+2)(n+2) matrices, see also [BP08] or Heisenberg group where T specifies the eltype of the matrix entries.\n\nbeginpmatrix 1  mathbfa^mathrmT  c mathbf0_n  I_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix\n\nwhere I_n is the nn unit matrix, mathbfa mathbfb  ℝ^n are vectors of length n, mathbf0_n is the zero vector of length n, and c  ℝ is a real number. The group operation is matrix multiplication.\n\nThe Lie algebra consists of the elements\n\nbeginpmatrix 0  mathbfa^mathrmT  c mathbf0_n  Z_n  mathbfb 0  mathbf0_n^mathrmT  0endpmatrix\n\nwhere additionally Z_n denotes the nn zero matrix.\n\n\n\n\n\n","category":"type"},{"location":"groups/heisenberg_group/#Base.exp-Tuple{HeisenbergGroup, Any, Any}","page":"Heisenberg","title":"Base.exp","text":"exp(G::HeisenbergGroup, g, X)\n\nExponential map on the HeisenbergGroup G with the left-invariant metric.\n\nWe denote by g a point on the Heisenberg group and by X a vector from the Lie algebra. These are of the form\n\ng = beginpmatrix 1  mathbfa^mathrmT  c mathbf0_n  I_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix\nqquad\nX = beginpmatrix 0  mathbfd^mathrmT  f mathbf0_n  Z_n  mathbfe 0  mathbf0_n^mathrmT  0endpmatrix\n\nwhere I_n is the nn unit matrix, Z_n is the nn zero matrix, mathbfa mathbfb mathbfd mathbfe  ℝ^n are vectors of length n, mathbf0_n is the zero vector of length n, and cf  ℝ are real numbers.\n\nThen the formula reads\n\nexp_g(X) =\nbeginpmatrix 1  (mathbfa+mathbfd)^mathrmT  c+f+frac12mathbfd^mathrmTmathbfe + mathbfa^mathrmTmathbfe mathbf0_n  I_n  mathbfb+mathbfe 0  mathbf0_n^mathrmT  1endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#Base.exp-Tuple{HeisenbergGroup, Any}","page":"Heisenberg","title":"Base.exp","text":"exp(G::HeisenbergGroup, X)\nexp!(G::HeisenbergGroup, g, X)\n\nCompute the Lie group exponential for the HeisenbergGroup G of the vector X.\n\nFor X = beginpmatrix 0  mathbfa^mathrmT  c mathbf0_n  Z_n  mathbfb 0  mathbf0_n^mathrmT  0endpmatrix from the Lie algebra of the Heisenberg group, where mathbfa mathbfb  ℝ^n vectors of length n, mathbf0_n is the zero vector of length n, c  ℝ, and Z_n denotes the nn zero matrix.\n\nThen the\n\nexp_mathcal G(X) =\nbeginpmatrix 1  mathbfa^mathrmT  c + frac12mathbfa^mathrmTmathbfb mathbf0_n  I_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix\n\nwhere I_n is the nn unit matrix.\n\nThis can be computed in-place of the Lie group element g.\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#Base.log-Tuple{HeisenbergGroup, Any, Any}","page":"Heisenberg","title":"Base.log","text":"log(G::HeisenbergGroup, g, h)\n\nCompute the logarithmic map on the HeisenbergGroup group.\n\nWe denote two points g h from the Heisenberg by\n\ng = beginpmatrix 1  mathbfa^mathrmT  c mathbf0_n  I_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix\nqquad\nh = beginpmatrix 1  mathbfd^mathrmT  f mathbf0_n  I_n  mathbfe 0  mathbf0_n^mathrmT  1endpmatrix\n\nwhere I_n is the nn unit matrix, mathbfa mathbfb mathbfd mathbfe  ℝ^n are vectors of length n, mathbf0_n is the zero vector of length n, and cf  ℝ are real numbers.\n\nThen formula reads\n\nlog_g(h) = beginpmatrix 0  (mathbfd-mathbfq)^mathrmT  f - c + mathbfa^mathrmTmathbfb - mathbfd^mathrmTmathbfe - frac12(mathbfd-mathbfa)^mathrmT(mathbfe-mathbfb) mathbf0_n  Z_n  mathbfe - mathbfb 0  mathbf0_n^mathrmT  0endpmatrix\n\nwhere additionally Z_n denotes the nn zero matrix.\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#Base.log-Tuple{HeisenbergGroup, Any}","page":"Heisenberg","title":"Base.log","text":"log(G::HeisenbergGroup, g)\nlog!(G::HeisenbergGroup, X, g)\n\nCompute the Lie group logarithm for the HeisenbergGroup G.\n\nFor g = beginpmatrix 1  mathbfa^mathrmT  c mathbf0_n  I_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix from the Lie algebra of the Heisenberg group, where mathbfa mathbfb  ℝ^n vectors of length n, mathbf0_n is the zero vector of length n, c  ℝ, and I_n is the nn unit matrix.\n\nThen the\n\nlog_mathcal G(g) =\nbeginpmatrix 1  mathbfa^mathrmT  c - frac12mathbfa^mathrmTmathbfb mathbf0_n  Z_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix\n\nwhere Z_n denotes the nn zero matrix.\n\nThis can be computed in-place of the Lie algebra vector X.\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#ManifoldsBase.injectivity_radius-Tuple{HeisenbergGroup}","page":"Heisenberg","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(G::HeisenbergGroup)\n\nReturn the injectivity radius on the HeisenbergGroup G, which is .\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#Literature","page":"Heisenberg","title":"Literature","text":"","category":"section"},{"location":"groups/heisenberg_group/","page":"Heisenberg","title":"Heisenberg","text":"E. Biny and S. Pods. The Geometry of Heisenberg Groups: With Applications in Signal Theory, Optics, Quantization, and Field Quantization (American Mathematical Society, 2008).\n\n\n\n","category":"page"},{"location":"groups/product_group/#The-product-Lie-group","page":"Product group","title":"The product Lie group","text":"","category":"section"},{"location":"groups/product_group/","page":"Product group","title":"Product group","text":"Modules = [LieGroups]\nPages = [\"groups/product_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/product_group/#LieGroups.AbstractProductGroupOperation","page":"Product group","title":"LieGroups.AbstractProductGroupOperation","text":"AbstractProductGroupOperation <: AbstractGroupOperation\n\nAn abstract type to model group operations on a product manifold\n\n\n\n\n\n","category":"type"},{"location":"groups/product_group/#LieGroups.ProductGroupOperation","page":"Product group","title":"LieGroups.ProductGroupOperation","text":"ProductGroupOperation{O<:NTuple{N,AbstractGroupOperation} where N} <: AbstractProductGroupOperation\n\nA struct do model a tuple of group operations, one for each factor of a product group, that together forms a new group operation.\n\nAccess to the single operations can be done by pgo[i].\n\nConstructor\n\nProductGroupOperation(o::AbstractGroupOperation...)\n×(o::AbstractGroupOperation...) = ProductGroupOperation(o...)\n\n\n\n\n\n","category":"type"},{"location":"groups/product_group/#LieGroups.ProductLieGroup-Tuple{LieGroup, LieGroup}","page":"Product group","title":"LieGroups.ProductLieGroup","text":"ProductLieGroup(G, H, ...)\n\nReturn the LieGroup of the product of Lie groups G and H.\n\nAlternatively, the short hand G × H can be used.\n\n\n\n\n\n","category":"method"},{"location":"groups/product_group/#LinearAlgebra.cross-Tuple{Vararg{AbstractGroupOperation}}","page":"Product group","title":"LinearAlgebra.cross","text":"cross(O1::AbstractGroupOperation, O2::AbstractGroupOperation)\nO1 × O2\nO1 × O2 × O3 × ...\n\nReturn the ProductGroupOperation For two AbstractGroupOperation` O1 and O2, where for the case that one of them is a ProductGroupOperation itself, the other is either prepended (if O1 is a product) or appended (if O2 is). If both are product operations, they are combined into one, keeping the order of operations.\n\nFor the case that more than two are concatenated with × this is iterated.\n\n\n\n\n\n","category":"method"},{"location":"groups/product_group/#LinearAlgebra.cross-Tuple{Vararg{LieGroup}}","page":"Product group","title":"LinearAlgebra.cross","text":"cross(G::LieGroup, H::LieGroup)\nG × H\nG1 × G2 × G3 × ...\n\nReturn the ProductLieGroup For two LieGroups G and H, where for the case that one of them is a ProductLieGroup itself, the other is either prepended (if H is a product) or appended (if G is). If both are product Lie groups, they are combined into one, keeping the order of operations.\n\nFor the case that more than two are concatenated with × this is iterated.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#The-special-orthogonal-group","page":"Special orthogonal group","title":"The special orthogonal group","text":"","category":"section"},{"location":"groups/special_orthogonal_group/","page":"Special orthogonal group","title":"Special orthogonal group","text":"SpecialOrthogonalGroup","category":"page"},{"location":"groups/special_orthogonal_group/#LieGroups.SpecialOrthogonalGroup","page":"Special orthogonal group","title":"LieGroups.SpecialOrthogonalGroup","text":"SpecialOrthogonalGroup{T}\n\nThe special orthogonal group mathrmSO(n) is the Lie group consisting of the MatrixMultiplicationGroupOperation on the manifold of rotations Rotations.\n\nConstructor\n\nSpecialOrthogonalGroup(n::Int; kwargs...)\n\nGenerate  special orthogonal group mathrmSO(n). All keyword arguments in kwargs... are passed on to Rotations as well.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_orthogonal_group/","page":"Special orthogonal group","title":"Special orthogonal group","text":"For this Lie group, several implementations are already covered by the defaults in the generic (matrix) multiplication operation.","category":"page"},{"location":"groups/special_orthogonal_group/#Functions","page":"Special orthogonal group","title":"Functions","text":"","category":"section"},{"location":"groups/special_orthogonal_group/","page":"Special orthogonal group","title":"Special orthogonal group","text":"Modules = [LieGroups]\nPages = [\"groups/special_orthogonal_group.jl\"]\nOrder = [:function]","category":"page"},{"location":"groups/special_orthogonal_group/#Base.exp-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any}","page":"Special orthogonal group","title":"Base.exp","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, these simplify for the case of 22 matrices to X=beginpmatrix 0  -α α  0endpmatrix, for some αℝ.\n\nTheir exponential is\n\nexp_mathcal G(X) =  beginpmatrix cos(α)  -sin(α) sin(α)  cos(α)endpmatrix\n\nThis result can be computed in-place of g.\n\nNote that since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#Base.exp-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any}","page":"Special orthogonal group","title":"Base.exp","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, the 33 skew symmetric matrices are of the form\n\n    X = beginpmatrix 0  -c  b c  0  -a -b  a  0endpmatrix\n\nfor some a b c  ℝ. To compute the exponential, the Rodrigues' rotation formula can be used. With α = sqrta^2+b^2+c^2 = frac1sqrt2lVert X rVert_ we obtain for α  0\n\nexp_mathcal G(X) = I_3 + fracsinαX + frac(1 - cos)α^2X^2\n\nand \\exp{\\mathcal G}(X) = I3`` otherwise.\n\nThis result can be computed in-place of g.\n\nNote that since mathrmSO(3) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#Base.exp-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any}","page":"Special orthogonal group","title":"Base.exp","text":"exp(G, e, X)\nexp!(G, e, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSimilar to the 33 case, an efficient computation is provided, adapted from [GX02], [AR13] with a few numerical stabilisations.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#Base.log-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any}","page":"Special orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nFor the two-dimensional case, any rotation matrix g can be represented as beginpmatrix cos(α)  -sin(α) sin(α)  cos(α)endpmatrix. For the SpecialOrthogonalGroup, g might also include reflections.\n\nThe logarithm is then\n\nlog_mathcal G(g) =  beginpmatrix 0  α -α  0endpmatrix\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#Base.log-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any}","page":"Special orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nHere, exp_mathcal G(X) = g is inverted using the Rodrigues' rotation formula\n\nexp_mathcal G(X) = I_3 + fracsinαX + frac(1 - cos)α^2X^2\n\nFor α   0 π  we obtain X from the observation that\n\nmathrmtr(g) = 1 + 2cos(α)\nqquadtext and qquad\nfrac12(g-g^mathrmT) = sin(α)X\n\nFor α = 0 we have g = I_3 and X = 0.\n\nFor α = π we have to solve X^2 = frac12(g-I_3), where X is skew-symmetric and hence we have to solve for three unknowns.\n\nlog_mathcal G(g) = X\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(3) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#Base.log-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any}","page":"Special orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nThe implementation is based on a generalized variant of the Rodrigues' like formula. For details, see [GX02, Section 3].\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.exp!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, these simplify for the case of 22 matrices to X=beginpmatrix 0  -α α  0endpmatrix, for some αℝ.\n\nTheir exponential is\n\nexp_mathcal G(X) =  beginpmatrix cos(α)  -sin(α) sin(α)  cos(α)endpmatrix\n\nThis result can be computed in-place of g.\n\nNote that since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.exp!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, the 33 skew symmetric matrices are of the form\n\n    X = beginpmatrix 0  -c  b c  0  -a -b  a  0endpmatrix\n\nfor some a b c  ℝ. To compute the exponential, the Rodrigues' rotation formula can be used. With α = sqrta^2+b^2+c^2 = frac1sqrt2lVert X rVert_ we obtain for α  0\n\nexp_mathcal G(X) = I_3 + fracsinαX + frac(1 - cos)α^2X^2\n\nand \\exp{\\mathcal G}(X) = I3`` otherwise.\n\nThis result can be computed in-place of g.\n\nNote that since mathrmSO(3) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.exp!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, e, X)\nexp!(G, e, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSimilar to the 33 case, an efficient computation is provided, adapted from [GX02], [AR13] with a few numerical stabilisations.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.get_coordinates!-Tuple{SpecialOrthogonalGroup, Any, Identity{MatrixMultiplicationGroupOperation}, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Special orthogonal group","title":"ManifoldsBase.get_coordinates!","text":"get_coordinates(𝔤::OrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates(G::SpecialOrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::OrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::SpecialOrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the vector of coordinates c  ℝ^d from the Lie algebra tangent vector X  𝔬(n) of the OrthogonalGroup O(n) in the DefaultLieAlgebraOrthogonalBasis, where d is the dimension of the Lie algebra. This is also the version used in vee.\n\nFor O(2) there is only one coefficient α in the basis beginpmatrix 0  -α α  0endpmatrix, which is returned as c = (α)^mathrmT.\n\nA usual basis representation of ``𝔬(3) is given by\n\n    X = beginpmatrix 0  -γ  β γ  0  -α -β  α  0endpmatrix\n\nhence the coordinate vector is c = (α β γ)^mathrmT  ℝ^3.\n\nFor n ≥ 4the lower triangular part is added toc` row-wise.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.get_coordinates-Tuple{SpecialOrthogonalGroup, Identity{MatrixMultiplicationGroupOperation}, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Special orthogonal group","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(𝔤::OrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates(G::SpecialOrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::OrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::SpecialOrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the vector of coordinates c  ℝ^d from the Lie algebra tangent vector X  𝔬(n) of the OrthogonalGroup O(n) in the DefaultLieAlgebraOrthogonalBasis, where d is the dimension of the Lie algebra. This is also the version used in vee.\n\nFor O(2) there is only one coefficient α in the basis beginpmatrix 0  -α α  0endpmatrix, which is returned as c = (α)^mathrmT.\n\nA usual basis representation of ``𝔬(3) is given by\n\n    X = beginpmatrix 0  -γ  β γ  0  -α -β  α  0endpmatrix\n\nhence the coordinate vector is c = (α β γ)^mathrmT  ℝ^3.\n\nFor n ≥ 4the lower triangular part is added toc` row-wise.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.get_vector!-Tuple{SpecialOrthogonalGroup, Any, Identity{MatrixMultiplicationGroupOperation}, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Special orthogonal group","title":"ManifoldsBase.get_vector!","text":"get_vector(G::OrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector(G::SpecialOrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::OrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::SpecialOrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the tangent vector X  𝔬(n) based on a vector of coordinates c  ℝ^d, where d is the dimension of the Lie algebra of the OrthogonalGroup O(n) and the coordinates are with respect to the DefaultLieAlgebraOrthogonalBasis. This is also the version used in hat.\n\nFor O(2) there is only one coefficient ``c = (α)^mathrmT and hence X = beginpmatrix 0  -α α  0endpmatrix is returned.\n\nFor n=3 a usual representtion turns c = (α β γ)^mathrmT  ℝ^3 into\n\n    X = beginpmatrix 0  -γ  β γ  0  -α -β  α  0endpmatrix\n\nhence the coordinate vector is .\n\nFor n ≥ 4` all further coefficients are used to fill up the following rows of the lower triangular part – which determines the upper triangular part due to skew-symmetry\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.get_vector-Tuple{SpecialOrthogonalGroup, Identity{MatrixMultiplicationGroupOperation}, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Special orthogonal group","title":"ManifoldsBase.get_vector","text":"get_vector(G::OrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector(G::SpecialOrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::OrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::SpecialOrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the tangent vector X  𝔬(n) based on a vector of coordinates c  ℝ^d, where d is the dimension of the Lie algebra of the OrthogonalGroup O(n) and the coordinates are with respect to the DefaultLieAlgebraOrthogonalBasis. This is also the version used in hat.\n\nFor O(2) there is only one coefficient ``c = (α)^mathrmT and hence X = beginpmatrix 0  -α α  0endpmatrix is returned.\n\nFor n=3 a usual representtion turns c = (α β γ)^mathrmT  ℝ^3 into\n\n    X = beginpmatrix 0  -γ  β γ  0  -α -β  α  0endpmatrix\n\nhence the coordinate vector is .\n\nFor n ≥ 4` all further coefficients are used to fill up the following rows of the lower triangular part – which determines the upper triangular part due to skew-symmetry\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.log!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nFor the two-dimensional case, any rotation matrix g can be represented as beginpmatrix cos(α)  -sin(α) sin(α)  cos(α)endpmatrix. For the SpecialOrthogonalGroup, g might also include reflections.\n\nThe logarithm is then\n\nlog_mathcal G(g) =  beginpmatrix 0  α -α  0endpmatrix\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.log!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nHere, exp_mathcal G(X) = g is inverted using the Rodrigues' rotation formula\n\nexp_mathcal G(X) = I_3 + fracsinαX + frac(1 - cos)α^2X^2\n\nFor α   0 π  we obtain X from the observation that\n\nmathrmtr(g) = 1 + 2cos(α)\nqquadtext and qquad\nfrac12(g-g^mathrmT) = sin(α)X\n\nFor α = 0 we have g = I_3 and X = 0.\n\nFor α = π we have to solve X^2 = frac12(g-I_3), where X is skew-symmetric and hence we have to solve for three unknowns.\n\nlog_mathcal G(g) = X\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(3) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.log!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nThe implementation is based on a generalized variant of the Rodrigues' like formula. For details, see [GX02, Section 3].\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#The-orthogonal-group","page":"Orthogonal group","title":"The orthogonal group","text":"","category":"section"},{"location":"groups/orthogonal_group/","page":"Orthogonal group","title":"Orthogonal group","text":"OrthogonalGroup","category":"page"},{"location":"groups/orthogonal_group/#LieGroups.OrthogonalGroup","page":"Orthogonal group","title":"LieGroups.OrthogonalGroup","text":"OrthogonalGroup{T}\n\nThe orthogonal group mathrmO(n) is the Lie group consisting of the MatrixMultiplicationGroupOperation on the manifold of rotations OrthogonalMatrices.\n\nConstructor\n\nOrthogonalGroup(n::Int; kwargs...)\n\nGenerate  orthogonal group mathrmO(n). All keyword arguments in kwargs... are passed on to OrthogonalMatrices as well.\n\n\n\n\n\n","category":"type"},{"location":"groups/orthogonal_group/","page":"Orthogonal group","title":"Orthogonal group","text":"For this Lie group, several implementations are already covered by the defaults in the generic (matrix) multiplication operation.","category":"page"},{"location":"groups/orthogonal_group/#Functions","page":"Orthogonal group","title":"Functions","text":"","category":"section"},{"location":"groups/orthogonal_group/","page":"Orthogonal group","title":"Orthogonal group","text":"Modules = [LieGroups]\nPages = [\"groups/orthogonal_group.jl\"]\nOrder = [:function]","category":"page"},{"location":"groups/orthogonal_group/#Base.exp-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any}","page":"Orthogonal group","title":"Base.exp","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, these simplify for the case of 22 matrices to X=beginpmatrix 0  -α α  0endpmatrix, for some αℝ.\n\nTheir exponential is\n\nexp_mathcal G(X) =  beginpmatrix cos(α)  -sin(α) sin(α)  cos(α)endpmatrix\n\nThis result can be computed in-place of g.\n\nNote that since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Base.exp-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any}","page":"Orthogonal group","title":"Base.exp","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, the 33 skew symmetric matrices are of the form\n\n    X = beginpmatrix 0  -c  b c  0  -a -b  a  0endpmatrix\n\nfor some a b c  ℝ. To compute the exponential, the Rodrigues' rotation formula can be used. With α = sqrta^2+b^2+c^2 = frac1sqrt2lVert X rVert_ we obtain for α  0\n\nexp_mathcal G(X) = I_3 + fracsinαX + frac(1 - cos)α^2X^2\n\nand \\exp{\\mathcal G}(X) = I3`` otherwise.\n\nThis result can be computed in-place of g.\n\nNote that since mathrmSO(3) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Base.exp-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any}","page":"Orthogonal group","title":"Base.exp","text":"exp(G, e, X)\nexp!(G, e, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSimilar to the 33 case, an efficient computation is provided, adapted from [GX02], [AR13] with a few numerical stabilisations.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Base.log-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any}","page":"Orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nFor the two-dimensional case, any rotation matrix g can be represented as beginpmatrix cos(α)  -sin(α) sin(α)  cos(α)endpmatrix. For the SpecialOrthogonalGroup, g might also include reflections.\n\nThe logarithm is then\n\nlog_mathcal G(g) =  beginpmatrix 0  α -α  0endpmatrix\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Base.log-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any}","page":"Orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nHere, exp_mathcal G(X) = g is inverted using the Rodrigues' rotation formula\n\nexp_mathcal G(X) = I_3 + fracsinαX + frac(1 - cos)α^2X^2\n\nFor α   0 π  we obtain X from the observation that\n\nmathrmtr(g) = 1 + 2cos(α)\nqquadtext and qquad\nfrac12(g-g^mathrmT) = sin(α)X\n\nFor α = 0 we have g = I_3 and X = 0.\n\nFor α = π we have to solve X^2 = frac12(g-I_3), where X is skew-symmetric and hence we have to solve for three unknowns.\n\nlog_mathcal G(g) = X\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(3) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Base.log-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any}","page":"Orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nThe implementation is based on a generalized variant of the Rodrigues' like formula. For details, see [GX02, Section 3].\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.exp!-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, these simplify for the case of 22 matrices to X=beginpmatrix 0  -α α  0endpmatrix, for some αℝ.\n\nTheir exponential is\n\nexp_mathcal G(X) =  beginpmatrix cos(α)  -sin(α) sin(α)  cos(α)endpmatrix\n\nThis result can be computed in-place of g.\n\nNote that since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.exp!-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, the 33 skew symmetric matrices are of the form\n\n    X = beginpmatrix 0  -c  b c  0  -a -b  a  0endpmatrix\n\nfor some a b c  ℝ. To compute the exponential, the Rodrigues' rotation formula can be used. With α = sqrta^2+b^2+c^2 = frac1sqrt2lVert X rVert_ we obtain for α  0\n\nexp_mathcal G(X) = I_3 + fracsinαX + frac(1 - cos)α^2X^2\n\nand \\exp{\\mathcal G}(X) = I3`` otherwise.\n\nThis result can be computed in-place of g.\n\nNote that since mathrmSO(3) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.exp!-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, e, X)\nexp!(G, e, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSimilar to the 33 case, an efficient computation is provided, adapted from [GX02], [AR13] with a few numerical stabilisations.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.get_coordinates!-Tuple{ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, OrthogonalGroup{T}, Identity{MatrixMultiplicationGroupOperation}} where T, Any, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Orthogonal group","title":"ManifoldsBase.get_coordinates!","text":"get_coordinates(𝔤::OrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates(G::SpecialOrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::OrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::SpecialOrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the vector of coordinates c  ℝ^d from the Lie algebra tangent vector X  𝔬(n) of the OrthogonalGroup O(n) in the DefaultLieAlgebraOrthogonalBasis, where d is the dimension of the Lie algebra. This is also the version used in vee.\n\nFor O(2) there is only one coefficient α in the basis beginpmatrix 0  -α α  0endpmatrix, which is returned as c = (α)^mathrmT.\n\nA usual basis representation of ``𝔬(3) is given by\n\n    X = beginpmatrix 0  -γ  β γ  0  -α -β  α  0endpmatrix\n\nhence the coordinate vector is c = (α β γ)^mathrmT  ℝ^3.\n\nFor n ≥ 4the lower triangular part is added toc` row-wise.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.get_coordinates-Tuple{ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, OrthogonalGroup{T}, Identity{MatrixMultiplicationGroupOperation}} where T, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Orthogonal group","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(𝔤::OrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates(G::SpecialOrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::OrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::SpecialOrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the vector of coordinates c  ℝ^d from the Lie algebra tangent vector X  𝔬(n) of the OrthogonalGroup O(n) in the DefaultLieAlgebraOrthogonalBasis, where d is the dimension of the Lie algebra. This is also the version used in vee.\n\nFor O(2) there is only one coefficient α in the basis beginpmatrix 0  -α α  0endpmatrix, which is returned as c = (α)^mathrmT.\n\nA usual basis representation of ``𝔬(3) is given by\n\n    X = beginpmatrix 0  -γ  β γ  0  -α -β  α  0endpmatrix\n\nhence the coordinate vector is c = (α β γ)^mathrmT  ℝ^3.\n\nFor n ≥ 4the lower triangular part is added toc` row-wise.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.get_vector!-Tuple{ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, OrthogonalGroup{T}, Identity{MatrixMultiplicationGroupOperation}} where T, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Orthogonal group","title":"ManifoldsBase.get_vector!","text":"get_vector(G::OrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector(G::SpecialOrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::OrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::SpecialOrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the tangent vector X  𝔬(n) based on a vector of coordinates c  ℝ^d, where d is the dimension of the Lie algebra of the OrthogonalGroup O(n) and the coordinates are with respect to the DefaultLieAlgebraOrthogonalBasis. This is also the version used in hat.\n\nFor O(2) there is only one coefficient ``c = (α)^mathrmT and hence X = beginpmatrix 0  -α α  0endpmatrix is returned.\n\nFor n=3 a usual representtion turns c = (α β γ)^mathrmT  ℝ^3 into\n\n    X = beginpmatrix 0  -γ  β γ  0  -α -β  α  0endpmatrix\n\nhence the coordinate vector is .\n\nFor n ≥ 4` all further coefficients are used to fill up the following rows of the lower triangular part – which determines the upper triangular part due to skew-symmetry\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.get_vector-Tuple{ManifoldsBase.Fiber{ℝ, ManifoldsBase.TangentSpaceType, OrthogonalGroup{T}, Identity{MatrixMultiplicationGroupOperation}} where T, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Orthogonal group","title":"ManifoldsBase.get_vector","text":"get_vector(G::OrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector(G::SpecialOrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::OrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::SpecialOrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the tangent vector X  𝔬(n) based on a vector of coordinates c  ℝ^d, where d is the dimension of the Lie algebra of the OrthogonalGroup O(n) and the coordinates are with respect to the DefaultLieAlgebraOrthogonalBasis. This is also the version used in hat.\n\nFor O(2) there is only one coefficient ``c = (α)^mathrmT and hence X = beginpmatrix 0  -α α  0endpmatrix is returned.\n\nFor n=3 a usual representtion turns c = (α β γ)^mathrmT  ℝ^3 into\n\n    X = beginpmatrix 0  -γ  β γ  0  -α -β  α  0endpmatrix\n\nhence the coordinate vector is .\n\nFor n ≥ 4` all further coefficients are used to fill up the following rows of the lower triangular part – which determines the upper triangular part due to skew-symmetry\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.log!-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nFor the two-dimensional case, any rotation matrix g can be represented as beginpmatrix cos(α)  -sin(α) sin(α)  cos(α)endpmatrix. For the SpecialOrthogonalGroup, g might also include reflections.\n\nThe logarithm is then\n\nlog_mathcal G(g) =  beginpmatrix 0  α -α  0endpmatrix\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.log!-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nHere, exp_mathcal G(X) = g is inverted using the Rodrigues' rotation formula\n\nexp_mathcal G(X) = I_3 + fracsinαX + frac(1 - cos)α^2X^2\n\nFor α   0 π  we obtain X from the observation that\n\nmathrmtr(g) = 1 + 2cos(α)\nqquadtext and qquad\nfrac12(g-g^mathrmT) = sin(α)X\n\nFor α = 0 we have g = I_3 and X = 0.\n\nFor α = π we have to solve X^2 = frac12(g-I_3), where X is skew-symmetric and hence we have to solve for three unknowns.\n\nlog_mathcal G(g) = X\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(3) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.log!-Tuple{OrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nThe implementation is based on a generalized variant of the Rodrigues' like formula. For details, see [GX02, Section 3].\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Utility-functions","page":"Orthogonal group","title":"Utility functions","text":"","category":"section"},{"location":"groups/orthogonal_group/","page":"Orthogonal group","title":"Orthogonal group","text":"LieGroups.angles_4d_skew_sym_matrix\nLieGroups.cos_angles_4d_rotation_matrix\nLieGroups.log_safe!\nLieGroups.usinc_from_cos","category":"page"},{"location":"groups/orthogonal_group/#LieGroups.angles_4d_skew_sym_matrix","page":"Orthogonal group","title":"LieGroups.angles_4d_skew_sym_matrix","text":"angles_4d_skew_sym_matrix(A)\n\nThe Lie algebra 𝔰𝔬(4) of OrthogonalGroup(4) in ℝ^44, consists of 44 skew-symmetric matrices. The unique imaginary components of their eigenvalues are the angles of the two plane rotations. This function computes these more efficiently than eigvals.\n\nBy convention, the returned values are sorted in decreasing order. See also cos_angles_4d_rotation_matrix.\n\n\n\n\n\n","category":"function"},{"location":"groups/orthogonal_group/#LieGroups.cos_angles_4d_rotation_matrix","page":"Orthogonal group","title":"LieGroups.cos_angles_4d_rotation_matrix","text":"cos_angles_4d_rotation_matrix(R)\n\n4D rotations can be described by two orthogonal planes that are unchanged by the action of the rotation (vectors within a plane rotate only within the plane). The cosines of the two angles αβ of rotation about these planes may be obtained from the distinct real parts of the eigenvalues of the rotation matrix. This function computes these more efficiently by solving the system\n\nbeginaligned cosα + cosβ = frac12mathrmtr(R) cosα cosβ = frac18mathrmtr(R)^2 - frac116mathrmtr((R - R^T)^2) - 1endaligned\n\nBy convention, the returned values are sorted in decreasing order. See also angles_4d_skew_sym_matrix.\n\n\n\n\n\n","category":"function"},{"location":"groups/orthogonal_group/#LieGroups.log_safe!","page":"Orthogonal group","title":"LieGroups.log_safe!","text":"log_safe!(y, x)\n\nCompute the matrix logarithm of x. If the eltype of y is real, then the imaginary part of x is ignored, and a DomainError is raised if real(x) has no real logarithm.\n\n\n\n\n\n","category":"function"},{"location":"groups/orthogonal_group/#LieGroups.usinc_from_cos","page":"Orthogonal group","title":"LieGroups.usinc_from_cos","text":"usinc_from_cos(x::Real)\n\nUnnormalized version of sinc function, i.e. mathrmusinc(θ) = fracsin(θ)θ, computed from x = cos(θ).\n\n\n\n\n\n","category":"function"},{"location":"groups/special_unitary_group/#The-special-unitary-group","page":"Special unitary group","title":"The special unitary group","text":"","category":"section"},{"location":"groups/special_unitary_group/","page":"Special unitary group","title":"Special unitary group","text":"SpecialUnitaryGroup","category":"page"},{"location":"groups/special_unitary_group/#LieGroups.SpecialUnitaryGroup","page":"Special unitary group","title":"LieGroups.SpecialUnitaryGroup","text":"SpecialUnitaryGroup{T}\n\nThe special orthogonal group mathrmSO(n) is the Lie group consisting of the MatrixMultiplicationGroupOperation on the manifold of rotations GeneralUnitaryMatrices with determinant one.\n\nConstructor\n\nSpecialUnitaryGroup(n::Int; kwargs...)\n\nGenerate special unitary group mathrmSO(n). All keyword arguments in kwargs... are passed on to Rotations as well.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_unitary_group/","page":"Special unitary group","title":"Special unitary group","text":"For this Lie group, several implementations are already covered by the defaults in the generic (matrix) multiplication operation.","category":"page"},{"location":"#LieGroups.jl","page":"Home","title":"LieGroups.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the Documentation of LieGroups.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = LieGroups","category":"page"},{"location":"","page":"Home","title":"Home","text":"LieGroups.LieGroups","category":"page"},{"location":"#LieGroups.LieGroups","page":"Home","title":"LieGroups.LieGroups","text":"LieGroups.jl: Lie groups and Lie algebras in Julia.\n\nThe package is named after the Norwegian mathematician Marius Sophus Lie (1842–1899).\n\n📚 Documentation: juliamanifolds.github.io/LieGroups.jl/\n📦 Repository: github.com/JuliaManifolds/LieGroups.jl\n💬 Discussions: github.com/JuliaManifolds/LieGroups.jl/discussions\n🎯 Issues: github.com/JuliaManifolds/LieGroups.jl/issues\n\n\n\n\n\n","category":"module"},{"location":"groups/translation_group/#The-Lie-group-of-translations-on-a-Euclidean-space","page":"Translation group","title":"The Lie group of translations on a Euclidean space","text":"","category":"section"},{"location":"groups/translation_group/","page":"Translation group","title":"Translation group","text":"TranslationGroup","category":"page"},{"location":"groups/translation_group/#LieGroups.TranslationGroup","page":"Translation group","title":"LieGroups.TranslationGroup","text":"TranslationGroup{𝔽,T}\n\nThe translation group mathcal T(n) is Lie group consisting of the AdditionGroupOperation on some Euclidean space.\n\nConstructor\n\nTranslationGroup(n₁,...,nᵢ; kwargs...)\n\nGenerate the translation group on 𝔽^n₁nᵢ = Euclidean(n₁,...,nᵢ; field=𝔽), which is isomorphic to the group itself. All keyword arguments in kwargs... are passed on to Euclidean as well\n\nWe denote the Lie algebra of mathcal T(n) by mathfrak t(n).\n\n\n\n\n\n","category":"type"},{"location":"groups/translation_group/","page":"Translation group","title":"Translation group","text":"For this Lie group, all implementations are already covered by the defaults in the generic addition operation.","category":"page"},{"location":"notation/#Notation-on-Lie-groups","page":"Notation","title":"Notation on Lie groups","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"In this package,the notation introduced in Manifolds.jl Notation is used with the following additional parts.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Symbol Description Also used Comment\n a group operation  \nc_gmathcal G  mathcal G the conjugation map (with g)  \nmathrme identity element of a group  \nexp_mathcal G(X) The Lie group exponential function  \nexp_g(X) The Lie group exponential map (w.r.t. a Cartan Schouten connection)  \ng h k elements on a (Lie) group. Sometimes called points. g_1 g_2  \nmathfrak g a Lie algebra  \nmathcalG a Lie group  \nλ_g mathcal G  mathcal G the left group operation map λ_g(h) = gh  \nlog_mathcal G(g) The Lie group logarithmic function  \nlog_g(h) The Lie group logarithmic map (w.r.t. a Cartan Schouten connection)  \nρ_g mathcal G  mathcal G the right group operation map ρ_g(h) = hg  \nσ mathcal G  mathcal M a left group action  σ_g(p) to emphasize a fixed group element\nτ mathcal M  mathcal G a right group action σ_mathrmR τ_g(p) to emphasize a fixed group element","category":"page"}]
}
