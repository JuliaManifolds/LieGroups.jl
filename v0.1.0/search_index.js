var documenterSearchIndex = {"docs":
[{"location":"tutorials/transition/#Transition-from-GroupManifolds-in-Manifolds.jl","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds in Manifolds.jl","text":"","category":"section"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"One predecessor of LieGroups.jl are the GroupManifolds in Manifolds.jl. While this package provides the same features, one reason for a new package is, that a ‚Äúrestart‚Äù offers the opportunity to put the main focus for the functions in this package really on Lie groups.","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"This tutorial provides an overview of the necessary changes to your code if you based it on the predecessor.","category":"page"},{"location":"tutorials/transition/#Table-of-function-names-and-its-successors","page":"Transition from GroupManifolds","title":"Table of function names and its successors","text":"","category":"section"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"The following table lists all functions related to GroupManifolds and their new names or replacements here in LieGroups.jl. In this code G always refers to the GroupManifold in the first column and the LieGroup in the second. Lie group elements (points) are always g,h, Lie algebra elements (vectors) always X, Y.","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"New functions and types in this package are only mentioned, if they are worth a comment and if something changed.","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"The list is alphabetical, but first lists types, then functions","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"Manifolds.jl LieGroups.jl Comment\nAdditionOperation AdditionGroupOperation \nLeftForwardAction LeftGroupOperationAction \nLeftBackwardAction InverseRightGroupOperationAction note that this is now also aa AbstractLeftGroupActionType\n LieAlgebra(G) new alias to emphasize its manifold- and vector structure as well as for a few dispatch methods.\nGroupManifold(M, op) LieGroup(M, op) \nPowerGroup(M) PowerLieGroup(G,n) The main change is, that the constructor now requires a Lie group to build the power Lie group; This also allows for G^n. The other two former constructors for nested and nested-replacing are no longer necessary. PowerLieGroup behaves exactly the same as PowerManifold.\nProductGroup(M) ProductLieGroup(G, H) The main change is, that the constructor now requires two Lie groups to build their product. This also allows for the short hand G√óH to generate this product.\nSemidirectProductGroup(G, H, a) LeftSemidirectProductLieGroup(G, H, a) While this staid the same, there is now also the default_left_action(G,H). When this agrees with a you can use the short hand G‚ãâH to generate this semidirect product. Analogously there now also exists the RightSemidirectProductLieGroup(G,H) withdefault_left_action(G,H) that allows for the short cut G‚ãäH\nRightBackwardAction RightGroupOperationAction \nRightForwardAction InverseLeftGroupOperationAction note that this is an AbstractRightGroupActionType\nadjoint_action adjoint now implemented with a default, when you provide diff_conjugate!.\napply_diff diff_apply modifiers (diff) come first, consistent with ManifoldsDiff.jl\napply_diff_group diff_group_apply modifiers (diff/group) come first, consistent with ManifoldsDiff.jl\n conjugate, diff_conjugate a new function to model c_g mathcal G  mathcal G given by c_g(h) = ghg^-1\ndifferential_exp_argument_lie_approx - Scheduled for update and renaming. Though available in ManifoldDiff.jl for GroupManifolds, that will move to differential_exp_argument_approx instead, since exp_lie changed to now just exp.\nexp(G, g, X) exp(base_manifold(G), g, X) the previous defaults whenever not agreeing with the Riemannian one can now be accessed on the internal manifold\nexp_inv(G, g, X) exp(G, g, X) the exponential map invariant to the group operation is the default on Lie groups here\nexp_lie(G, X) exp(G, X) the (matrix/Lie group) exponential\ninverse_translate(G, g, h, c) inv_left_compose(G, g, h), inv_right_compose(G, g, h) compute g^-1h and gh^-1, resp.\ninverse_translate_diff(G, g, h, X, LeftForwardAction()) - discontinued, use diff_left_compose(G, inv(G,g), h)\ninverse_translate_diff(G, g, h, X, RightBackwardAction()) - discontinued, use diff_left_compose(G, h, inv(G,g))\nlog(G, g, h) log(base_manifold(G), g, h) you can now access the previous defaults on the internal manifold whenever they do not agree with the invariant one\nlog_inv(G, g, h) log(G, g, h) the logarithmic map invariant to the group operation is the default on Lie groups here\nlog_lie(G, g) log(G, g) the (matrix/Lie group) logarithm\nswitch_direction(A) inv(A) switches from an action to its inverse action (formerly the direction forward/backward, sometimes even left/right, do not confuse with the side left/right).\nswitch_side(A) switch(A) switches from a left action to its corresponding right action.\ntranslate(G, g, h) compose(G, g, h) unified to compose\ntranslate_diff(G, g, X, c) diff_left_compose(G, g, h, X), diff_right_compose(G, g, h, X) for compose gh the functions now specify whether the derivative is taken w.r.t. to the left (g) or right (h) argument\nVeeOrthogonalBasis DefaultLieAlgebraOrthogonalBasis ","category":"page"},{"location":"tutorials/transition/#Further-notable-changes","page":"Transition from GroupManifolds","title":"Further notable changes","text":"","category":"section"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"In general the default for tangent vectors is now to represent them in the LieAlgebra, which obtains its own name now, though defined as a constant of a certain tangent space.\nIn accordance with point 1., the GeneralLinearGroup (formerly GeneralLinear) switched to using its Lie algebra to represent tangent vectors.\nFormerly, both a power manifold of Lie groups as a manifold as well as a Lie group of a power manifold as a Lie group were possible. This is unified to just defining G^n as the Lie group on the power manifold with the element-wise group operation.\nFormerly, product manifolds were stored as a ProductManifold of Lie groups and an indicator for the group operation, that the direct product should be used. This is switched to internally only store a ProductManifold as well as a (new) ProductGroupOperation that specifies one group operation for every factor.\nThe last two points achieve one unified modelling aspect of Lie groups: they are now always a manifold M together with a group operation op, but a Lie group does not store another Lie group (or product of them) internally with one common type they share, a LieGroup.","category":"page"},{"location":"references/#Literature","page":"References","title":"Literature","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"This is all literature mentioned / referenced in the LieGroups.jl documentation. You can find a small reference section at the end of every documentation page that contains the corresponding references as well.","category":"page"},{"location":"references/","page":"References","title":"References","text":"D.¬†Andrica and R.-A.¬†Rohan. Computing the Rodrigues coefficients of the exponential map of the Lie groups of matrices. Balkan¬†Journal¬†of¬†Geometry¬†and¬†Its¬†Applications 18, 1‚Äì10 (2013).\n\n\n\nT.¬†Bendokat and R.¬†Zimmermann. The real symplectic Stiefel and Grassmann manifolds: metrics, geodesics and applications, arXiv¬†Preprint,¬†2108.12447 (2021), arXiv:2108.12447.\n\n\n\nE.¬†Biny and S.¬†Pods. The Geometry of Heisenberg Groups: With Applications in Signal Theory, Optics, Quantization, and Field Quantization (American Mathematical Society, 2008).\n\n\n\nJ.¬†Gallier and D.¬†Xu. Computing exponentials of skew-symmetric matrices and logarithms of orthogonal matrices. International¬†Journal¬†of¬†Robotics¬†and¬†Automation 17, 1‚Äì11 (2002).\n\n\n\nM.¬†B.¬†Giles. Collected Matrix Derivative Results for Forward and Reverse Mode Algorithmic Differentiation. In: Advances in Automatic Differentiation, Lecture Notes in Computational Science and Engineering, edited by C.¬†H.¬†Bischof, H.¬†M.¬†B√ºcker, P.¬†Hovland, U.¬†Naumann and J.¬†Utke (Springer, Berlin, Heidelberg, 2008); pp.¬†35‚Äì44.\n\n\n\nJ.¬†Hilgert and K.-H.¬†Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\nD.¬†Latifi and M.¬†Toomanian. On the existence of bi-invariant Finsler metrics on Lie groups. Mathematical¬†Sciences 7, 37 (2013).\n\n\n\nJ.¬†Sol√†, J.¬†Deray and D.¬†Atchuthan. A micro Lie theory for state estimation in robotics (Dec 2021), arXiv:1812.01537 [cs.RO], arXiv: 1812.01537.\n\n\n\n","category":"page"},{"location":"groups/circle_group/#The-circle-group","page":"Circle Group","title":"The circle group","text":"","category":"section"},{"location":"groups/circle_group/","page":"Circle Group","title":"Circle Group","text":"Modules = [LieGroups]\nPages = [\"groups/circle_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/circle_group/#LieGroups.CircleGroup-Tuple{Union{ManifoldsBase.AbstractNumbers, Manifolds.Circle, Manifolds.Euclidean, Manifolds.Sphere}}","page":"Circle Group","title":"LieGroups.CircleGroup","text":"CircleGroup\n\nThe circle group ùïä^1 is the unit circle together with composing points on the circle by adding angles. The circle itself is a one dimensional Riemannian manifold. Hence the Lie algebra is the real line.\n\nThe elements of the circle group can be represented in three different ways.\n\nAs complex numbers\n\nElements of the circle group can be represented as complex numbers of absolute value one, that is\n\nùïä¬π = bigl z  ‚ÑÇ big z = 1bigr  = bigl a + bmathrmi  ‚ÑÇ big a^2+b^2 = 1bigr \n\nwhere mathrmi denotes the imaginary unit. It is equipped with the group operation of complex multiplication AbelianMultiplicationGroupOperation. That operation is given by\n\n(a + bmathrmi)  (c + dmathrmi) = (ac - bd) + (ad + bc)mathrmi\n\nfor complex numbers a + bmathrmi c + dmathrmi  ‚ÑÇ.\n\nAs angles in -œÄœÄ)\n\nElements of the circle group can be represented by the angle on the unit circle that they correspond to. In that case the elements are represented by real numbers x  -œÄœÄ) and the circle group is identified with a quotient space of the real numbers\n\n ùïä¬π = ‚Ñù  2œÄ‚Ñ§ = bigl x  ‚Ñù  2œÄ‚Ñ§ big x  -œÄœÄ)bigr \n\nIt is equipped with the group operation of adding angles mathrmmod  2œÄ via AdditionGroupOperation.\n\nAs part of the 2D plane ‚Ñù^2\n\nElements of the circle group can be represented as two dimensional real valued vectors x  ‚Ñù of length 1. In that case the circle group is identified with the unit circle in ‚Ñù^2, that is the one dimensional Sphere\n\nùïä^1 = bigl (x y)  ‚Ñù^2 big x^2 + y^2 = 1bigr \n\nIt is equipped with the group operation of adding the angles of two points on the unit circle which corresponds to complex multiplication\n\n(x_1 y_1)  (x_2 y_2) = ( x_1x_2 - y_1y_2 x_1y_2 + x_2y_1)\n\nfor real valued vectors (x_1 y_1)^mathrmT (x_2 y_2)^mathrmT  ‚Ñù^2 via AbelianMultiplicationGroupOperation.\n\nConstructors\n\nCircleGroup(Circle(‚ÑÇ))\nCircleGroup(‚ÑÇ)\nCircleGroup()\n\nGenerate the circle group represented as complex numbers.\n\nCircleGroup(Circle(‚Ñù))\nCircleGroup(‚Ñù)\n\nGenerate the circle group represented as real valued angles x  -œÄ œÄ).\n\nCircleGroup(Sphere(1))\nCircleGroup(‚Ñù^2)\n\nGenerate the circle group represented as two dimensional real valued vectors of unit norm.\n\nThe default representation is by complex numbers and can be constructed with CircleGroup().\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#circle-group-real","page":"Circle Group","title":"Representation on the real line","text":"","category":"section"},{"location":"groups/circle_group/","page":"Circle Group","title":"Circle Group","text":"Modules = [LieGroups]\nPages = [\"groups/circle_group_real.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/circle_group/#Base.exp-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, <:Manifolds.Circle{‚Ñù}}, Number}","page":"Circle Group","title":"Base.exp","text":"exp(::LieGroup{‚Ñù, AdditionGroupOperation, Circle{‚Ñù}}, X)\nexp!(::LieGroup{‚Ñù, AdditionGroupOperation, Circle{‚Ñù}}, g, X)\n\nCompute the Lie group exponential of a vector X of the LieAlgebra of the circle group, represented as angles in -œÄ œÄ). In that case, the Lie algebra is the real line and the Lie group exponential of a vector X  ‚Ñù is its equivalence class\n\n    exp(X) = X  bigl x  ‚Ñù  2œÄ‚Ñ§ big x  -œÄœÄ)bigr \n\nThis can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#Base.log-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, <:Manifolds.Circle{‚Ñù}}, Number}","page":"Circle Group","title":"Base.log","text":"log(::LieGroup{‚Ñù, AdditionGroupOperation, Circle{‚Ñù}}, g)\nlog!(::LieGroup{‚Ñù, AdditionGroupOperation, Circle{‚Ñù}}, X, g)\n\nCompute the Lie group logarithm on the CircleGroup, represented as angles in -œÄœÄ). The LieAlgebra is the real line and log is given by the identity map.\n\nFormally log promotes an equivalence class X to a representative X‚Ñù.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.conjugate!-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, <:Manifolds.Circle{‚Ñù}}, Any, Any, Any}","page":"Circle Group","title":"LieGroups.conjugate!","text":"conjugate(CircleGroup, g, h)\nconjugate!(CircleGroup, k, g, h)\n\nCompute the conjugation map c_g mathcal G  mathcal G given by c_g(h) = ghg^-1 = h. It simplifies to the identity since the group operation on the circle group is abelian.\n\nThis can be computed in-place of k if k is mutable.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.conjugate-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, <:Manifolds.Circle{‚Ñù}}, Any, Any}","page":"Circle Group","title":"LieGroups.conjugate","text":"conjugate(CircleGroup, g, h)\nconjugate!(CircleGroup, k, g, h)\n\nCompute the conjugation map c_g mathcal G  mathcal G given by c_g(h) = ghg^-1 = h. It simplifies to the identity since the group operation on the circle group is abelian.\n\nThis can be computed in-place of k if k is mutable.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.diff_conjugate-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, <:Manifolds.Circle{‚Ñù}}, Any, Any, Number}","page":"Circle Group","title":"LieGroups.diff_conjugate","text":"diff_conjugate(G::LieGroup{‚Ñù, AdditionGroupOperation, Circle{‚Ñù}}, g, h, X)\ndiff_conjugate!(G::LieGroup{‚Ñù, AdditionGroupOperation, Circle{‚Ñù}}, Y, g, h, X)\n\nCompute the differential of the conjugation map c_g(h) = ghg^-1=h. On the circle group represented as part of the real line, this simplifies to D(c_g(h))X = X.\n\nThis can be computed in-place of Y if Y is mutable.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.diff_inv!-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, <:Manifolds.Circle{‚Ñù}}, Any, Any, Any}","page":"Circle Group","title":"LieGroups.diff_inv!","text":"diff_inv(G::LieGroup{‚Ñù, AdditionGroupOperation, Circle{‚Ñù}}, g, X)\ndiff_inv!(G::LieGroup{‚Ñù, AdditionGroupOperation, Circle{‚Ñù}}, Y, g, X)\n\nCompute the the differential DŒπ_mathcal G(g)X of the inversion Œπ_mathcal G(g) = g^-1 = -g at X  ùî§ in the LieAlgebra ùî§ of the real CircleGroup G =mathcal G.\n\nThe computation simplifies due to commutativity to\n\nDŒπ_mathcal G(g)X = -X\n\nThis can be computed in-place of Y if Y is mutable.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.diff_inv-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, <:Manifolds.Circle{‚Ñù}}, Any, Any}","page":"Circle Group","title":"LieGroups.diff_inv","text":"diff_inv(G::LieGroup{‚Ñù, AdditionGroupOperation, Circle{‚Ñù}}, g, X)\ndiff_inv!(G::LieGroup{‚Ñù, AdditionGroupOperation, Circle{‚Ñù}}, Y, g, X)\n\nCompute the the differential DŒπ_mathcal G(g)X of the inversion Œπ_mathcal G(g) = g^-1 = -g at X  ùî§ in the LieAlgebra ùî§ of the real CircleGroup G =mathcal G.\n\nThe computation simplifies due to commutativity to\n\nDŒπ_mathcal G(g)X = -X\n\nThis can be computed in-place of Y if Y is mutable.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.sym_rem-Union{Tuple{N}, Tuple{N, Any}} where N<:Number","page":"Circle Group","title":"LieGroups.sym_rem","text":"sym_rem(x,[T=œÄ])\n\nCompute symmetric remainder of x with respect to the interall 2*T, i.e. (x+T)%2T, where the default for T is œÄ.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#ManifoldsBase.exp!-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, <:Manifolds.Circle{‚Ñù}}, Any, Any}","page":"Circle Group","title":"ManifoldsBase.exp!","text":"exp(::LieGroup{‚Ñù, AdditionGroupOperation, Circle{‚Ñù}}, X)\nexp!(::LieGroup{‚Ñù, AdditionGroupOperation, Circle{‚Ñù}}, g, X)\n\nCompute the Lie group exponential of a vector X of the LieAlgebra of the circle group, represented as angles in -œÄ œÄ). In that case, the Lie algebra is the real line and the Lie group exponential of a vector X  ‚Ñù is its equivalence class\n\n    exp(X) = X  bigl x  ‚Ñù  2œÄ‚Ñ§ big x  -œÄœÄ)bigr \n\nThis can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#ManifoldsBase.log!-Tuple{LieGroup{‚Ñù, AdditionGroupOperation, <:Manifolds.Circle{‚Ñù}}, Any, Any}","page":"Circle Group","title":"ManifoldsBase.log!","text":"log(::LieGroup{‚Ñù, AdditionGroupOperation, Circle{‚Ñù}}, g)\nlog!(::LieGroup{‚Ñù, AdditionGroupOperation, Circle{‚Ñù}}, X, g)\n\nCompute the Lie group logarithm on the CircleGroup, represented as angles in -œÄœÄ). The LieAlgebra is the real line and log is given by the identity map.\n\nFormally log promotes an equivalence class X to a representative X‚Ñù.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#circle-group-complex","page":"Circle Group","title":"Representation on the complex plane","text":"","category":"section"},{"location":"groups/circle_group/","page":"Circle Group","title":"Circle Group","text":"Modules = [LieGroups]\nPages = [\"groups/circle_group_complex.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/circle_group/#Base.exp-Tuple{LieGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, <:Manifolds.Circle{‚ÑÇ}}, Number}","page":"Circle Group","title":"Base.exp","text":"exp(::LieGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, Circle{‚ÑÇ}}, X)\nexp!(::LieGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, Circle{‚ÑÇ}}, g, X)\n\nComputes the Lie group exponential on the complex CircleGroup, which coincides with the ordinary complex exponential.\n\nThe Lie algebra is precisely the imaginary axis of the complex plane.\n\nThis can be computed in-place of g.\n\nexp (mathrmit) = cos(t) + mathrmisin(t)\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#Base.log-Tuple{LieGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, <:Manifolds.Circle{‚ÑÇ}}, Any}","page":"Circle Group","title":"Base.log","text":"log(::CircleGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, Circle{‚ÑÇ}}, g)\nlog!(::CircleGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, Circle{‚ÑÇ}}, X, g)\n\nCompute the Lie group logarithm on the complex CircleGroup, which coincides with the ordinary complex logarithm.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.diff_left_compose-Tuple{LieGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, <:Manifolds.Circle{‚ÑÇ}}, Number, Any, Number}","page":"Circle Group","title":"LieGroups.diff_left_compose","text":"diff_left_compose(::LieGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, Circle{‚ÑÇ}}, g, h, X)\ndiff_left_compose(::LieGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, Circle{‚ÑÇ}}, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh. On the complex circle the differential simplifies to the ordinary complex multiplication\n\n    Œª_g(h) = g  X\n\nThis can be computed in-place of Y if Y is mutable.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.diff_right_compose-Tuple{LieGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, <:Manifolds.Circle{‚ÑÇ}}, Number, Any, Number}","page":"Circle Group","title":"LieGroups.diff_right_compose","text":"diff_right_compose(::LieGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, Circle{‚ÑÇ}}, g, h, X)\ndiff_right_compose(::LieGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, Circle{‚ÑÇ}}, Y, g, h, X)\n\nCompute the differential of the right group multiplication œÅ_g(h) = hg. On the complex circle the differential simplifies to the ordinary complex multiplication\n\n    œÅ_g(h) = X  g\n\nThis can be computed in-place of Y if Y is mutable due to the wrapper defined in the AbelianMultiplicationGroupOperation.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#ManifoldsBase.exp!-Tuple{LieGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, <:Manifolds.Circle{‚ÑÇ}}, Any, Any}","page":"Circle Group","title":"ManifoldsBase.exp!","text":"exp(::LieGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, Circle{‚ÑÇ}}, X)\nexp!(::LieGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, Circle{‚ÑÇ}}, g, X)\n\nComputes the Lie group exponential on the complex CircleGroup, which coincides with the ordinary complex exponential.\n\nThe Lie algebra is precisely the imaginary axis of the complex plane.\n\nThis can be computed in-place of g.\n\nexp (mathrmit) = cos(t) + mathrmisin(t)\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#ManifoldsBase.log!-Tuple{LieGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, <:Manifolds.Circle{‚ÑÇ}}, Any, Any}","page":"Circle Group","title":"ManifoldsBase.log!","text":"log(::CircleGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, Circle{‚ÑÇ}}, g)\nlog!(::CircleGroup{‚ÑÇ, AbelianMultiplicationGroupOperation, Circle{‚ÑÇ}}, X, g)\n\nCompute the Lie group logarithm on the complex CircleGroup, which coincides with the ordinary complex logarithm.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#circle-group-plane","page":"Circle Group","title":"Representation on the 2D-plane","text":"","category":"section"},{"location":"groups/circle_group/","page":"Circle Group","title":"Circle Group","text":"Modules = [LieGroups]\nPages = [\"groups/circle_group_sphere.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/circle_group/#Base.exp-Tuple{LieGroup{‚Ñù, AbelianMultiplicationGroupOperation, <:Manifolds.Sphere{ManifoldsBase.TypeParameter{Tuple{1}}, ‚Ñù}}, Any}","page":"Circle Group","title":"Base.exp","text":"exp(::LieGroup{‚Ñù, AbelianMultiplicationGroupOperation, Sphere}, X)\nexp!(::LieGroup{‚Ñù, AbelianMultiplicationGroupOperation, Sphere}, g, X)\n\nCompute the Lie group exponential on the CircleGroup, represented as two dimensional vectors in the real plane. It coincides with the ordinary complex exponential after canonical identification of the real plane with the complex plane.\n\nThis can be computed in-place of g.\n\nexp beginpmatrix 0 tendpmatrix = beginpmatrix cos(t) sin(t)endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#Base.log-Tuple{LieGroup{‚Ñù, AbelianMultiplicationGroupOperation, <:Manifolds.Sphere{ManifoldsBase.TypeParameter{Tuple{1}}, ‚Ñù}}, Any}","page":"Circle Group","title":"Base.log","text":"log(::LieGroup{‚Ñù, AbelianMultiplicationGroupOperation, Sphere}, g)\nlog!(::LieGroup{‚Ñù, AbelianMultiplicationGroupOperation, Sphere}, X, g)\n\nCompute the Lie group logarithm on the CircleGroup, represented as two dimensional vectors in the real plane. It coincides with the ordinary complex logarithm after canonical identification of the real plane with the complex plane.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.diff_left_compose!-Tuple{LieGroup{‚Ñù, AbelianMultiplicationGroupOperation, <:Manifolds.Sphere{ManifoldsBase.TypeParameter{Tuple{1}}, ‚Ñù}}, Vararg{Any, 4}}","page":"Circle Group","title":"LieGroups.diff_left_compose!","text":"diff_left_compose(G::LieGroup{‚Ñù, AbelianMultiplicationGroupOperation, Sphere}, g, h, X)\ndiff_left_compose!(G::LieGroup{‚Ñù, AbelianMultiplicationGroupOperation, Sphere}, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh of the Circle Group, represented as two dimensional vectors in ‚Ñù^2.\n\nIt simplifies for the AbelianMultiplicationGroupOperation to DŒª_g(h)X = g*X, where the multiplication corresponds to the complex multiplication after canonical identification of the real plane with the complex plane.\n\nThis can be computed in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.diff_left_compose-NTuple{4, Any}","page":"Circle Group","title":"LieGroups.diff_left_compose","text":"diff_left_compose(G::LieGroup{‚Ñù, AbelianMultiplicationGroupOperation, Sphere}, g, h, X)\ndiff_left_compose!(G::LieGroup{‚Ñù, AbelianMultiplicationGroupOperation, Sphere}, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh of the Circle Group, represented as two dimensional vectors in ‚Ñù^2.\n\nIt simplifies for the AbelianMultiplicationGroupOperation to DŒª_g(h)X = g*X, where the multiplication corresponds to the complex multiplication after canonical identification of the real plane with the complex plane.\n\nThis can be computed in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#LieGroups.diff_right_compose!-Tuple{LieGroup{‚Ñù, AbelianMultiplicationGroupOperation, <:Manifolds.Sphere{ManifoldsBase.TypeParameter{Tuple{1}}, ‚Ñù}}, Vararg{Any, 4}}","page":"Circle Group","title":"LieGroups.diff_right_compose!","text":"diff_right_compose(G::LieGroup{‚Ñù, AbelianMultiplicationGroupOperation, Sphere}, g, h, X)\ndiff_right_compose!(G::LieGroup{‚Ñù, AbelianMultiplicationGroupOperation, Sphere}, Y, g, h, X)\n\nCompute the differential of the right group multiplication Œª_g(h) = gh of the Circle Group, represented as two dimensional vectors in ‚Ñù^2.\n\nIt simplifies for the AbelianMultiplicationGroupOperation to DŒª_g(h)X = X*g, where the multiplication corresponds to the complex multiplication after canonical identification of the real plane with the complex plane.\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#ManifoldsBase.exp!-Tuple{LieGroup{‚Ñù, AbelianMultiplicationGroupOperation, <:Manifolds.Sphere{ManifoldsBase.TypeParameter{Tuple{1}}, ‚Ñù}}, Any, Any}","page":"Circle Group","title":"ManifoldsBase.exp!","text":"exp(::LieGroup{‚Ñù, AbelianMultiplicationGroupOperation, Sphere}, X)\nexp!(::LieGroup{‚Ñù, AbelianMultiplicationGroupOperation, Sphere}, g, X)\n\nCompute the Lie group exponential on the CircleGroup, represented as two dimensional vectors in the real plane. It coincides with the ordinary complex exponential after canonical identification of the real plane with the complex plane.\n\nThis can be computed in-place of g.\n\nexp beginpmatrix 0 tendpmatrix = beginpmatrix cos(t) sin(t)endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"groups/circle_group/#ManifoldsBase.log!-Tuple{LieGroup{‚Ñù, AbelianMultiplicationGroupOperation, <:Manifolds.Sphere{ManifoldsBase.TypeParameter{Tuple{1}}, ‚Ñù}}, Any, Any}","page":"Circle Group","title":"ManifoldsBase.log!","text":"log(::LieGroup{‚Ñù, AbelianMultiplicationGroupOperation, Sphere}, g)\nlog!(::LieGroup{‚Ñù, AbelianMultiplicationGroupOperation, Sphere}, X, g)\n\nCompute the Lie group logarithm on the CircleGroup, represented as two dimensional vectors in the real plane. It coincides with the ordinary complex logarithm after canonical identification of the real plane with the complex plane.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"EditURL = \"https://github.com/JuliaManifolds/LieGroups.jl/blob/main/CONTRIBUTING.md\"","category":"page"},{"location":"contributing/#Contributing-to-LieGroups.jl","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"First, thanks for taking the time to contribute. We appreciate and welcome any contribution.","category":"page"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"The following is a set of guidelines to LieGroups.jl.","category":"page"},{"location":"contributing/#Table-of-contents","page":"Contributing to LieGroups.jl","title":"Table of contents","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Contributing to LieGroups.jl     - Table of Contents\nHow to just ask a question\nHow to file an issue\nHow to contribute\nCode style","category":"page"},{"location":"contributing/#How-to-just-ask-a-question","page":"Contributing to LieGroups.jl","title":"How to just ask a question","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"You can most easily reach the developers in the Julia Slack channel #manifolds. You can apply for the Julia Slack workspace here if you haven't joined yet. You can also ask your question on discourse.julialang.org.","category":"page"},{"location":"contributing/#How-to-file-an-issue","page":"Contributing to LieGroups.jl","title":"How to file an issue","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"If you found a bug or want to propose a feature, please open an issue in within the GitHub repository.","category":"page"},{"location":"contributing/#How-to-contribute","page":"Contributing to LieGroups.jl","title":"How to contribute","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Currently most details are still work-in-progress. Feel free to contribute ideas, features you would like to see, Lie groups you want to have or would like to contribute, or any other idea for LieGroups.jl. For these, use either the discussions or issues in the GitHub repository","category":"page"},{"location":"contributing/#Code-style","page":"Contributing to LieGroups.jl","title":"Code style","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Please follow the documentation guidelines from the Julia documentation as well as Blue Style. Run JuliaFormatter.jl on the repository running using JuliaFormatter; format(\".\") on the main folder of the project.","category":"page"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Please follow a few internal conventions:","category":"page"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Include the mathematical formulae for any implemented function if a closed form exists.\nDefine a Lie group, a Lie group action, or a Lie algebra in its own file. Include all related functions in the same file\nan alphabetical order of functions in every file is preferable.\nThe preceding implies that the mutating variant of a function follows the non-mutating variant.\nDocument both the allocating and the mutating variants of a function. To avoid duplication, attach one doc string defined before both functions and attach it to both.\nThere should be no dangling = signs.\nAdd a newline between things of different types (struct/method/const).\nAdd a newline between methods for different functions (including allocating/mutating variants).\nPrefer to have no newline between methods for the same function; when reasonable, merge the documentation strings.\nAll import/using/include should be in the main module file.\nAvoid using import and use the explicit full name, like Base.exp, when implementing functions, that extend functions of other packages.\nif possible provide both mathematical formulae and literature references using DocumenterCitations.jl and BibTeX where possible\nAlways document all input variables and keyword arguments","category":"page"},{"location":"groups/special_euclidean_group/#The-special-Euclidean-group","page":"Special Euclidean group","title":"The special Euclidean group","text":"","category":"section"},{"location":"groups/special_euclidean_group/","page":"Special Euclidean group","title":"Special Euclidean group","text":"SpecialEuclideanGroup","category":"page"},{"location":"groups/special_euclidean_group/#LieGroups.SpecialEuclideanGroup","page":"Special Euclidean group","title":"LieGroups.SpecialEuclideanGroup","text":"SpecialEuclideanGroup{T}\n\nThe special Euclidean group mathrmSE(n) = mathrmSO(n)  mathcal T(n) is the Lie group consisting of the LeftSemidirectProductGroupOperation of the SpecialOrthogonalGroup and the TranslationGroup together with the GroupOperationAction{LeftGroupOperationAction}.\n\nTo be precise, the group operation is defined on mathrmSO(n)  mathcal T(n) as follows:\n\n(r_1 t_1)  (r_2 t_2) = (r_1r_2 t_1 + r_1t_2)\n\nwhere r_1r_2  mathrmSO(n) and t_1t_2  mathcal T(n)\n\nAnalogously you can write this on elements of mathrmSO(n)  mathcal T(n) as\n\n(t_1 r_1)  (t_2 r_2) = (t_1 + r_1s_2 r_1r_2)\n\nBoth these cases can be represented in a single matrix in affine form\n\ng = beginpmatrix r  t mathbf0_n^mathrmT  1endpmatrix\nqquad r  mathrmSO(n) t  mathcal T(n)\n\nwhere mathbf0_n  ‚Ñù^n denotes the vector containing zeros.\n\nWe refer also in general to elements on mathrmSE(n) as g and their rotation and translation components as r and t, respectively.\n\nConstructor\n\nSpecialEuclideanGroup(n::Int; variant=:left, kwargs...)\nSpecialOrthogonalGroup(n; kwargs...) ‚ãâ TranslationGroup(n; kwargs...)\nTranslationGroup(n; kwargs...) ‚ãä SpecialOrthogonalGroup(n; kwargs...)\n\nGenerate special Euclidean group mathrmSE(n) = mathrmSO(n)  mathcal T(n), where the first constructor is equivalent to the second.\n\nAll keyword arguments in kwargs... are passed on to Rotations as well.\n\nThe default representation for mathrmSE(n) is the affine form. Alternatively you can use the ArrayPartition from RecursiveArrayTools.jl to work on (rt). or for mathcal T(n)  mathrmSO(n) using the ArrayPartitions (tr); which corresponds to setting variant=:right in the first constructor.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_euclidean_group/#Representation-of-points-and-tangent-vectors","page":"Special Euclidean group","title":"Representation of points and tangent vectors","text":"","category":"section"},{"location":"groups/special_euclidean_group/","page":"Special Euclidean group","title":"Special Euclidean group","text":"SpecialEuclideanMatrixPoint\nSpecialEuclideanMatrixTangentVector\nSpecialEuclideanProductPoint\nSpecialEuclideanProductTangentVector","category":"page"},{"location":"groups/special_euclidean_group/#LieGroups.SpecialEuclideanMatrixPoint","page":"Special Euclidean group","title":"LieGroups.SpecialEuclideanMatrixPoint","text":"SpecialEuclideanMatrixPoint <: AbstractLieGroupPoint\n\nrepresent a point on some AbstractLieGroup by an affine matrix.\n\nbeginpmatrix M  v mathbf0_n^mathrmT  1endpmatrix  ‚Ñù^(n+1)(n+1)\nqquad M  ‚Ñù^nn v  mathcal T(n)\n\nwhere mathbf0_n  ‚Ñù^n denotes the vector containing zeros.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_euclidean_group/#LieGroups.SpecialEuclideanMatrixTangentVector","page":"Special Euclidean group","title":"LieGroups.SpecialEuclideanMatrixTangentVector","text":"SpecialEuclideanMatrixTangentVector <: AbstractLieAlgebraTangentVector\n\nrepresent a tangent vector on some AbstractLieGroup by a matrix of the form\n\nbeginpmatrix M  v mathbf0_n^mathrmT  0endpmatrix  ‚Ñù^(n+1)(n+1)\nqquad M  ‚Ñù^nn v  mathcal T(n)\n\nwhere mathbf0_n  ‚Ñù^n denotes the vector containing zeros.\n\nWhile this tangent vector itself is not an affine matrix itself, it can be used for the Lie algebra of the affine group\n\n\n\n\n\n","category":"type"},{"location":"groups/special_euclidean_group/#LieGroups.SpecialEuclideanProductPoint","page":"Special Euclidean group","title":"LieGroups.SpecialEuclideanProductPoint","text":"SpecialEuclideanProductPoint <: AbstractLieGroupPoint\n\nRepresent a point on a Lie group (explicitly) as a point that consists of components\n\n\n\n\n\n","category":"type"},{"location":"groups/special_euclidean_group/#LieGroups.SpecialEuclideanProductTangentVector","page":"Special Euclidean group","title":"LieGroups.SpecialEuclideanProductTangentVector","text":"SpecialEuclideanProductTangentVector <: AbstractLieAlgebraTangentVector\n\nRepresent a point on a Lie algebra (explicitly) as a tangent vector that consists of components.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_euclidean_group/#Specific-functions","page":"Special Euclidean group","title":"Specific functions","text":"","category":"section"},{"location":"groups/special_euclidean_group/","page":"Special Euclidean group","title":"Special Euclidean group","text":"Modules = [LieGroups]\nPages = [\"groups/special_euclidean_group.jl\"]\nOrder = [:function]","category":"page"},{"location":"groups/special_euclidean_group/#Base.exp-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{2}}, ‚Ñù}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}, Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{2}}, ‚Ñù}}}}}, Any}","page":"Special Euclidean group","title":"Base.exp","text":"exp(G::SpecialEuclidean, X)\nexp!(G::SpecialEuclidean, g, X)\n\nCompute the Lie group exponential function on the SpecialEuclideanGroup G=mathrmSE(2) using a TypeParameter{Tuple{2}} for dispatch.\n\nThe Lie algebra vector X = (Y v)  mathfrak se(2) consists of a rotation component Y  mathfrak so(2) and a translation component v  mathfrak t(2), so we can use vee on mathrmSO(2) to obtain the angle of rotation Œ± (or alternatively using sqrt2Œ± = lVert Y rVert_)\n\nFor Œ±  0 define\n\nU_Œ± = fracsinŒ±Œ±I_2 + frac1-cosŒ±Œ±^2Y\n\nand U_0 = I_2, where I_2 is the identity matrix.\n\nThen the result g=(Rt) is given by\n\nR = exp_mathrmSO(2)Y  mathrmSO(2)\nquad\ntext and \nquad\nt = U_Œ±v  mathcal T(2)\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.exp-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ‚Ñù}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ‚Ñù}}}}}, Any}","page":"Special Euclidean group","title":"Base.exp","text":"exp(G::SpecialEuclidean, X)\nexp!(G::SpecialEuclidean, g, X)\n\nCompute the Lie group exponential function on the SpecialEuclideanGroup G=mathrmSE(3) using a TypeParameter{Tuple{3}} for dispatch.\n\nSince X = (Y v)  mathfrak se(3) consists of a rotation component Y  mathfrak se(3) and a translation component v  mathfrak t(3), we can use vee on mathrmSO(3) computing the coefficients norm to obtain the angle of rotation Œ± (or alternatively using sqrt2Œ± = lVert Y rVert_).\n\nFor Œ±  0 define\n\nU_Œ± = I_3 + frac1-cosŒ±Œ±^2Y + fracŒ±-sinŒ±Œ±^3Y^2\n\nand U_0 = I_3, where I_2 is the identity matrix.\n\nThen the result g=(Rt) is given by\n\nR = exp_mathrmSO(3)Y  mathrmSO(3)\nquad\ntext and \nquad\nt = U_Œ±v  mathcal T(3)\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.getindex-Tuple{Union{Identity, SpecialEuclideanMatrixPoint, SpecialEuclideanProductPoint}, Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{T, ‚Ñù}, Manifolds.Rotations{T}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{T}, Manifolds.Euclidean{T, ‚Ñù}}}}} where T, Union{Int64, Symbol}}","page":"Special Euclidean group","title":"Base.getindex","text":"g[G::SpecialEuclideanGroup,s]\ngetindex(g, G::SpecialEuclideanGroup, s)\nX[ùî§,s]\ngetindex(g, ùî§, s)\n\nAccess sub-parts of a SpecialEuclideanGroup G or its Lie algebra ùî§. where s can be an index :Rotation, :Translation to access the single parts. Use : to access all submanifold components as a unified tuple.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.getindex-Tuple{Union{SpecialEuclideanMatrixTangentVector, SpecialEuclideanProductTangentVector}, ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, <:SpecialEuclideanGroup{T} where T, Identity{var\"#s239\"}} where var\"#s239\"<:(Union{var\"#s106\", var\"#s105\"} where {var\"#s106\"<:(LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}), var\"#s105\"<:(RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction})}), Colon}","page":"Special Euclidean group","title":"Base.getindex","text":"g[G::SpecialEuclideanGroup,s]\ngetindex(g, G::SpecialEuclideanGroup, s)\nX[ùî§,s]\ngetindex(g, ùî§, s)\n\nAccess sub-parts of a SpecialEuclideanGroup G or its Lie algebra ùî§. where s can be an index :Rotation, :Translation to access the single parts. Use : to access all submanifold components as a unified tuple.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.getindex-Tuple{Union{SpecialEuclideanMatrixTangentVector, SpecialEuclideanProductTangentVector}, ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, <:SpecialEuclideanGroup{T} where T, Identity{var\"#s239\"}} where var\"#s239\"<:(Union{var\"#s106\", var\"#s105\"} where {var\"#s106\"<:(LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}), var\"#s105\"<:(RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction})}), Union{Int64, Symbol}}","page":"Special Euclidean group","title":"Base.getindex","text":"g[G::SpecialEuclideanGroup,s]\ngetindex(g, G::SpecialEuclideanGroup, s)\nX[ùî§,s]\ngetindex(g, ùî§, s)\n\nAccess sub-parts of a SpecialEuclideanGroup G or its Lie algebra ùî§. where s can be an index :Rotation, :Translation to access the single parts. Use : to access all submanifold components as a unified tuple.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.inv-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{T, ‚Ñù}, Manifolds.Rotations{T}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{T}, Manifolds.Euclidean{T, ‚Ñù}}}}} where T, Any}","page":"Special Euclidean group","title":"Base.inv","text":"inv(G::SpecialEuclideanGroup, g)\ninv(G::SpecialEuclideanGroup, h, g)\n\nCompute the inverse element of a g  mathrmSE(n) from the SpecialEuclideanGroup(n).\n\nIn affine form, g = beginpmatrix r  t mathbf0_n^mathrmT  1endpmatrix, where mathbf0_n  ‚Ñù^n denotes the vector containing zeros.\n\nThe inverse reads\n\ng^-1 = beginpmatrix r^mathrmT  -r^mathrmTt mathbf0_n^mathrmT  1endpmatrix\n\nThis computation can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.log-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{2}}, ‚Ñù}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}, Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{2}}, ‚Ñù}}}}}, Any}","page":"Special Euclidean group","title":"Base.log","text":"log(G::SpecialEuclidean, g)\nlog!(G::SpecialEuclidean, X, g)\n\nCompute the Lie group logarithm function on the SpecialEuclideanGroup G=mathrmSE(2), and G uses a TypeParameter{Tuple{2}} for dispatch.\n\nSince g=(Rt)  mathrmSE(2) consists of a rotation component R  mathrmSO(2) and a translation component t  mathcal T(2), we first compute Y = log_mathrmSO(2)R. Then we can use vee on mathrmSO(2) to obtain the angle of rotation Œ± (or alternatively using sqrt2Œ± = lVert Y rVert_)\n\nFor Œ±  0 define\n\nV_Œ± = fracŒ±2 beginpmatrix fracsinŒ±1-cosŒ±  1 -1  fracsinŒ±1-cosŒ±endpmatrix\n\nand V_0 = I_2, where I_2 is the identity matrix. Note that this is the inverse of U_Œ± as given in the group exponential\n\nThen the result X = (Y v)  mathfrak se(2) is given by Y  mathfrak so(2) as computed above and\n\nv = V_Œ±r  mathcal T(2)\n\nwhere v is computed in-place without setting up V_Œ±\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#Base.log-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ‚Ñù}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ‚Ñù}}}}}, Any}","page":"Special Euclidean group","title":"Base.log","text":"log(G::SpecialEuclidean, g)\nlog!(G::SpecialEuclidean, X, g)\n\nCompute the Lie group logarithm function on the SpecialEuclideanGroup G=mathrmSE(3), where e is the Identity on mathrmSE(3) G uses a TypeParameter{Tuple{3}} for dispatch.\n\nSince g=(Rt)  mathrmSE(3) consists of a rotation component R  mathrmSO(3) and a translation component t  mathcal T(2), we first compute Y = log_mathrmSO(3)R. Then we can use vee on mathrmSO(3) to obtain the angle of rotation Œ± (or alternatively using sqrt2Œ± = lVert Y rVert_)\n\nFor Œ±  0 define\n\nV_Œ± = I_3 - frac12Y + Œ≤ Y^2 quadtext where  Œ≤ = frac1Œ±^2 - frac1 + cos(Œ±)2Œ±sin(Œ±)\n\nand V_0 = I_3, where I_3 is the identity matrix. Note that this is the inverse of U_Œ± as given in the group exponential\n\nThen the result X = (Y v)  mathfrak se(3) is given by Y  mathfrak so(3) as computed above and v = V_Œ± t  mathfrak t(3).\n\nThis result can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.default_left_action-Tuple{SpecialOrthogonalGroup, TranslationGroup}","page":"Special Euclidean group","title":"LieGroups.default_left_action","text":"default_left_action(G::SpecialOrthogonalGroup, ::TranslationGroup)\n\nReturn the default left action for the special Euclidean group mathrmSO(n)  mathcal T(n), that is the GroupOperationAction(LeftGroupOperationAction(G.op)).\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.default_right_action-Tuple{TranslationGroup, SpecialOrthogonalGroup}","page":"Special Euclidean group","title":"LieGroups.default_right_action","text":"default_right_action(::TranslationGroup, G::SpecialOrthogonalGroup)\n\nReturn the default right action for the special Euclidean group, that is the GroupOperationAction(LeftGroupOperationAction(G.op)).\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.init_constants!-Tuple{ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, <:SpecialEuclideanGroup{T} where T, Identity{var\"#s239\"}} where var\"#s239\"<:(Union{var\"#s106\", var\"#s105\"} where {var\"#s106\"<:(LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}), var\"#s105\"<:(RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction})}), AbstractMatrix}","page":"Special Euclidean group","title":"LieGroups.init_constants!","text":"init_constants!(G::SpecialEuclidean, g)\ninit_Constants!(ùî∞ùî¢::LieAlgebra{‚Ñù, SpecialEuclideanGroupOperation, SpecialEuclidean}, X)\n\nInitialize the constant elements of g or X.\n\nThe matrix representation of gmathrmSE(n) has a last row, that contains zeros, besides the diagonal element, which is g_n+1n+1 = 1.\n\nThe matrix representation of Xmathfrak se(n) has a last row that contains zeros.\n\nthis function sets these entries accordingly.\n\nPer default for other representations, this function does not change entries for them.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.init_constants!-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{T, ‚Ñù}, Manifolds.Rotations{T}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{T}, Manifolds.Euclidean{T, ‚Ñù}}}}} where T, AbstractMatrix}","page":"Special Euclidean group","title":"LieGroups.init_constants!","text":"init_constants!(G::SpecialEuclidean, g)\ninit_Constants!(ùî∞ùî¢::LieAlgebra{‚Ñù, SpecialEuclideanGroupOperation, SpecialEuclidean}, X)\n\nInitialize the constant elements of g or X.\n\nThe matrix representation of gmathrmSE(n) has a last row, that contains zeros, besides the diagonal element, which is g_n+1n+1 = 1.\n\nThe matrix representation of Xmathfrak se(n) has a last row that contains zeros.\n\nthis function sets these entries accordingly.\n\nPer default for other representations, this function does not change entries for them.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#LieGroups.inv!-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{T, ‚Ñù}, Manifolds.Rotations{T}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{T}, Manifolds.Euclidean{T, ‚Ñù}}}}} where T, AbstractMatrix, AbstractMatrix}","page":"Special Euclidean group","title":"LieGroups.inv!","text":"inv(G::SpecialEuclideanGroup, g)\ninv(G::SpecialEuclideanGroup, h, g)\n\nCompute the inverse element of a g  mathrmSE(n) from the SpecialEuclideanGroup(n).\n\nIn affine form, g = beginpmatrix r  t mathbf0_n^mathrmT  1endpmatrix, where mathbf0_n  ‚Ñù^n denotes the vector containing zeros.\n\nThe inverse reads\n\ng^-1 = beginpmatrix r^mathrmT  -r^mathrmTt mathbf0_n^mathrmT  1endpmatrix\n\nThis computation can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#ManifoldsBase.exp!-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ‚Ñù}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ‚Ñù}}}}}, AbstractMatrix, AbstractMatrix}","page":"Special Euclidean group","title":"ManifoldsBase.exp!","text":"exp(G::SpecialEuclidean, X)\nexp!(G::SpecialEuclidean, g, X)\n\nCompute the Lie group exponential function on the SpecialEuclideanGroup G=mathrmSE(3) using a TypeParameter{Tuple{3}} for dispatch.\n\nSince X = (Y v)  mathfrak se(3) consists of a rotation component Y  mathfrak se(3) and a translation component v  mathfrak t(3), we can use vee on mathrmSO(3) computing the coefficients norm to obtain the angle of rotation Œ± (or alternatively using sqrt2Œ± = lVert Y rVert_).\n\nFor Œ±  0 define\n\nU_Œ± = I_3 + frac1-cosŒ±Œ±^2Y + fracŒ±-sinŒ±Œ±^3Y^2\n\nand U_0 = I_3, where I_2 is the identity matrix.\n\nThen the result g=(Rt) is given by\n\nR = exp_mathrmSO(3)Y  mathrmSO(3)\nquad\ntext and \nquad\nt = U_Œ±v  mathcal T(3)\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#ManifoldsBase.exp!-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{var\"#s240\", ‚Ñù}, Manifolds.Rotations{var\"#s240\"}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{var\"#s240\"}, Manifolds.Euclidean{var\"#s240\", ‚Ñù}}}}} where var\"#s240\"<:ManifoldsBase.TypeParameter{Tuple{2}}, AbstractMatrix, AbstractMatrix}","page":"Special Euclidean group","title":"ManifoldsBase.exp!","text":"exp(G::SpecialEuclidean, X)\nexp!(G::SpecialEuclidean, g, X)\n\nCompute the Lie group exponential function on the SpecialEuclideanGroup G=mathrmSE(2) using a TypeParameter{Tuple{2}} for dispatch.\n\nThe Lie algebra vector X = (Y v)  mathfrak se(2) consists of a rotation component Y  mathfrak so(2) and a translation component v  mathfrak t(2), so we can use vee on mathrmSO(2) to obtain the angle of rotation Œ± (or alternatively using sqrt2Œ± = lVert Y rVert_)\n\nFor Œ±  0 define\n\nU_Œ± = fracsinŒ±Œ±I_2 + frac1-cosŒ±Œ±^2Y\n\nand U_0 = I_2, where I_2 is the identity matrix.\n\nThen the result g=(Rt) is given by\n\nR = exp_mathrmSO(2)Y  mathrmSO(2)\nquad\ntext and \nquad\nt = U_Œ±v  mathcal T(2)\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#ManifoldsBase.log!-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{2}}, ‚Ñù}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{2}}}, Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{2}}, ‚Ñù}}}}}, AbstractMatrix, AbstractMatrix}","page":"Special Euclidean group","title":"ManifoldsBase.log!","text":"log(G::SpecialEuclidean, g)\nlog!(G::SpecialEuclidean, X, g)\n\nCompute the Lie group logarithm function on the SpecialEuclideanGroup G=mathrmSE(2), and G uses a TypeParameter{Tuple{2}} for dispatch.\n\nSince g=(Rt)  mathrmSE(2) consists of a rotation component R  mathrmSO(2) and a translation component t  mathcal T(2), we first compute Y = log_mathrmSO(2)R. Then we can use vee on mathrmSO(2) to obtain the angle of rotation Œ± (or alternatively using sqrt2Œ± = lVert Y rVert_)\n\nFor Œ±  0 define\n\nV_Œ± = fracŒ±2 beginpmatrix fracsinŒ±1-cosŒ±  1 -1  fracsinŒ±1-cosŒ±endpmatrix\n\nand V_0 = I_2, where I_2 is the identity matrix. Note that this is the inverse of U_Œ± as given in the group exponential\n\nThen the result X = (Y v)  mathfrak se(2) is given by Y  mathfrak so(2) as computed above and\n\nv = V_Œ±r  mathcal T(2)\n\nwhere v is computed in-place without setting up V_Œ±\n\nThis result can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_euclidean_group/#ManifoldsBase.log!-Tuple{Union{LieGroup{‚Ñù, <:RightSemidirectProductGroupOperation{<:AdditionGroupOperation, <:MatrixMultiplicationGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ‚Ñù}, Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}}}}, LieGroup{‚Ñù, <:LeftSemidirectProductGroupOperation{<:MatrixMultiplicationGroupOperation, <:AdditionGroupOperation, LeftGroupOperationAction}, <:ManifoldsBase.ProductManifold{‚Ñù, Tuple{Manifolds.Rotations{ManifoldsBase.TypeParameter{Tuple{3}}}, Manifolds.Euclidean{ManifoldsBase.TypeParameter{Tuple{3}}, ‚Ñù}}}}}, AbstractMatrix, AbstractMatrix}","page":"Special Euclidean group","title":"ManifoldsBase.log!","text":"log(G::SpecialEuclidean, g)\nlog!(G::SpecialEuclidean, X, g)\n\nCompute the Lie group logarithm function on the SpecialEuclideanGroup G=mathrmSE(3), where e is the Identity on mathrmSE(3) G uses a TypeParameter{Tuple{3}} for dispatch.\n\nSince g=(Rt)  mathrmSE(3) consists of a rotation component R  mathrmSO(3) and a translation component t  mathcal T(2), we first compute Y = log_mathrmSO(3)R. Then we can use vee on mathrmSO(3) to obtain the angle of rotation Œ± (or alternatively using sqrt2Œ± = lVert Y rVert_)\n\nFor Œ±  0 define\n\nV_Œ± = I_3 - frac12Y + Œ≤ Y^2 quadtext where  Œ≤ = frac1Œ±^2 - frac1 + cos(Œ±)2Œ±sin(Œ±)\n\nand V_0 = I_3, where I_3 is the identity matrix. Note that this is the inverse of U_Œ± as given in the group exponential\n\nThen the result X = (Y v)  mathfrak se(3) is given by Y  mathfrak so(3) as computed above and v = V_Œ± t  mathfrak t(3).\n\nThis result can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/getstarted/#Get-Started-with-LieGroups.jl","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"","category":"section"},{"location":"tutorials/getstarted/#Introduction","page":"üöÄ Get Started with LieGroups.jl","title":"Introduction","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"This tutorial introduces both a few basics of Lie groups as well as how to use LieGroups.jl. The Lie groups we consider are the rotations in the plane, or special orthogonal group as well as rigid body motions, or in other words the special euclidean group.","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"In a nutshell a Lie group ùí¢ is a manifold ‚Ñ≥ that also is a group with a group operation.","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"A manifold can informally be described as a set that ‚Äúlocally looks like a Euclidean space‚Äù and has some way to measure angles at every point. Formally, this yields an inner product that depends (smoothly) on the point one is at. For Lie groups this will be a bit easier.","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"A group means that on the set there also exists an operation, within this package usually denoted by  ùí¢  ùí¢  ùí¢, LieGroups.jl uses the manifolds defined in Manifolds.jl. For more details on that, see also the introductory tutorial there. A Lie group is usually written as a tuple (‚Ñ≥) with the manifold and the group operation thereon.","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"For more theoretical background, see for example [HN12], especially their Chapter 9.","category":"page"},{"location":"tutorials/getstarted/#Rotations-on-the-plane-‚Ñù2-and-in-‚Ñù3.","page":"üöÄ Get Started with LieGroups.jl","title":"Rotations on the plane ‚Ñù^2 and in ‚Ñù^3.","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"This first part considers rotations in the plane. These can be represented by rotation matrices","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"R_Œ± = beginpmatrix cos(Œ±) -sin(Œ±) sin(Œ±)  cos(Œ±) endpmatrixqquad Œ±  ‚Ñù","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"where we already represent all possible rotations when restricting Œ± to 02œÄ. Adding two matrices R_Œ± + R_Œ≤ does not yield a valid rotation matrix again, but we can have these matrices in mind as being ‚Äúlocally like the real line‚Äù, since changing the rotation angle slightly yields rotation matrices that are ‚Äúclose by‚Äù in the sense that they perform nearly the same rotation when applied to a point x  ‚Ñù^2 by computing R_Œ±x. Matrix multiplication R_Œ≤ = R_Œ±_1 R_Œ±_2 does yield a new rotation and also fulfills all other properties to yield a group operation. Using trigonometric identities we observe that R_Œ≤ = R_Œ±_1+Œ±_2. Since the angle of rotation is 2œÄ-periodic, we also see here, that e.g.¬†for small angles around 0, this behaves like the real line, but globally it differs, since R_Œ± = R_Œ±+2œÄ","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"The set of rotation matrices is hence a Lie group and called the special orthogonal group mathrmSO(2). In LieGroups.jl we initialise this as","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"using LieGroups, LinearAlgebra, RecursiveArrayTools, Rotations\nSO2 = SpecialOrthogonalGroup(2)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"SpecialOrthogonalGroup(2)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"Elements g h  mathrmSO(2) we generate as","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"g = [1.0 0.0; 0.0 1.0]\nh = 1/sqrt(2) .* [1.0 -1.0; 1.0 1.0]","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"2√ó2 Matrix{Float64}:\n 0.707107  -0.707107\n 0.707107   0.707107","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"A first thing to do is to use is_point to verify they are valid.","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"(is_point(SO2, g), is_point(SO2, h))","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"(true, true)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"The already mentioned group operation as the matrix multiplication, there is also a generic function available, compose as well as its in-place variant compose!. The following two yield the same matrix","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"[ compose(SO2, g, h), g*h ]","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"2-element Vector{Matrix{Float64}}:\n [0.7071067811865475 -0.7071067811865475; 0.7071067811865475 0.7071067811865475]\n [0.7071067811865475 -0.7071067811865475; 0.7071067811865475 0.7071067811865475]","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"Furthermore a lot of of functions are ‚Äúpassed down‚Äù tp the manifold, which is stored within the LieGroup. For example the dimension of the manifold, or the number of degrees of freedom can be accessed via the manifold_dimension","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"manifold_dimension(SO2)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"1","category":"page"},{"location":"tutorials/getstarted/#The-Lie-algebra,-and-the-Lie-group-exponential-function.","page":"üöÄ Get Started with LieGroups.jl","title":"The Lie algebra, and the Lie group exponential function.","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"For the following investigations, we consider the special orthogonal group mathrmSO(3), that is rotations in a 3-dimensional space. Besides one special rotation in the following code for completeness, a prominent, at first glace maybe a bit ‚Äúdull‚Äù point on this Lie group is the identity matrix e.","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"SO3 = SpecialOrthogonalGroup(3)\ng = RotZ(œÄ/3)*RotY(œÄ/4)\ne = Matrix{Float64}(I,3,3)\ng","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"3√ó3 RotZY{Float64} with indices SOneTo(3)√óSOneTo(3)(1.0472, 0.785398):\n  0.353553  -0.866025  0.353553\n  0.612372   0.5       0.612372\n -0.707107   0.0       0.707107","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"The element g can be seen as a rotation by œÄ3 in the x-y-plane combined with a rotation by œÄ4 in the x-z plane.","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"The tangent space T_eùí¢ plays a special role and is called the LieAlgebra ùî§.","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"Similar to the Riemannian exponential map The exponential function exp_ùí¢ ùî§  ùí¢ maps Lie algebra tangent vectors X  T_eùí¢ to a point on the Lie group. This is implemented in exp(G::LieGroup, X). Its inverse is the Lie group logarithmic function log(G::LieGroup, g).","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"X = log(SO3,g)\nis_point(LieAlgebra(SO3), X)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"true","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"exp(SO3,X)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"3√ó3 StaticArraysCore.MMatrix{3, 3, Float64, 9} with indices SOneTo(3)√óSOneTo(3):\n  0.353553  -0.866025     0.353553\n  0.612372   0.5          0.612372\n -0.707107  -5.55112e-17  0.707107","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"The term ‚Äúexponential‚Äù has at least three different meanings throughout Lie groups and Riemannian manifolds. To be precise, we call the just introduced one ‚Äúexponential function‚Äù, since it often agrees with the matrix exponential.","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"Taking a closed look at X we see","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"X","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"3√ó3 StaticArraysCore.MMatrix{3, 3, Float64, 9} with indices SOneTo(3)√óSOneTo(3):\n  0.0       -0.990825  0.710856\n  0.990825   0.0       0.410413\n -0.710856  -0.410413  0.0","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"an example that all elements from the Lie algebra are skew symmetric matrices. This allows for one way to see that we have three degrees of freedom, cf","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"manifold_dimension(SO3)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"3","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"As the Lie algebra was introduced via a tangent space, we also know that it is a vector space. To ‚Äúturn‚Äù the X into a vector with three elements, we need a basis of the tangent space to decompose X into and ‚Äúread off‚Äù its components. While in general this can be done using the bases of a tangent space from ManifoldsBase.jl, a very specific one is vee(::LieAlgebra, X)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"c = vee(LieAlgebra(SO3), X)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"3-element Vector{Float64}:\n -0.41041311978624273\n  0.7108563755626242\n  0.990824919963801","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"and its inverse, hat(G::LieAlgebra, c)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"X_ = hat(LieAlgebra(SO3),c)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"3√ó3 Matrix{Float64}:\n  0.0       -0.990825  0.710856\n  0.990825   0.0       0.410413\n -0.710856  -0.410413  0.0","category":"page"},{"location":"tutorials/getstarted/#Representing-tangent-vectors","page":"üöÄ Get Started with LieGroups.jl","title":"Representing tangent vectors","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"Consider the function of left group composition Œª_g(h) = gh. Its differential (or push forward) DŒª_g(e) maps from T_eùí¢ to T_gùí¢ and is a linear bijection between both spaces. Its adjoint differential (or pullback) D^*Œª_g(e) maps back from T_gùí¢ to T_eùí¢.","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"This allows to introduce an inner product on all tangent spaces, that smoothly varies with the base point, we obtain the left-invariant metric","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"XY_g = D^*Œª_g(e)XD^*Œª_g(e)_e","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"since it is invariant if you use the differential of the left composition to identify tangent vectors. We can even ‚Äúspare‚Äù the pullbacks in this definition, when representing tangent vector alsways by their correspnding representants in the Lie algebra. This is the default in LieGroups.jl.","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"Alternatively one can start with the right composition and its differential to arrive an right-invariant vector fields and a right-invariant metric.","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"The left-invariant metric is in general not right-invariant, except for compact Lie groups and their direct products with translations, see for example [LT13] for an even more general proof.","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"With respect to this metric on the manifold the exponential and logarithmic maps are given by","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"exp_g(X) = g  exp_ùí¢(X)\nquadtextwith its inversequad\nlog_g(h) = log_ùí¢(g^-1h)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"With respect to these geodesics and the representation in the Lie algebra, parallel transport simplifies to the identity. To still access the Riemannian exponential map with respect to the metric (compatible to the Levi-Civita connection) on the underlying Riemannian manifold, use exp(base_manifold(G), g, X).","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"As an example, we compute","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"h = exp(SO3, g, X)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"3√ó3 StaticArraysCore.MMatrix{3, 3, Float64, 9} with indices SOneTo(3)√óSOneTo(3):\n -0.65533    -0.739199  -0.15533\n  0.0896799  -0.28033    0.955705\n -0.75        0.612372   0.25","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"and its inverse is returning X as well.","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"log(SO3, g, h)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"3√ó3 StaticArraysCore.MMatrix{3, 3, Float64, 9} with indices SOneTo(3)√óSOneTo(3):\n  0.0       -0.990825  0.710856\n  0.990825   0.0       0.410413\n -0.710856  -0.410413  0.0","category":"page"},{"location":"tutorials/getstarted/#The-Special-Euclidean-group-\\mathrm{SE}(3)-of-rigid-body-motions","page":"üöÄ Get Started with LieGroups.jl","title":"The Special Euclidean group mathrmSE(3) of rigid body motions","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"There are two further ingredients this tutorial needs to get towards rigid body motions.","category":"page"},{"location":"tutorials/getstarted/#Group-actions","page":"üöÄ Get Started with LieGroups.jl","title":"Group actions","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"For a group like mathrmSO(3) an action describes how points g  ùí¢ can act on points from a Riemannian manifold p  ‚Ñ≥ ‚Äì in short an action of a certain AbstractGroupActionType ‚Äùcombines‚Äú p and g into a new element q = œÉ_g(p). In the example of ùí¢=mathrmSO(3) and ‚Ñ≥=‚Ñù^3 the action is (just) the application of the rotation or the matrix-vector multiplication œÉ_g(p)=gp. A special case is, when ‚Ñ≥ itself is also a Lie group. In the example this is the case, since together with vector addition p+q we get the TranslationGroup T(3) = (‚Ñù^3 +) Depending on how the concatenation of two types, the AbstractLeftGroupActionType like the one here and a AbstractRightGroupActionType.","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"T3 = TranslationGroup(3)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"TranslationGroup(3; field=‚Ñù)","category":"page"},{"location":"tutorials/getstarted/#Products-and-semidirect-products-of-Lie-groups","page":"üöÄ Get Started with LieGroups.jl","title":"Products and semidirect products of Lie groups","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"Similar to product manifolds (direct) product Lie groups are formed the same way. For two Lie groups ùí¢ = ùí¢_1  ùí¢_2 is the product of the two manifolds together with the component wise application of the group operations: the first group operation (of ùí¢_1) to the first component and that of ùí¢_2 to the second.","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"Instead of the component wise or ‚Äúnot interacting‚Äù variant of the (direct) product Lie groups, for the semidirect product Lie groups ùí¢ = ùí¢_1  ùí¢_2 we also require an action of how ùí¢_1 acts on ùí¢_2. Semidirect here means that the first component of ùí¢ is the same as for the direct product, but before applying the second group operation on ùí¢_2 one of the elements is ‚Äúacted upon‚Äù from an element of ùí¢_1. The group operation reads for (g_1g_2) (h_1h_2)  ùí¢","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"(g_1g_2)  (h_1h_2) = (g_1  h_1 œÉ_h_1(g_2)  h_2)","category":"page"},{"location":"tutorials/getstarted/#Rigid-body-motions","page":"üöÄ Get Started with LieGroups.jl","title":"Rigid body motions","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"We obtain the special Euclidean group mathrmSE(3) = mathrmSO(3)  T(3) where the group action is the one discussed as an example before.","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"SE3 = SpecialEuclideanGroup(3)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"SpecialEuclideanGroup(3)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"which we could also generate with SO3 and T3 from before as","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"SO3 ‚ãâ T3","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"SpecialEuclideanGroup(3)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"This call employs the default_left_action(SO3,T3) to determine the action for the semidirect product Lie group. This is defined whenever for two Lie groups, their (left) action is clear, because there exists a reasonable default. Otherwise the full form","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"LeftSemidirectProductLieGroup(SO3, T3, LeftGroupOperationAction())","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"SpecialEuclideanGroup(3)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"is necessary. Here, the first Left for the semidirect product refers to the fact that the left group acts on the right one before the right group operation is performed. LeftGroupOperationAction refers to that the group operation ‚Äì left multiplication with a matrix ‚Äì is applied here.","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"For this case, any point mathrmSE(3) is a tuple of a rotation matrix and a vector. We model this using RecursiveArrayTools.jl, namely its ArrayPartition. For example with the rotation matrix g from before we have","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"g1 = ArrayPartition(g, [1.0, 0.0, 2.0])","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"([0.35355339059327384 -0.8660254037844386 0.3535533905932738; 0.6123724356957946 0.5000000000000001 0.6123724356957945; -0.7071067811865475 0.0 0.7071067811865476], [1.0, 0.0, 2.0])","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"and for a pure translation we can reuse e as in","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"h1 = ArrayPartition(e, [0.0, 3.0, 0.0])","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0], [0.0, 3.0, 0.0])","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"and we can summarize a few operations from before: both are valid points on SE3","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"(is_point(SE3, g1), is_point(SE3, h1))","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"(true, true)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"we can perform the group operation","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"gh1 = compose(SE3, g1, h1)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"([0.35355339059327384 -0.8660254037844386 0.3535533905932738; 0.6123724356957946 0.5000000000000001 0.6123724356957945; -0.7071067811865475 0.0 0.7071067811865476], [-1.598076211353316, 1.5000000000000004, 2.0])","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"apply the Lie group exponential","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"Y = log(SE3, gh1)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"([0.0 -0.990824919963801 0.7108563755626242; 0.990824919963801 0.0 0.41041311978624273; -0.7108563755626242 -0.41041311978624273 0.0], [-1.4693272604812524, 1.8941219089183496, 1.7705711589135078])","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"and look at the manifold dimension, it is the sum of dimensions of its components","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"manifold_dimension(SE3)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"6","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"The coordinates of Y are","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"vee(LieAlgebra(SE3), Y)","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"6-element Vector{Float64}:\n -0.41041311978624273\n  0.7108563755626242\n  0.990824919963801\n -1.4693272604812524\n  1.8941219089183496\n  1.7705711589135078","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"which actually is component wise again, the first 3 values refer to the rotation part, the second three to the translation part.","category":"page"},{"location":"tutorials/getstarted/#Technical-details","page":"üöÄ Get Started with LieGroups.jl","title":"Technical details","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"This tutorial is cached. It was last run on the following package versions.","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"Status `~/work/LieGroups.jl/LieGroups.jl/tutorials/Project.toml`\n  [7073ff75] IJulia v1.27.0\n  [6774de46] LieGroups v0.1.0 `~/work/LieGroups.jl/LieGroups.jl`\n  [1cead3c2] Manifolds v0.10.16\n  [731186ca] RecursiveArrayTools v3.32.0\n  [6038ab10] Rotations v1.7.1","category":"page"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"This tutorial was last rendered April 22, 2025, 9:8:55.","category":"page"},{"location":"tutorials/getstarted/#Literature","page":"üöÄ Get Started with LieGroups.jl","title":"Literature","text":"","category":"section"},{"location":"tutorials/getstarted/","page":"üöÄ Get Started with LieGroups.jl","title":"üöÄ Get Started with LieGroups.jl","text":"J.¬†Hilgert and K.-H.¬†Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\nD.¬†Latifi and M.¬†Toomanian. On the existence of bi-invariant Finsler metrics on Lie groups. Mathematical¬†Sciences 7, 37 (2013).\n\n\n\n","category":"page"},{"location":"interface/operations/#An-interface-for-Lie-group-operations","page":"Group operation","title":"An interface for Lie group operations","text":"","category":"section"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"AbstractGroupOperation\nIdentity","category":"page"},{"location":"interface/operations/#LieGroups.AbstractGroupOperation","page":"Group operation","title":"LieGroups.AbstractGroupOperation","text":"AbstractGroupOperation\n\nRepresent a type of group operation for a AbstractLieGroup mathcal G, that is a smooth binary operation   mathcal G  mathcal G  mathcal G on elements of a Lie group mathcal G.\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#LieGroups.Identity","page":"Group operation","title":"LieGroups.Identity","text":"Identity{O<:AbstractGroupOperation}\n\nRepresent the group identity element e  mathcal G on an AbstractLieGroup mathcal G with AbstractGroupOperation of type O.\n\nSimilar to the philosophy that points are agnostic of their group at hand, the identity does not store the group mathcal G it belongs to. However it depends on the type of the AbstractGroupOperation used.\n\nSee also identity_element on how to obtain the corresponding AbstractManifoldPoint or array representation.\n\nConstructors\n\nIdentity(::AbstractLieGroup{ùîΩ,O}) where {ùîΩ,O<:AbstractGroupOperation}\nIdentity(o::AbstractGroupOperation)\nIdentity(::Type{AbstractGroupOperation})\n\ncreate the identity of the corresponding subtype O<:AbstractGroupOperation\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"You can combine some specific group operations with one of several manifolds to form a Lie group. You can still define the corresponding functions generically for all groups with this group operation regardless of the manifold. The following sections collect these.","category":"page"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"an AdditionGroupOperation\nan AbelianMultiplicationGroupOperation and\na MatrixMultiplicationGroupOperation","category":"page"},{"location":"interface/operations/#addition-operation-sec","page":"Group operation","title":"Additive group operation","text":"","category":"section"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"Modules = [LieGroups]\nPages = [\"addition_operation.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"interface/operations/#LieGroups.AdditionGroupOperation","page":"Group operation","title":"LieGroups.AdditionGroupOperation","text":"AdditionGroupOperation <: AbstractGroupOperation\n\nA group operation that is realised introducing defaults that fall back to + and - being overloaded, for example _compose(G::LieGroup{ùîΩ,AdditionGroupOperation}, a, b) = a + b\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#Base.exp-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any}} where ùîΩ","page":"Group operation","title":"Base.exp","text":"exp(G::LieGroup{ùîΩ,AdditionGroupOperation}, X)\nexp!(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, X)\n\nCompute the Lie group exponential on a LieGroup with an AdditionGroupOperation. This can be computed in-place of g.\n\nSince e is just the zero-element with respect to the corresponding +, the formula reads g=0+X=X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.inv-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any}} where ùîΩ","page":"Group operation","title":"Base.inv","text":"inv(G::LieGroup{ùîΩ,AdditionGroupOperation}, g)\ninv!(G::LieGroup{ùîΩ,AdditionGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for the AdditionGroupOperation simplifies to -g. This can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.log-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any}} where ùîΩ","page":"Group operation","title":"Base.log","text":"log(G::LieGroup{ùîΩ,AdditionGroupOperation}, g)\nlog!(G::LieGroup{ùîΩ,AdditionGroupOperation}, X, g)\n\nCompute the Lie group logarithm on a LieGroup with an AdditionGroupOperation. This can be computed in-place of X.\n\nSince e is just the zero-element with respect to the corresponding +, the formula reads X=g-0=g.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.compose!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.compose!","text":"compose(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, h)\ncompose!(G::LieGroup{ùîΩ,AdditionGroupOperation}, k, g, h)\n\nCompute the group operation composition of g and h with respect to the AdditionGroupOperation on G, which falls back to calling g+h, where + is assumed to be overloaded accordingly.\n\nThis can be computed in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Vararg{Any, 4}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_conjugate!","text":"diff_conjugate(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjutage c_g(h) = ghg^-1 = g+h-g = h, which simplifies for AdditionGroupOperation to D(c_g(h))X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_conjugate","text":"diff_conjugate(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjutage c_g(h) = ghg^-1 = g+h-g = h, which simplifies for AdditionGroupOperation to D(c_g(h))X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_inv!","text":"diff_inv(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, g, X)\n\nCompute the differential of the inverse operation Œπ_mathcal G(g) = g^-1 = -g, which simplifies for AdditionGroupOperation to DŒπ_mathcal G(g)X = -X\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_inv","text":"diff_inv(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, g, X)\n\nCompute the differential of the inverse operation Œπ_mathcal G(g) = g^-1 = -g, which simplifies for AdditionGroupOperation to DŒπ_mathcal G(g)X = -X\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Vararg{Any, 4}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_left_compose!","text":"diff_left_compose(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh, which simplifies for AdditionGroupOperation to DŒª_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_left_compose","text":"diff_left_compose(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh, which simplifies for AdditionGroupOperation to DŒª_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Vararg{Any, 4}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_right_compose!","text":"diff_right_compose(G::LieGroup{ùîΩ,AdditionGroupOperation}, h, g, X)\ndiff_right_compose!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, h, g, X)\n\nCompute the differential of the right group multiplication œÅ_g(h) = hg, which simplifies for AdditionGroupOperation to DœÅ_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_right_compose","text":"diff_right_compose(G::LieGroup{ùîΩ,AdditionGroupOperation}, h, g, X)\ndiff_right_compose!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, h, g, X)\n\nCompute the differential of the right group multiplication œÅ_g(h) = hg, which simplifies for AdditionGroupOperation to DœÅ_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.identity_element!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.identity_element!","text":"identity_element(G::LieGroup{ùîΩ,AdditionGroupOperation})\nidentity_element!(G::LieGroup{ùîΩ,AdditionGroupOperation}, e)\n\nReturn the a point representation of the Identity, which for the AdditionGroupOperation is the zero element or array.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.inv!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.inv!","text":"inv(G::LieGroup{ùîΩ,AdditionGroupOperation}, g)\ninv!(G::LieGroup{ùîΩ,AdditionGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for the AdditionGroupOperation simplifies to -g. This can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket!-Union{Tuple{O}, Tuple{ùîΩ}, Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, <:LieGroup{ùîΩ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Identity{O}}, Any, Any, Any}} where {ùîΩ, O<:AdditionGroupOperation}","page":"Group operation","title":"LieGroups.lie_bracket!","text":"lie_bracket!(ùî§::LieAlgebra{ùîΩ,AdditionGroupOperation}, X, Y)\nlie_bracket!(ùî§::LieAlgebra{ùîΩ,AdditionGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the AdditionGroupOperation simplifies to the corresponding zero_vector. The computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket-Union{Tuple{ùîΩ}, Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{AdditionGroupOperation}} where G<:(AbstractLieGroup{var\"#s21\", AdditionGroupOperation, M} where {var\"#s21\", M<:ManifoldsBase.AbstractManifold{var\"#s21\"}}), Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.lie_bracket","text":"lie_bracket!(ùî§::LieAlgebra{ùîΩ,AdditionGroupOperation}, X, Y)\nlie_bracket!(ùî§::LieAlgebra{ùîΩ,AdditionGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the AdditionGroupOperation simplifies to the corresponding zero_vector. The computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Manifolds.compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any}} where ùîΩ","page":"Group operation","title":"Manifolds.compose","text":"compose(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, h)\ncompose!(G::LieGroup{ùîΩ,AdditionGroupOperation}, k, g, h)\n\nCompute the group operation composition of g and h with respect to the AdditionGroupOperation on G, which falls back to calling g+h, where + is assumed to be overloaded accordingly.\n\nThis can be computed in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Manifolds.identity_element-Union{Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Tuple{ùîΩ}} where ùîΩ","page":"Group operation","title":"Manifolds.identity_element","text":"identity_element(G::LieGroup{ùîΩ,AdditionGroupOperation})\nidentity_element!(G::LieGroup{ùîΩ,AdditionGroupOperation}, e)\n\nReturn the a point representation of the Identity, which for the AdditionGroupOperation is the zero element or array.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.exp!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any}} where ùîΩ","page":"Group operation","title":"ManifoldsBase.exp!","text":"exp(G::LieGroup{ùîΩ,AdditionGroupOperation}, X)\nexp!(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, X)\n\nCompute the Lie group exponential on a LieGroup with an AdditionGroupOperation. This can be computed in-place of g.\n\nSince e is just the zero-element with respect to the corresponding +, the formula reads g=0+X=X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.log!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any}} where ùîΩ","page":"Group operation","title":"ManifoldsBase.log!","text":"log(G::LieGroup{ùîΩ,AdditionGroupOperation}, g)\nlog!(G::LieGroup{ùîΩ,AdditionGroupOperation}, X, g)\n\nCompute the Lie group logarithm on a LieGroup with an AdditionGroupOperation. This can be computed in-place of X.\n\nSince e is just the zero-element with respect to the corresponding +, the formula reads X=g-0=g.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#multiplication-operation-sec","page":"Group operation","title":"Multiplication group operation","text":"","category":"section"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"Modules = [LieGroups]\nPages = [\"multiplication_operation.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"interface/operations/#LieGroups.AbstractMultiplicationGroupOperation","page":"Group operation","title":"LieGroups.AbstractMultiplicationGroupOperation","text":"AbstractMultiplicationGroupOperation <: AbstractGroupOperation\n\nA group operation that is realised introducing defaults that fall back to * being overloaded, for example _compose(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, a, b) = a * b\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#LieGroups.MatrixMultiplicationGroupOperation","page":"Group operation","title":"LieGroups.MatrixMultiplicationGroupOperation","text":"MatrixMultiplicationGroupOperation <: AbstractMultiplicationGroupOperation\n\nA group operation that is realised by a matrix multiplication.\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#Base.exp-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s21\", M} where {var\"#s21\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any}} where ùîΩ","page":"Group operation","title":"Base.exp","text":"exp(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, X)\nexp!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, X)\n\nCompute the Lie group exponential on a LieGroup with an AbstractMultiplicationGroupOperation, which simplifies to the matrix exponential.\n\nThis can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.inv-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s21\", M} where {var\"#s21\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any}} where ùîΩ","page":"Group operation","title":"Base.inv","text":"inv(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g)\ninv!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for an AbstractMultiplicationGroupOperation simplifies to the multiplicative inverse g^-1. This can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.log-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s21\", M} where {var\"#s21\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any}} where ùîΩ","page":"Group operation","title":"Base.log","text":"log(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g)\nlog!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, X, g)\n\nCompute the Lie group logarithm on a LieGroup with a concrete instance of AbstractMultiplicationGroupOperation, which simplifies to the (matrix) logarithm.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.compose!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s21\", M} where {var\"#s21\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.compose!","text":"compose(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, h)\ncompose!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, k, g, h)\n\nCompute the group operation composition of g and h with respect to an AbstractMultiplicationGroupOperation on an LieGroup G, which falls back to calling g*h, where * is assumed to be overloaded accordingly.\n\nThis can be computed in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Vararg{Any, 4}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_conjugate!","text":"diff_conjugate(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1 = ghg^-1, which simplifies for an AbstractMultiplicationGroupOperation to D(c_g(h))X = gXg^-1.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s21\", M} where {var\"#s21\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_conjugate","text":"diff_conjugate(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1 = ghg^-1, which simplifies for an AbstractMultiplicationGroupOperation to D(c_g(h))X = gXg^-1.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_inv!","text":"diff_inv(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, g, X)\n\nCompute the value of differential DŒπ_mathcal G(g)X of matrix inversion Œπ_mathcal G(g) = g^-1 at X  ùî§ in the LieAlgebra ùî§ of the LieGroup G.\n\nThe formula is given by\n\nDŒπ_mathcal G(g)X = -g^mathrmTXg^-1\n\nwhich stems from using the differential of the inverse from [Gil08] given by D(g^-1)X = -g^-1Xg^-1 composed with the push forward of the left composition DŒª_mathrme(g)X = gX mapping from the Liea algebra into the tangent space at g, and its adjoint D^*Œª_mathrme(g)X = g^mathrmTX. Then we get g^mathrmT(g^-1(gX)g^-1) which simplifies to -g^mathrmTXg^-1 from above.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Number}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_inv","text":"diff_inv(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, g, X)\n\nCompute the value of differential DŒπ_mathcal G(g)X of matrix inversion Œπ_mathcal G(g) = g^-1 at X  ùî§ in the LieAlgebra ùî§ of the LieGroup G.\n\nThe formula is given by\n\nDŒπ_mathcal G(g)X = -g^mathrmTXg^-1\n\nwhich stems from using the differential of the inverse from [Gil08] given by D(g^-1)X = -g^-1Xg^-1 composed with the push forward of the left composition DŒª_mathrme(g)X = gX mapping from the Liea algebra into the tangent space at g, and its adjoint D^*Œª_mathrme(g)X = g^mathrmTX. Then we get g^mathrmT(g^-1(gX)g^-1) which simplifies to -g^mathrmTXg^-1 from above.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Vararg{Any, 4}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_left_compose!","text":"diff_left_compose(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh, which simplifies for an AbstractMultiplicationGroupOperation to DŒª_g(h)X = gX.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s21\", M} where {var\"#s21\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_left_compose","text":"diff_left_compose(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh, which simplifies for an AbstractMultiplicationGroupOperation to DŒª_g(h)X = gX.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Vararg{Any, 4}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_right_compose!","text":"diff_right_compose(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, h, g, X)\ndiff_right_compose!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, h, g, X)\n\nCompute the differential of the right group multiplication œÅ_g(h) = hg, which simplifies for an AbstractMultiplicationGroupOperation to DœÅ_g(h)X = Xg.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s21\", M} where {var\"#s21\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_right_compose","text":"diff_right_compose(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, h, g, X)\ndiff_right_compose!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, h, g, X)\n\nCompute the differential of the right group multiplication œÅ_g(h) = hg, which simplifies for an AbstractMultiplicationGroupOperation to DœÅ_g(h)X = Xg.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.identity_element!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s21\", M} where {var\"#s21\"<:MatrixMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.identity_element!","text":"identity_element(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation})\nidentity_element!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, e)\n\nReturn the a point representation of the Identity, which for an AbstractMultiplicationGroupOperation is the one-element or identity array.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.inv!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.inv!","text":"inv(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g)\ninv!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for an AbstractMultiplicationGroupOperation simplifies to the multiplicative inverse g^-1. This can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket!-Union{Tuple{O}, Tuple{ùîΩ}, Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, <:LieGroup{ùîΩ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Identity{O}}, Any, Any, Any}} where {ùîΩ, O<:MatrixMultiplicationGroupOperation}","page":"Group operation","title":"LieGroups.lie_bracket!","text":"lie_bracket(::LieAlgebra{ùîΩ,MatrixMultiplicationGroupOperation}, X, Y)\nlie_bracket!(::LieAlgebra{ùîΩ,MatrixMultiplicationGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the MatrixMultiplicationGroupOperation yields the commutator bracket\n\nX Y = XY-YX\n\nThe computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket-Union{Tuple{ùîΩ}, Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{MatrixMultiplicationGroupOperation}} where G<:(AbstractLieGroup{var\"#s21\", MatrixMultiplicationGroupOperation, M} where {var\"#s21\", M<:ManifoldsBase.AbstractManifold{var\"#s21\"}}), Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.lie_bracket","text":"lie_bracket(::LieAlgebra{ùîΩ,MatrixMultiplicationGroupOperation}, X, Y)\nlie_bracket!(::LieAlgebra{ùîΩ,MatrixMultiplicationGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the MatrixMultiplicationGroupOperation yields the commutator bracket\n\nX Y = XY-YX\n\nThe computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Manifolds.compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s21\", M} where {var\"#s21\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any}} where ùîΩ","page":"Group operation","title":"Manifolds.compose","text":"compose(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, h)\ncompose!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, k, g, h)\n\nCompute the group operation composition of g and h with respect to an AbstractMultiplicationGroupOperation on an LieGroup G, which falls back to calling g*h, where * is assumed to be overloaded accordingly.\n\nThis can be computed in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Manifolds.identity_element-Union{Tuple{LieGroup{ùîΩ, var\"#s21\", M} where {var\"#s21\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}}, Tuple{ùîΩ}} where ùîΩ","page":"Group operation","title":"Manifolds.identity_element","text":"identity_element(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation})\nidentity_element!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, e)\n\nReturn the a point representation of the Identity, which for an AbstractMultiplicationGroupOperation is the one-element or identity array.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.exp!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any}} where ùîΩ","page":"Group operation","title":"ManifoldsBase.exp!","text":"exp(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, X)\nexp!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, X)\n\nCompute the Lie group exponential on a LieGroup with an AbstractMultiplicationGroupOperation, which simplifies to the matrix exponential.\n\nThis can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.log!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s20\", M} where {var\"#s20\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any}} where ùîΩ","page":"Group operation","title":"ManifoldsBase.log!","text":"log(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g)\nlog!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, X, g)\n\nCompute the Lie group logarithm on a LieGroup with a concrete instance of AbstractMultiplicationGroupOperation, which simplifies to the (matrix) logarithm.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#multiplication-operationabelian-sec","page":"Group operation","title":"Abelian multiplication group operation","text":"","category":"section"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"Since the commutativity of some Lie groups leads to a significant simplification of computations on those groups, the abelian multiplication group operation optimizes these cases. Additionally, it provides an interface for the abelian Lie groups. Some of these can are represented by isbits-types, which don't have mutating variants of the functions.","category":"page"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"Modules = [LieGroups]\nPages = [\"multiplication_operation_abelian.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"interface/operations/#LieGroups.AbelianMultiplicationGroupOperation","page":"Group operation","title":"LieGroups.AbelianMultiplicationGroupOperation","text":"AbelianMultiplicationGroupOperation <: AbstractMultiplicationGroupOperation\n\nA group operation that is realised by an abelian multiplication.\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#Base.exp-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AbelianMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, AbstractArray{<:Any, 0}}} where ùîΩ","page":"Group operation","title":"Base.exp","text":"exp(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, X)\nexp(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, g, X)\nexp!(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, h, X)\nexp!(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, h, g, X)\n\nCompute the Lie group exponential on a LieGroup at a point g or the Identity with an AbelianMultiplicationGroupOperation.\n\nDue to differences in the representation of some abelian Lie groups, this method wraps a concrete implementation of a specific abelian LieGroup with inputs of type AbstractArray{<:Any,0} and supports in-place computation.\n\nThis can be computed in-place of h if h is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.inv-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s76\", M} where {var\"#s76\"<:AbelianMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Number}} where ùîΩ","page":"Group operation","title":"Base.inv","text":"inv(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g)\ninv!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for the AbelianMultiplicationGroupOperation simplifies for a scalar input to the ordinary scalar inverse g^-1.\n\nDue to differences in the representation of some abelian Lie groups, this method wraps a concrete implementation of a specific abelian LieGroup with inputs of type AbstractArray{<:Any,0} and supports in-place computation.\n\nThis can be computed in-place of h if h is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.log-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AbelianMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any}} where ùîΩ","page":"Group operation","title":"Base.log","text":"log(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, h)\nlog(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, g, h)\nlog!(G::LieGroup{ùîΩ,<:AbeliantMultiplicationGroupOperation}, X, g)\nlog!(G::LieGroup{ùîΩ,<:AbeliantMultiplicationGroupOperation}, X, g, h)\n\nCompute the Lie group logarithm on a LieGroup at a point g or the Identity with a concrete instance of AbelianMultiplicationGroupOperation.\n\nDue to differences in the representation of some abelian Lie groups, this method wraps a concrete implementation of a specific abelian LieGroup with inputs of type AbstractArray{<:Any,0} and supports in-place computation.\n\nThis can be computed in-place of X if X is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s8\", M} where {var\"#s8\"<:AbelianMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, AbstractArray{<:Any, 0}, AbstractArray{<:Any, 0}, AbstractArray{<:Any, 0}, AbstractArray{<:Any, 0}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_conjugate!","text":"diff_conjugate(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1 = ghg^-1, which simplifies for an AbelianMultiplicationGroupOperation to D(c_g(h))X = X.\n\nThis can be computed in-place of Y if Y is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s20\", M} where {var\"#s20\"<:AbelianMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any, Number}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_conjugate","text":"diff_conjugate(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1 = ghg^-1, which simplifies for an AbelianMultiplicationGroupOperation to D(c_g(h))X = X.\n\nThis can be computed in-place of Y if Y is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s76\", M} where {var\"#s76\"<:AbelianMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_inv!","text":"diff_inv(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, Y, g, X)\n\nCompute the value of the differential DŒπ_mathcal G(g)X of the inversion Œπ_mathcal G(g) = g^-1 at X  ùî§ in the LieAlgebra ùî§ of the LieGroup G.\n\nIn the abelian case, the computation simplifies to\n\nDŒπ_mathcal G(g)X = -gXg^-1 = -X\n\nThis can be computed in-place of Y if Y is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s76\", M} where {var\"#s76\"<:AbelianMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Vararg{Any, 4}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_left_compose!","text":"diff_left_compose(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh.\n\nDue to differences in the representation of some abelian Lie groups, this method wraps a concrete implementation of a specific abelian LieGroup with inputs of type AbstractArray{<:Any,0} and supports in-place computation.\n\nThis can be computed in-place of Y if Y is mutable.    \n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s20\", M} where {var\"#s20\"<:AbelianMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, AbstractArray{<:Any, 0}, Any, AbstractArray{<:Any, 0}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_left_compose","text":"diff_left_compose(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh.\n\nDue to differences in the representation of some abelian Lie groups, this method wraps a concrete implementation of a specific abelian LieGroup with inputs of type AbstractArray{<:Any,0} and supports in-place computation.\n\nThis can be computed in-place of Y if Y is mutable.    \n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s76\", M} where {var\"#s76\"<:AbelianMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Vararg{Any, 4}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_right_compose!","text":"diff_right_compose(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, g, h, X)\ndiff_right_compose!(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the right group multiplication œÅ_g(h) = hg.\n\nDue to differences in the representation of some abelian Lie groups, this method wraps a concrete implementation of a specific abelian LieGroup with inputs of type AbstractArray{<:Any,0} and supports in-place computation.\n\nThis can be computed in-place of Y if Y is mutable.    \n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s20\", M} where {var\"#s20\"<:AbelianMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, AbstractArray{<:Any, 0}, Any, AbstractArray{<:Any, 0}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_right_compose","text":"diff_right_compose(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, g, h, X)\ndiff_right_compose!(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the right group multiplication œÅ_g(h) = hg.\n\nDue to differences in the representation of some abelian Lie groups, this method wraps a concrete implementation of a specific abelian LieGroup with inputs of type AbstractArray{<:Any,0} and supports in-place computation.\n\nThis can be computed in-place of Y if Y is mutable.    \n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.identity_element!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AbelianMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.identity_element!","text":"identity_element(G::LieGroup{ùîΩ,AbelianMultiplicationGroupOperation})\nidentity_element!(G::LieGroup{ùîΩ,AbelianMultiplicationGroupOperation}, e)\n\nReturn the point representation of the Identity, which for an AbelianMultiplicationGroupOperation is the one-element.\n\nThis can be computed in e if e is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.inv!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s76\", M} where {var\"#s76\"<:AbelianMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.inv!","text":"inv(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g)\ninv!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for the AbelianMultiplicationGroupOperation simplifies for a scalar input to the ordinary scalar inverse g^-1.\n\nDue to differences in the representation of some abelian Lie groups, this method wraps a concrete implementation of a specific abelian LieGroup with inputs of type AbstractArray{<:Any,0} and supports in-place computation.\n\nThis can be computed in-place of h if h is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket!-Union{Tuple{O}, Tuple{ùîæ}, Tuple{ùîΩ}, Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, <:LieGroup{ùîæ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîæ}, Identity{O}}, Any, Any, Any}} where {ùîΩ, ùîæ, O<:AbelianMultiplicationGroupOperation}","page":"Group operation","title":"LieGroups.lie_bracket!","text":"lie_bracket(::LieAlgebra{ùîΩ,AbelianMultiplicationGroupOperation}, X, Y)\nlie_bracket!(::LieAlgebra{ùîΩ,AbelianMultiplicationGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the AbelianMultiplicationGroupOperation yields the zero vector of the LieAlgebra due to commutativity. \n\nX Y = XY-YX = 0\n\nThe computation can be done in-place of Z if Z is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket-Union{Tuple{O}, Tuple{ùîæ}, Tuple{ùîΩ}, Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, <:LieGroup{ùîæ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîæ}, Identity{O}}, Number, Number}} where {ùîΩ, ùîæ, O<:AbelianMultiplicationGroupOperation}","page":"Group operation","title":"LieGroups.lie_bracket","text":"lie_bracket(::LieAlgebra{ùîΩ,AbelianMultiplicationGroupOperation}, X, Y)\nlie_bracket!(::LieAlgebra{ùîΩ,AbelianMultiplicationGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the AbelianMultiplicationGroupOperation yields the zero vector of the LieAlgebra due to commutativity. \n\nX Y = XY-YX = 0\n\nThe computation can be done in-place of Z if Z is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Manifolds.identity_element-Union{Tuple{T}, Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AbelianMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Type{T}}} where {ùîΩ, T<:Union{Number, AbstractArray{0, <:Number}}}","page":"Group operation","title":"Manifolds.identity_element","text":"identity_element(G::LieGroup{ùîΩ,AbelianMultiplicationGroupOperation})\nidentity_element!(G::LieGroup{ùîΩ,AbelianMultiplicationGroupOperation}, e)\n\nReturn the point representation of the Identity, which for an AbelianMultiplicationGroupOperation is the one-element.\n\nThis can be computed in e if e is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.exp!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AbelianMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any}} where ùîΩ","page":"Group operation","title":"ManifoldsBase.exp!","text":"exp(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, X)\nexp(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, g, X)\nexp!(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, h, X)\nexp!(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, h, g, X)\n\nCompute the Lie group exponential on a LieGroup at a point g or the Identity with an AbelianMultiplicationGroupOperation.\n\nDue to differences in the representation of some abelian Lie groups, this method wraps a concrete implementation of a specific abelian LieGroup with inputs of type AbstractArray{<:Any,0} and supports in-place computation.\n\nThis can be computed in-place of h if h is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.log!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AbelianMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any}} where ùîΩ","page":"Group operation","title":"ManifoldsBase.log!","text":"log(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, h)\nlog(G::LieGroup{ùîΩ,<:AbelianMultiplicationGroupOperation}, g, h)\nlog!(G::LieGroup{ùîΩ,<:AbeliantMultiplicationGroupOperation}, X, g)\nlog!(G::LieGroup{ùîΩ,<:AbeliantMultiplicationGroupOperation}, X, g, h)\n\nCompute the Lie group logarithm on a LieGroup at a point g or the Identity with a concrete instance of AbelianMultiplicationGroupOperation.\n\nDue to differences in the representation of some abelian Lie groups, this method wraps a concrete implementation of a specific abelian LieGroup with inputs of type AbstractArray{<:Any,0} and supports in-place computation.\n\nThis can be computed in-place of X if X is mutable.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Literature","page":"Group operation","title":"Literature","text":"","category":"section"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"M.¬†B.¬†Giles. Collected Matrix Derivative Results for Forward and Reverse Mode Algorithmic Differentiation. In: Advances in Automatic Differentiation, Lecture Notes in Computational Science and Engineering, edited by C.¬†H.¬†Bischof, H.¬†M.¬†B√ºcker, P.¬†Hovland, U.¬†Naumann and J.¬†Utke (Springer, Berlin, Heidelberg, 2008); pp.¬†35‚Äì44.\n\n\n\n","category":"page"},{"location":"about/#About-LieGroups.jl","page":"About","title":"About LieGroups.jl","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"The package LieGroups.jl in its current form started in 2024 as a ‚Äúspin-off‚Äù from Manifolds.jl, where a type GroupManifolds was a predecessor of the main LieGroup type of this package. That approach started around 2021 by Seth Axen. At about the same, Yueh-Hua Tu started a package LieGroups.jl, which was continued then here with a full rewrite in order to base all Lie groups on a manifold from Manifolds.jl.","category":"page"},{"location":"about/","page":"About","title":"About","text":"The current main developers are Ronny Bergmann and Mateusz Baran.","category":"page"},{"location":"about/#Contributors","page":"About","title":"Contributors","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"Thanks to the following contributors to LieGroups.jl:","category":"page"},{"location":"about/","page":"About","title":"About","text":"Paula Conrad and Leonard Schreiter implemented the Circle group as part of their student assistant project.\nOlivier Verdier helped in the design and some mathematical explanations","category":"page"},{"location":"about/","page":"About","title":"About","text":"as well as contributors providing small extensions, finding small bugs and mistakes and fixing them by opening PRs. Thanks to all of you.","category":"page"},{"location":"about/","page":"About","title":"About","text":"If you want to contribute a manifold or algorithm or have any questions, visit the GitHub repository to clone/fork the repository or open an issue.","category":"page"},{"location":"about/#Work-using-LieGroups.jl","page":"About","title":"Work using LieGroups.jl","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"If LieGroups.jl is useful within another package or in your project, we would like to list that here. Please open an issue. It would be great to collect anything and anyone using LieGroups.jl in this list.","category":"page"},{"location":"interface/actions/#An-Interface-for-Lie-group-actions","page":"Group action","title":"An Interface for Lie group actions","text":"","category":"section"},{"location":"interface/actions/","page":"Group action","title":"Group action","text":"Modules = [LieGroups]\nPages = [\"group_action_interface.jl\"]\nOrder = [:type]","category":"page"},{"location":"interface/actions/#LieGroups.AbstractGroupActionType","page":"Group action","title":"LieGroups.AbstractGroupActionType","text":"AbstractGroupActionType\n\nAn abstract supertype for group action types, which are used within a GroupAction.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.AbstractLeftGroupActionType","page":"Group action","title":"LieGroups.AbstractLeftGroupActionType","text":"AbstractLeftGroupActionType <: AbstractGroupActionType\n\nA type representing a (smooth) group action œÉ mathcal G  mathcal M  mathcal M of a AbstractLieGroup mathcal G acting (from the left) on an AbstractManifold mathcal M. with the following properties\n\nœÉ(mathrme p) = p holds for all p  mathcal M\nœÉ(g œÉ(h p)) = œÉ(gh p) holds for all gh  mathcal G, p  mathcal M\n\nwhere  denotes the group operation of the AbstractLieGroup mathcal G. See also [HN12, Definition 9.1.11].\n\nThe type of action can be seen a bit better when writing the action as a family œÉ_g(p): we obtain from the second property as\n\n  œÉ_g(œÉ_h(p)) = œÉ_gh(p)\n\nand see that g appears on the left.\n\nTo emphasize the side the group operation is acting from, we sometimes write œÉ^mathrmL. If the action is clear from context we write œÉ(g p) = g  p.\n\nOne notable example of a left action is the inverse of an action of AbstractRightGroupActionType œÉ^mathrmR, which is given by œÑ_g = (œÉ^mathrmR_g)^-1 = œÉ^mathrmR_g^-1. We obtain\n\nœÑ_g(œÑ_h(p))\n= œÉ^mathrmR_g^-1(œÉ^mathrmR_h^-1(p))\n= œÉ^mathrmR_h^-1g^-1(p)\n= œÉ^mathrmR_(gh)^-1(p)\nœÑ_gh(p)\n\nnote: Note\nIn function definitions we follow the idea of the family of actions and use the order (M, g, p) in function signatures.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.AbstractRightGroupActionType","page":"Group action","title":"LieGroups.AbstractRightGroupActionType","text":"AbstractRightGroupActionType <: AbstractGroupActionType\n\nA type representing a (smooth) group action œÉ mathcal M  mathcal G  mathcal M of a AbstractLieGroup mathcal G acting (from the right) on an AbstractManifold mathcal M. with the following properties\n\nœÉ(p mathrme) = p holds for all p  mathcal M\nœÉ(œÉ(p g) h) = œÉ(p gh) holds for all gh  mathcal G, p  mathcal M\n\nwhere  denotes the group operation of the AbstractLieGroup mathcal G. See also [HN12, Remark 9.1.12].\n\nThe type of action can be seen a bit better when writing the action as a family œÉ_g(p): we obtain from the second property as\n\n  œÉ_g(œÉ_h(p)) = œÉ_hg(p)\n\nand see that g appears on the right.\n\nTo emphasize the side the group operation is acting from, we sometimes write œÉ^mathrmR. If the action is clear from context we write œÉ(p g) = p  g.\n\nOne notable example of a right action is the inverse of an action of  AbstractLeftGroupActionType œÉ^mathrmL, which is given by œÑ_g = (œÉ^mathrmL_g)^-1 = œÉ^mathrmL_g^-1. We obtain\n\nœÑ_g(œÑ_h(p))\n= œÉ^mathrmL_g^-1(œÉ^mathrmL_h^-1(p))\n= œÉ^mathrmL_g^-1h^-1(p)\n= œÉ^mathrmL_(hg)^-1(p)\nœÑ_hg(p)\n\nnote: Note\nIn function definitions we follow the idea of the family of actions and use the order (M, g, p) in function signatures.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.GroupAction","page":"Group action","title":"LieGroups.GroupAction","text":"GroupAction{T<:GroupActionType, L<:LieGroup, M<:AbstractManifold}\n\nSpecify a group action of AbstractGroupActionType T of a AbstractLieGroup G acting on M.\n\nLet mathcal M be a AbstractManifold and mathcal G be a AbstractLieGroup with group operation .\n\nA (smooth) action of the group mathcal G on the manifold mathcal M is a map\n\nœÉ mathcal G  mathcal M  mathcal M\n\nwith the properties\n\nœÉ(mathrme p) = p holds for all p  mathcal M\nœÉ(g œÉ(h p)) = œÉ(gh p) holds for all gh  mathcal G, p  mathcal M\n\nFields\n\ntype::T: The type of the group action.\ngroup::L: The group acting.\nmanifold::M: The manifold the group acts upon.\n\nSee [HN12, Section 9.1.3] for more details.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#Functions-for-Lie-group-actions","page":"Group action","title":"Functions for Lie group actions","text":"","category":"section"},{"location":"interface/actions/","page":"Group action","title":"Group action","text":"Modules = [LieGroups]\nPages = [\"group_action_interface.jl\"]\nOrder = [:function]","category":"page"},{"location":"interface/actions/#Base.inv-Tuple{AbstractGroupActionType}","page":"Group action","title":"Base.inv","text":"inv(::AbstractGroupActionType)\n\nreturn the inverse group operation action, that is, use the type representing the inverse operation.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Base.inv-Tuple{GroupAction}","page":"Group action","title":"Base.inv","text":" inv(A::GroupAction{T})\n\nReturn the GroupAction representing the inverse of an GroupAction of AbstractGroupActionType T. This is usually done by returning the group action with the inverse type of T.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.base_lie_group-Tuple{GroupAction}","page":"Group action","title":"LieGroups.base_lie_group","text":"base_lie_group(A::GroupAction)\n\nReturn the AbstractLieGroup of the GroupAction specifying the action.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.default_left_action-Tuple{AbstractLieGroup, ManifoldsBase.AbstractManifold}","page":"Group action","title":"LieGroups.default_left_action","text":"default_left_action(G::AbstractLieGroup, M::AbstractManifold)\n\nReturn the default left action for a Lie group G acting on a manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.default_right_action-Tuple{AbstractLieGroup, ManifoldsBase.AbstractManifold}","page":"Group action","title":"LieGroups.default_right_action","text":"default_right_action(G::AbstractLieGroup, M::AbstractManifold)\n\nReturn the default right action for a Lie group G acting on a manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.diff_apply!-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"LieGroups.diff_apply!","text":"diff_apply(A::GroupAction{T, L, M}, g, p, X)\ndiff_apply!(A::GroupAction{T, L, M}, Y, g, p, X)\n\nCompute the differential D_p œÉ_g(p) T_pmathcal M  T_œÉ_g(p)mathcal M, where for a left group action we have œÉ_g(p) = œÉ(gp), for a right action œÉ_g(p) = œÉ(p g).\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.diff_apply-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"LieGroups.diff_apply","text":"diff_apply(A::GroupAction{T, L, M}, g, p, X)\ndiff_apply!(A::GroupAction{T, L, M}, Y, g, p, X)\n\nCompute the differential D_p œÉ_g(p) T_pmathcal M  T_œÉ_g(p)mathcal M, where for a left group action we have œÉ_g(p) = œÉ(gp), for a right action œÉ_g(p) = œÉ(p g).\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.diff_group_apply!-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"LieGroups.diff_group_apply!","text":"diff_group_apply(A::GroupAction{T, L, M}, g, p, X)\ndiff_group_apply!(A::GroupAction{T, L, M}, Y, g, p, X)\n\nCompute the differential D_g œÉ_g(p) mathfrak g  mathfrak g, where we use the short hand notation œÉ_p(g) = œÉ(gp) for a left action, and for a right action œÉ_p(g) = œÉ(p g).\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.diff_group_apply-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"LieGroups.diff_group_apply","text":"diff_group_apply(A::GroupAction{T, L, M}, g, p, X)\ndiff_group_apply!(A::GroupAction{T, L, M}, Y, g, p, X)\n\nCompute the differential D_g œÉ_g(p) mathfrak g  mathfrak g, where we use the short hand notation œÉ_p(g) = œÉ(gp) for a left action, and for a right action œÉ_p(g) = œÉ(p g).\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{AbstractGroupActionType}","page":"Group action","title":"LieGroups.switch","text":"switch(T::AbstractGroupActionType)\n\nReturn the object representing an AbstractGroupActionType related to a group operation action that switched the side, that is it turns a left action type into its corresponding right action type.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{GroupAction}","page":"Group action","title":"LieGroups.switch","text":" switch(A::GroupAction{T})\n\nReturn the group operation action representing the similar GroupAction of AbstractGroupActionType T but acting from the other side. It switches left to right and vice versa. This is done by returning the group action with the ‚Äúswitched‚Äù type of T.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Manifolds.apply!-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"Manifolds.apply!","text":"apply(A::GroupAction{T, L, M}, g, p)\napply!(A::GroupAction{T, L, M}, q, g, p)\n\nApply the group action induced by g  mathcal G to p  mathcal M, where the kind of group action is indicated by the AbstractGroupActionType T. This can be performed in-place of q.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Manifolds.apply-Tuple{GroupAction, Any, Any}","page":"Group action","title":"Manifolds.apply","text":"apply(A::GroupAction{T, L, M}, g, p)\napply!(A::GroupAction{T, L, M}, q, g, p)\n\nApply the group action induced by g  mathcal G to p  mathcal M, where the kind of group action is indicated by the AbstractGroupActionType T. This can be performed in-place of q.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#ManifoldsBase.base_manifold-Tuple{GroupAction}","page":"Group action","title":"ManifoldsBase.base_manifold","text":"base_manifold(A::GroupAction)\n\nReturn the AbstractManifold the group action acts upon.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Generic-Lie-group-actions","page":"Group action","title":"Generic Lie group actions","text":"","category":"section"},{"location":"interface/actions/","page":"Group action","title":"Group action","text":"Modules = [LieGroups]\nPages = [\"group_operation_action.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"interface/actions/#LieGroups.InverseLeftGroupOperationAction","page":"Group action","title":"LieGroups.InverseLeftGroupOperationAction","text":"InverseLeftGroupOperationAction <: AbstractRightGroupActionType\n\nA type for the AbstractLeftGroupActionType when acting on the group itself given by the inverse of a LeftGroupOperationAction œÉ_h as\n\nœÑ_h(g) coloneqq œÉ_h^-1(g) = œÉ(h^-1g) = h^-1g\n\nNote that while in naming it is the inverse of the left action, it's properties yield that is is an AbstractRightGroupActionType, since\n\nœÑ_g(œÑ_h(p))\n= œÉ^mathrmL_g^-1(œÉ^mathrmL_h^-1(p))\n= œÉ^mathrmL_g^-1h^-1(p)\n= œÉ^mathrmL_(hg)^-1(p)\nœÑ_hg(p)\n\nfor its inverse (œÉ_h)^-1 see InverseLeftGroupOperationAction.\n\nnote: Note\nSome literature also calls this by itself the right group operation action.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.InverseRightGroupOperationAction","page":"Group action","title":"LieGroups.InverseRightGroupOperationAction","text":"InverseRightGroupOperationAction <: AbstractLeftGroupActionType\n\nA type for the AbstractLeftGroupActionType when acting on the group itself given by the inverse of a RightGroupOperationAction œÉ_h as\n\nœÑ_h(g) coloneqq œÉ_h^-1(g) = œÉ(h^-1g) = gh^-1\n\nNote that while in naming it is the inverse of the right action, it's properties yield that is is an AbstractLeftGroupActionType, since\n\nœÑ_g(œÑ_h(p))\n= œÉ^mathrmR_g^-1(œÉ^mathrmR_h^-1(p))\n= œÉ^mathrmR_h^-1g^-1(p)\n= œÉ^mathrmR_(gh)^-1(p)\nœÑ_gh(p)\n\nfor its inverse (œÉ_h)^-1 see InverseLeftGroupOperationAction.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.LeftGroupOperationAction","page":"Group action","title":"LieGroups.LeftGroupOperationAction","text":"LeftGroupOperationAction <: AbstractLeftGroupActionType\n\nA type for the AbstractLeftGroupActionType when acting on the group itself from the left, that is\n\nœÉ_h(g) = œÉ(hg) = hg\n\nfor its inverse (œÉ_h)^-1 see InverseLeftGroupOperationAction.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.RightGroupOperationAction","page":"Group action","title":"LieGroups.RightGroupOperationAction","text":"RightGroupOperationAction <: AbstractRightGroupActionType\n\nA type for the AbstractLeftGroupActionType when acting on the group itself from the right.\n\nœÉ_h(g) = œÉ(hg) = gh\n\nfor its inverse (œÉ_h)^-1 see InverseRightGroupOperationAction.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#Base.inv-Tuple{InverseLeftGroupOperationAction}","page":"Group action","title":"Base.inv","text":"inv(::InverseLeftGroupOperationAction)\n\nReturn the inverse of the InverseLeftGroupOperationAction, that is the LeftGroupOperationAction.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Base.inv-Tuple{InverseRightGroupOperationAction}","page":"Group action","title":"Base.inv","text":"inv(::InverseRightGroupOperationAction)\n\nReturn the inverse of the InverseRightGroupOperationAction, that is the RightGroupOperationAction.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Base.inv-Tuple{LeftGroupOperationAction}","page":"Group action","title":"Base.inv","text":"inv(::LeftGroupOperationAction)\n\nReturn the inverse of the LeftGroupOperationAction, that is the InverseLeftGroupOperationAction.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Base.inv-Tuple{RightGroupOperationAction}","page":"Group action","title":"Base.inv","text":"inv(::RightGroupOperationAction)\n\nReturn the inverse of the RightGroupOperationAction, that is the InverseRightGroupOperationAction.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.GroupOperationAction-Tuple{AbstractGroupActionType, LieGroup}","page":"Group action","title":"LieGroups.GroupOperationAction","text":"GroupOperationAction(action::AbstractGroupActionType, group::LieGroup)\n\nReturn a GroupAction for an AbstractGroupActionType action representing the group operation as an action of the group on itself.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{InverseLeftGroupOperationAction}","page":"Group action","title":"LieGroups.switch","text":"switch(::InverseLeftGroupOperationAction)\n\nReturn the InverseRightGroupOperationAction, that is, turns œÉ_g = g^-1h into œÑ_g(h) = hg^-1\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{InverseRightGroupOperationAction}","page":"Group action","title":"LieGroups.switch","text":"switch(::InverseRightGroupOperationAction)\n\nReturn the InverseLeftGroupOperationAction, that is, turns œÉ_g = hg^-1 into œÑ_g(h) = g^-1h\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{LeftGroupOperationAction}","page":"Group action","title":"LieGroups.switch","text":"switch(::LeftGroupOperationAction)\n\nReturn the RightGroupOperationAction, that is, turns œÉ_g = gh into œÑ_g(h) = hg\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{RightGroupOperationAction}","page":"Group action","title":"LieGroups.switch","text":"switch(::RightGroupOperationAction)\n\nReturn the LeftGroupOperationAction, that is, turns œÉ_g = hg into œÑ_g(h) = gh\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Literature","page":"Group action","title":"Literature","text":"","category":"section"},{"location":"interface/actions/","page":"Group action","title":"Group action","text":"J.¬†Hilgert and K.-H.¬†Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\n","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"EditURL = \"https://github.com/JuliaManifolds/LieGroups.jl/blob/main/NEWS.md\"","category":"page"},{"location":"news/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"All notable Changes to the Julia package LieGroups.jl will be documented in this file.","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"news/#[0.1.0]-2025-04-22","page":"Changelog","title":"[0.1.0] 2025-04-22","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Everything denoted by ‚Äúformerly‚Äù refers to the previous name in Manifolds.jl. Several structs have been changed from the pre-release, so these are breaking.","category":"page"},{"location":"news/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"LieAlgebra\nLieGroup (formerly GroupManifold) as well as the concrete groups\nTranslationGroup\nSpecialEuclideanGroup (formerly SpecialEuclidean) including\nSpecialEuclideanMatrixPoint and SpecialEuclideanMatrixTangentVector when representing the points as affine (abstract) matrices\nSpecialEuclideanProductPoint and SpecialEuclideanProductTangentVector when representing them in a product structure, that is as an ArrayPartition from RecursiveArrayTools.\nneither of those types is necessary, besides for conversion between both. The product representation differs for the left and right semidirect product, while the affine matrix variant does not.\nSpecialOrthogonalGroup (formerly SpecialOrthogonal)\nSpecialUnitaryGroup (formerly SpecialUnitary)\nOrthogonalGroup (formerly Orthogonal)\nUnitaryGroup (formerly Unitary) also for quaternions.\nGeneralLinearGroup (formerly GeneralLinear)\nHeisenbergGroup\nLeftSemidirectProductLieGroup (formerly SemidirectProductGroup)\n‚ãâ (alias for LeftSemidirectProductGroupOperation when a default_left_action(G,H) is defined for the two groups)\nPowerLieGroup (formerly PowerGroup)\nPowerGroupOperation to internally avoid ambiguities. Since the constructor always expects a Lie group, this is only necessary internally\nProductLieGroup (formerly ProductGroup)\nRightSemidirectProductLieGroup\nSpecialLinearGroup (formerly SpecialLinear)\nSymplecticGroup\nCircleGroup now with even three representations: Real line (mod 2œÄ), Complex and plane circle\n‚ãä (alias for RightSemidirectProductGroupOperation when a default_right_action(G,H) is defined for the two groups)\na ValidationLieGroup verifying input and output of all interface functions, similar to the ValidationManifold which can also be used internally.\nAbstractGroupOperation as well as its concrete subtypes\nAdditionGroupOperation (formerly AdditionOperation)\nMatrixMultiplicationGroupOperation (formerly MultiplicationOperation)\nPowerGroupOperation (formerly the Lie group was stored inside a power manifold)\nProductGroupOperation (formerly the Lie groups were stored inside a product manifold)\nLeftSemidirectProductGroupOperation (this was formerly only implicitly stored in the SemidirectProductGroup)\nRightSemidirectProductGroupOperation\nAbstractGroupActionType with its 2 specific (new) abstract subtypes\nAbstractLeftGroupActionType\nAbstractRightGroupActionType\nFor the group operation actions there are now\nLeftGroupOperationAction (formerly LeftForwardAction)\nRightGroupOperationAction (formerly RightBackwardAction)\nInverseLeftGroupOperationAction (formerly RightForwardAction)\nInverseRightGroupOperationAction (formerly LeftBackwardAction)\nDefaultLieAlgebraOrthogonalBasis (replaces VeeOrthogonalBasis, which is still available in ManifoldsBase.jl)\nAbstractLieGroupPoint and AbstractLieAlgebraTangentVector as abstract types to introduce point and Lie algebra tangent vector representations\nIdentity\napplyand apply!\nbase_manifold to access the manifold within a Lie group\ncompose and compose!\nconjugate and conjugate!\ndiff_apply, diff_apply!, diff_group_apply, and diff_group_apply! (formerly apply_diff_[group][!])\ndiff_conjugate and diff_conjugate!\ndiff_left_compose, diff_left_compose!, diff_right_compose, diff_right_compose! (formerly translate_diff with different sides)\nexp(G::LieGroup, g, X) and exp!(G::LieGroup, h, g, X) (formerly exp_inv and exp_inv!)\nexp(G::LieGroup, X) and exp!(G::LieGroup, h, X) (formerly exp_lie and exp_lie!)\nhat and hat!, with slightly different signatures, since the base point is omitted.\nidentity_element and identity_element!\ninv and inv! (inv(::AbstractGroupAction) was formerly switch_direction)\ninv_left_compose, inv_left_compose! and inv_right_compose, inv_right_compose! (these functions correspond to inverse_translate with corresponding direction and side)\nis_identity\nlie_bracket and lie_bracket!\njacobian_conjugate (formerly adjoint_matrix, which is now a special case of this)\nlog(G::LieGroup, g, h) and log!(G::LieGroup, X, g, h) (formerly log_inv and log_inv!)\nlog(G::LieGroup, ::Identity, g) and log!(G::LieGroup, X, ::Identity, g) (formerly log_lie and log_lie!)\nswitch (formerly switch_side)\nvee and vee!, with slightly different signatures, since the base point is omitted.","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Compared to Manifolds.jl","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"all translate functions are not implemented here, since you can just use compose. The differentials are implemented as listed above with respect to both left and right argument of compose\nall inverse_apply functions are not implemented here, since it is recommended to use apply(inv(A), g, p) as a replacement.","category":"page"},{"location":"news/#[0.0.3]-‚Äì-2025-02-19","page":"Changelog","title":"[0.0.3] ‚Äì 2025-02-19","text":"","category":"section"},{"location":"news/#Added-2","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Finishes most of the work on the interface for the LieGroup type and the new LieAlgebra type.\nFinishes a generic implementation of a SemiDirectProductGroupOperation\nAll details will be detailed in the next release","category":"page"},{"location":"news/#Old-Changelog-pre-0.0.3","page":"Changelog","title":"Old Changelog pre 0.0.3","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Two previous releases where done by Yueh-Hua Tu in 2022 before he was so kind to transfer the development to the JuliaManifolds GitHub organisation.","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"All notable changes to this project will be documented in this file.","category":"page"},{"location":"news/#[0.0.2]","page":"Changelog","title":"[0.0.2]","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"fix SE{3} and add jacobian\ndefine dof and dim for Lie algebra and jacobian of inv\nadd action for SE{N}\nadd se3_location example","category":"page"},{"location":"interface/group/#An-interface-for-Lie-groups","page":"Lie group","title":"An interface for Lie groups","text":"","category":"section"},{"location":"interface/group/","page":"Lie group","title":"Lie group","text":"AbstractLieGroup\nLieGroup\nAbstractLieAlgebraTangentVector\nAbstractLieGroupPoint","category":"page"},{"location":"interface/group/#LieGroups.AbstractLieGroup","page":"Lie group","title":"LieGroups.AbstractLieGroup","text":"AbstractLieGroup{ùîΩ, O<:AbstractGroupOperation, M<:AbstractManifold{ùîΩ}} <: AbstractManifold{ùîΩ}\n\nAn abstract type to represent Lie groups. For most cases it should suffice to ‚Äúcombine‚Äù an AbstractManifold with an AbstractGroupOperation, see LieGroup.\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#LieGroups.LieGroup","page":"Lie group","title":"LieGroups.LieGroup","text":"LieGroup{ùîΩ, O<:AbstractGroupOperation, M<:AbstractManifold{ùîΩ}} <:  AbstractLieGroup{ùîΩ, O, M}\n\nRepresent a Lie Group mathcal G.\n\nA Lie Group mathcal G is a group endowed with the structure of a manifold such that the group operations  mathcal Gmathcal G  mathcal G, see compose and the inverse operation ^-1 mathcal G  mathcal G, see inv are smooth, see for example [HN12, Definition 9.1.1].\n\nLie groups are named after the Norwegian mathematician Marius Sophus Lie (1842‚Äì1899).\n\nFields\n\nmanifold: an AbstractManifold mathcal M\nop: an AbstractGroupOperation  on that manifold\n\nConstructor\n\nLieGroup(M::AbstractManifold, op::AbstractGroupOperation)\n\nGenerate a Lie group based on a manifold M and a group operation op, where vectors by default are stored in the Lie Algebra.\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#LieGroups.AbstractLieAlgebraTangentVector","page":"Lie group","title":"LieGroups.AbstractLieAlgebraTangentVector","text":"AbstractLieAlgebraTangentVector <: ManifoldsBase.AbstractTangentVector\n\nAn abstract type for a tangent vector represented in a LieAlgebra.\n\nWhile an tangent vectors are usually kept untyped for flexibility, it might be necessary to distinguish different types of points, for example\n\nfor complicated representations that require a struct\n\n@ semantic verification\n\nwhen there exist different representations\n\nBy sub-typing the AbstractManifoldPoint, this follows the same idea as in ManifoldsBase.jl.\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#LieGroups.AbstractLieGroupPoint","page":"Lie group","title":"LieGroups.AbstractLieGroupPoint","text":"AbstractLieGroupPoint <: ManifoldsBase.AbstractManifoldPoint end\n\nAn abstract type for a point on an AbstractLieGroup. While an points and tangent vectors are usually kept untyped for flexibility, it might be necessary to distinguish different types of points, for example\n\nfor complicated representations that require a struct\nsemantic verification\nwhen there exist different representations\n\nBy sub-typing the AbstractManifoldPoint, this follows the same idea as in ManifoldsBase.jl.\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#Functions-on-Lie-groups","page":"Lie group","title":"Functions on Lie groups","text":"","category":"section"},{"location":"interface/group/","page":"Lie group","title":"Lie group","text":"Modules = [LieGroups]\nPages = [\"src/interface.jl\"]\nOrder = [:function]","category":"page"},{"location":"interface/group/#Base.adjoint-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"Base.adjoint","text":"adjoint(G::AbstractLieGroup, g, X)\nadjoint!(G::AbstractLieGroup, Y, g, X)\n\nCompute the adjoint mathrmAd(g) mathfrak g  mathfrak g, which is defined as the differential diff_conjugate of the conjugate c_g(h) = ghg^-1 evaluated at the Identity h=mathrme. The operation can be performed in-place of Y.\n\n  mathrmAd(g)X = D c_g(mathrme) X qquad X  mathfrak g\n\nsee [HN12, Section 9.2.3].\n\nOn matrix Lie groups the adjoint reads mathrmAd(g)X = gXg^-1.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.exp-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"Base.exp","text":"exp(G::AbstractLieGroup, g, X)\nexp!(G::AbstractLieGroup, h, g, X)\n\nCompute the Lie group exponential map for gmathcal G and Xmathfrak g, where mathfrak g denotes the LieAlgebra of mathcal G. It is given by\n\nexp_g X = gexp_mathcal G(X)\n\nwhere X can be scaled by t, the computation can be performed in-place of h, and exp_mathcal G denotes the  Lie group exponential function.\n\nIf g is the Identity the Lie group exponential function exp_mathcal G is computed directly. Implementing the Lie group exponential function introduces a default implementation with the formula above.\n\nnote: Note\nThe Lie group exponential map is usually different from the exponential map with respect to the metric of the underlying Riemannian manifold mathcal M. To access the (Riemannian) exponential map, use exp(base_manifold(G), g, X).\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.exp-Tuple{AbstractLieGroup, Any}","page":"Lie group","title":"Base.exp","text":"exp(G::AbstractLieGroup, X::T)\nexp!(G::AbstractLieGroup, g, X)\n\nCompute the (Lie group) exponential function\n\nexp_mathcal G mathfrak g  mathcal Gqquad exp_mathcal G(X) = Œ≥_X(1)\n\nwhere Œ≥_X is the unique solution of the initial value problem\n\nŒ≥(0) = mathrme quad Œ≥(s) = Œ≥(s)X\n\nSee also [HN12, Definition 9.2.2]. On matrix Lie groups this is the same as the matrix exponential.\n\nThe computation can be performed in-place of g.\n\ninfo: Naming convention\nThere are at least two different objects usually called ‚Äúexponential‚Äù that need to be distinguishedthe (Riemannian) exponential map exp(M, p, X) from ManifoldsBase.jl. This can be accessed here using exp(base_manifold(G), p, X)\nthe exponential map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric exp(G, g, X), which we use as a default within this package\nthe (matrix/Lie group) exponential function exp(G, g) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.inv-Tuple{AbstractLieGroup, Any}","page":"Lie group","title":"Base.inv","text":"inv(G::AbstractLieGroup, g)\ninv!(G::AbstractLieGroup, h, g)\n\nCompute the inverse group element g^-1 with respect to the AbstractGroupOperation  on the AbstractLieGroup mathcal G, that is, return the unique element h=g^-1 such that hg=mathrme, where mathrme denotes the Identity.\n\nThis can be done in-place of h, without side effects, that is you can do inv!(G, g, g).\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.isapprox-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"Base.isapprox","text":"isapprox(M::AbstractLieGroup, g, h; kwargs...)\n\nCheck if points g and h from AbstractLieGroup are approximately equal. this function calls the corresponding isapprox on the AbstractManifold after handling the cases where one or more of the points are the Identity. All keyword argments are passed to this function as well.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.log-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"Base.log","text":"log(G::AbstractLieGroup, g, h)\nlog!(G::AbstractLieGroup, X, g, h)\n\nCompute the Lie group logarithmic map log_g mathcal G  mathfrak g, where mathfrak g denotes the LieAlgebra of mathcal G. It is given by\n\nlog_g h = log_mathcal G(g^-1h)\n\nwhere log_mathcal G denotes the Lie group logarithmic function The computation can be performed in-place of X.\n\ninfo: Naming convention\nThere are at least two different objects usually called ‚Äúlogarithm‚Äù that need to be distinguishedthe (Riemannian) logarithmic map log(M, p, X) from ManifoldsBase.jl\nthe exponential map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric exp(G, g, X), which we use as a default within this package\nthe (matrix/Lie group) exponential function exp(G, g) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.log-Tuple{AbstractLieGroup, Any}","page":"Lie group","title":"Base.log","text":"log(G::AbstractLieGroup, g, h)\nlog(G::AbstractLieGroup, g)\nlog(G::AbstractLieGroup, g::Identity, T)\nlog!(G::AbstractLieGroup, X::T, g)\n\nCompute the (Lie group) logarithmic function log_mathcal G mathcal G  mathfrak g, which is the inverse of the Lie group exponential function. For the allocating variant, you can specify the type T, when the point argument is the identity and hence does not provide the representation used. The computation can be performed in-place of X::T, which then determines the type.\n\ninfo: Naming convention\nThere are at least two different objects usually called ‚Äúlogarithm‚Äù that need to be distinguishedthe (Riemannian) logarithm map log(M, p, q) from ManifoldsBase.jl. This can be accessed here using log(base_manifold(G), p, q).\nthe logarithmic map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric log(G, g, h), which we use as a default within this package\nthe (matrix/Lie group) logarithm function log(G, h) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.rand-Tuple{AbstractLieGroup, Type}","page":"Lie group","title":"Base.rand","text":"rand(::AbstractLieGroup; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand(::AbstractLieGroup, PT::Type; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, T::Type; œÉ::Real=1.0, kwargs...)\nrand!(::AbstractLieGroup, gX::PT; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, X::T; œÉ::Real=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\nFor both cases, you can provide the type T for the tangent vector and/or point PT, if you want to generate a random point in a certain representation. For the in-place variants the type is inferred from pX¬¥ andX`, respectively.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.rand-Tuple{AbstractLieGroup}","page":"Lie group","title":"Base.rand","text":"rand(::AbstractLieGroup; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand(::AbstractLieGroup, PT::Type; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, T::Type; œÉ::Real=1.0, kwargs...)\nrand!(::AbstractLieGroup, gX::PT; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, X::T; œÉ::Real=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\nFor both cases, you can provide the type T for the tangent vector and/or point PT, if you want to generate a random point in a certain representation. For the in-place variants the type is inferred from pX¬¥ andX`, respectively.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.compose!-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.compose!","text":"compose(G::AbstractLieGroup, g, h)\ncompose!(G::AbstractLieGroup, k, g, h)\n\nPerform the group operation g  h for two g h  mathcal G on the AbstractLieGroup G. This can also be done in-place of h.\n\ninfo: Info\nThis function also handles the case where g or/and h are the Identity(G). Since this would lead to ambiguities when implementing a new group operations, this function calls _compose and _compose!, respectively, which is meant for the actual computation of group operations on (non-Identity` but maybe its numerical representation) elements.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.conjugate!-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.conjugate!","text":"conjugate(G::AbstractLieGroup, g, h)\nconjugate!(G::AbstractLieGroup, k, g, h)\n\nCompute the conjugation map c_g mathcal G  mathcal G given by c_g(h) = ghg^-1. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.conjugate-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"LieGroups.conjugate","text":"conjugate(G::AbstractLieGroup, g, h)\nconjugate!(G::AbstractLieGroup, k, g, h)\n\nCompute the conjugation map c_g mathcal G  mathcal G given by c_g(h) = ghg^-1. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_conjugate!-Tuple{AbstractLieGroup, Vararg{Any, 4}}","page":"Lie group","title":"LieGroups.diff_conjugate!","text":"diff_conjugate(G::AbstractLieGroup, g, h, X)\ndiff_conjugate!(G::AbstractLieGroup, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1 on the AbstractLieGroup G. The operation can be performed in-place of Y.\n\n  D(c_g(h))X qquad X  mathfrak g\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_conjugate-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.diff_conjugate","text":"diff_conjugate(G::AbstractLieGroup, g, h, X)\ndiff_conjugate!(G::AbstractLieGroup, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1 on the AbstractLieGroup G. The operation can be performed in-place of Y.\n\n  D(c_g(h))X qquad X  mathfrak g\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_inv!-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.diff_inv!","text":"diff_inv(G::AbstractLieGroup, g, X)\ndiff_inv!(G::AbstractLieGroup, Y, g, X)\n\nCompute the differential of the function Œπ_mathcal G(g) = g^-1, where DŒπ_mathcal G(g) mathfrak g  mathfrak g. This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_inv-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"LieGroups.diff_inv","text":"diff_inv(G::AbstractLieGroup, g, X)\ndiff_inv!(G::AbstractLieGroup, Y, g, X)\n\nCompute the differential of the function Œπ_mathcal G(g) = g^-1, where DŒπ_mathcal G(g) mathfrak g  mathfrak g. This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_left_compose!-Tuple{AbstractLieGroup, Vararg{Any, 4}}","page":"Lie group","title":"LieGroups.diff_left_compose!","text":"diff_left_compose(G::AbstractLieGroup, g, h, X)\ndiff_left_compose!(G::AbstractLieGroup, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh, on the AbstractLieGroup G, that is Compute DŒª_g(h)X, X  ùî§. This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_left_compose-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.diff_left_compose","text":"diff_left_compose(G::AbstractLieGroup, g, h, X)\ndiff_left_compose!(G::AbstractLieGroup, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh, on the AbstractLieGroup G, that is Compute DŒª_g(h)X, X  ùî§. This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_right_compose!-Tuple{AbstractLieGroup, Vararg{Any, 4}}","page":"Lie group","title":"LieGroups.diff_right_compose!","text":"diff_right_compose(G::AbstractLieGroup, h, g, X)\ndiff_right_compose!(G::AbstractLieGroup, Y, h, g, X)\n\nCompute the differential of the right group multiplication œÅ_g(h) = hg, on the AbstractLieGroup G, that is Compute DœÅ_g(h)X, X  ùî§ This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_right_compose-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.diff_right_compose","text":"diff_right_compose(G::AbstractLieGroup, h, g, X)\ndiff_right_compose!(G::AbstractLieGroup, Y, h, g, X)\n\nCompute the differential of the right group multiplication œÅ_g(h) = hg, on the AbstractLieGroup G, that is Compute DœÅ_g(h)X, X  ùî§ This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.identity_element!-Tuple{AbstractLieGroup, Any}","page":"Lie group","title":"LieGroups.identity_element!","text":"identity_element(G::AbstractLieGroup)\nidentity_element(G::AbstractLieGroup, T)\nidentity_element!(G::AbstractLieGroup, e::T)\n\nReturn a point representation of the Identity on the AbstractLieGroup G. By default this representation is the default array or number representation. If there exist several representations, the type T can be used to distinguish between them, and it should be provided for both the AbstractLieGroupPoint as well as the AbstractLieAlgebraTangentVector if they differ, since maybe only one of these types might be available for the second signature.\n\nIt returns the corresponding default representation of e as a point on G. This can be performed in-place of e.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv!-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"LieGroups.inv!","text":"inv(G::AbstractLieGroup, g)\ninv!(G::AbstractLieGroup, h, g)\n\nCompute the inverse group element g^-1 with respect to the AbstractGroupOperation  on the AbstractLieGroup mathcal G, that is, return the unique element h=g^-1 such that hg=mathrme, where mathrme denotes the Identity.\n\nThis can be done in-place of h, without side effects, that is you can do inv!(G, g, g).\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv_left_compose!-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.inv_left_compose!","text":"inv_left_compose(G::AbstractLieGroup, g, h)\ninv_left_compose!(G::AbstractLieGroup, k, g, h)\n\nCompute the inverse of the left group operation Œª_g(h) = gh, on the AbstractLieGroup G, that is, compute Œª_g^-1(h) = g^-1h. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv_left_compose-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"LieGroups.inv_left_compose","text":"inv_left_compose(G::AbstractLieGroup, g, h)\ninv_left_compose!(G::AbstractLieGroup, k, g, h)\n\nCompute the inverse of the left group operation Œª_g(h) = gh, on the AbstractLieGroup G, that is, compute Œª_g^-1(h) = g^-1h. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv_right_compose!-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.inv_right_compose!","text":"inv_right_compose(G::AbstractLieGroup, h, g)\ninv_right_compose!(G::AbstractLieGroup, k, h, g)\n\nCompute the inverse of the right group operation œÅ_g(h) = hg, on the AbstractLieGroup G, that is compute œÅ_g^-1(h) = hg^-1. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv_right_compose-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"LieGroups.inv_right_compose","text":"inv_right_compose(G::AbstractLieGroup, h, g)\ninv_right_compose!(G::AbstractLieGroup, k, h, g)\n\nCompute the inverse of the right group operation œÅ_g(h) = hg, on the AbstractLieGroup G, that is compute œÅ_g^-1(h) = hg^-1. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.jacobian_conjugate","page":"Lie group","title":"LieGroups.jacobian_conjugate","text":"jacobian_conjugate(G::AbstractLieGroup, g, h; basis::AbstractBasis=DefaultLieAlgebraOrthogonalBasis(); X=zero_vector(LieAlgebar(G)))\njacobian_conjugate!(G::AbstractLieGroup, J, g, h; basis::AbstractBasis=DefaultLieAlgebraOrthogonalBasis(); X=zero_vector(LieAlgebar(G)))\n\nCompute the Jacobian of the conjugate c_g(h) = ghg^-1, with respect to an AbstractBasis of the LieAlgebra.\n\nA default is implemented using diff_conjugate D(c_g(h))X: the jth column of of the Jacobian matrix J are given by the coefficients of the tangent vector D(c_g(h))[X_j]with respect to the basisB, whereX_jis thejth basis vector ofB`.\n\nnote: Note\nFor the case that h is the Identity and the relation of D(c_g(h))X to the adjoint mathrmAd(g), the Jacobian then sometimes called ‚Äúadjoint matrix‚Äù, e.g. in [SDA21], when choosing as a basis the DefaultLieAlgebraOrthogonalBasis() that is used for hat and vee.\n\nKeyword arguments\n\nX=zero_vector(LieAlgebra(G)) pass an interims memory to store the Lie algebra tangent vector in.\n\n\n\n\n\n","category":"function"},{"location":"interface/group/#LieGroups.jacobian_conjugate!","page":"Lie group","title":"LieGroups.jacobian_conjugate!","text":"jacobian_conjugate(G::AbstractLieGroup, g, h; basis::AbstractBasis=DefaultLieAlgebraOrthogonalBasis(); X=zero_vector(LieAlgebar(G)))\njacobian_conjugate!(G::AbstractLieGroup, J, g, h; basis::AbstractBasis=DefaultLieAlgebraOrthogonalBasis(); X=zero_vector(LieAlgebar(G)))\n\nCompute the Jacobian of the conjugate c_g(h) = ghg^-1, with respect to an AbstractBasis of the LieAlgebra.\n\nA default is implemented using diff_conjugate D(c_g(h))X: the jth column of of the Jacobian matrix J are given by the coefficients of the tangent vector D(c_g(h))[X_j]with respect to the basisB, whereX_jis thejth basis vector ofB`.\n\nnote: Note\nFor the case that h is the Identity and the relation of D(c_g(h))X to the adjoint mathrmAd(g), the Jacobian then sometimes called ‚Äúadjoint matrix‚Äù, e.g. in [SDA21], when choosing as a basis the DefaultLieAlgebraOrthogonalBasis() that is used for hat and vee.\n\nKeyword arguments\n\nX=zero_vector(LieAlgebra(G)) pass an interims memory to store the Lie algebra tangent vector in.\n\n\n\n\n\n","category":"function"},{"location":"interface/group/#LinearAlgebra.adjoint!-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"LinearAlgebra.adjoint!","text":"adjoint(G::AbstractLieGroup, g, X)\nadjoint!(G::AbstractLieGroup, Y, g, X)\n\nCompute the adjoint mathrmAd(g) mathfrak g  mathfrak g, which is defined as the differential diff_conjugate of the conjugate c_g(h) = ghg^-1 evaluated at the Identity h=mathrme. The operation can be performed in-place of Y.\n\n  mathrmAd(g)X = D c_g(mathrme) X qquad X  mathfrak g\n\nsee [HN12, Section 9.2.3].\n\nOn matrix Lie groups the adjoint reads mathrmAd(g)X = gXg^-1.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Manifolds.compose-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"Manifolds.compose","text":"compose(G::AbstractLieGroup, g, h)\ncompose!(G::AbstractLieGroup, k, g, h)\n\nPerform the group operation g  h for two g h  mathcal G on the AbstractLieGroup G. This can also be done in-place of h.\n\ninfo: Info\nThis function also handles the case where g or/and h are the Identity(G). Since this would lead to ambiguities when implementing a new group operations, this function calls _compose and _compose!, respectively, which is meant for the actual computation of group operations on (non-Identity` but maybe its numerical representation) elements.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Manifolds.identity_element-Tuple{AbstractLieGroup}","page":"Lie group","title":"Manifolds.identity_element","text":"identity_element(G::AbstractLieGroup)\nidentity_element(G::AbstractLieGroup, T)\nidentity_element!(G::AbstractLieGroup, e::T)\n\nReturn a point representation of the Identity on the AbstractLieGroup G. By default this representation is the default array or number representation. If there exist several representations, the type T can be used to distinguish between them, and it should be provided for both the AbstractLieGroupPoint as well as the AbstractLieAlgebraTangentVector if they differ, since maybe only one of these types might be available for the second signature.\n\nIt returns the corresponding default representation of e as a point on G. This can be performed in-place of e.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Manifolds.is_identity-Tuple{AbstractLieGroup, Any}","page":"Lie group","title":"Manifolds.is_identity","text":"is_identity(G::AbstractLieGroup, q; kwargs...)\n\nCheck whether q is the identity on the AbstractLieGroup mathcal G. This means it is either the Identity{O} with the respect to the corresponding AbstractGroupOperation O, or (approximately) the correct point representation.\n\nSee also\n\nidentity_element, identity_element!\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.base_manifold-Tuple{AbstractLieGroup}","page":"Lie group","title":"ManifoldsBase.base_manifold","text":"base_manifold(G::AbstractLieGroup)\n\nReturn the manifold stored within the AbstractLieGroup G.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.exp!-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"ManifoldsBase.exp!","text":"exp(G::AbstractLieGroup, g, X)\nexp!(G::AbstractLieGroup, h, g, X)\n\nCompute the Lie group exponential map for gmathcal G and Xmathfrak g, where mathfrak g denotes the LieAlgebra of mathcal G. It is given by\n\nexp_g X = gexp_mathcal G(X)\n\nwhere X can be scaled by t, the computation can be performed in-place of h, and exp_mathcal G denotes the  Lie group exponential function.\n\nIf g is the Identity the Lie group exponential function exp_mathcal G is computed directly. Implementing the Lie group exponential function introduces a default implementation with the formula above.\n\nnote: Note\nThe Lie group exponential map is usually different from the exponential map with respect to the metric of the underlying Riemannian manifold mathcal M. To access the (Riemannian) exponential map, use exp(base_manifold(G), g, X).\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.exp!-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"ManifoldsBase.exp!","text":"exp(G::AbstractLieGroup, X::T)\nexp!(G::AbstractLieGroup, g, X)\n\nCompute the (Lie group) exponential function\n\nexp_mathcal G mathfrak g  mathcal Gqquad exp_mathcal G(X) = Œ≥_X(1)\n\nwhere Œ≥_X is the unique solution of the initial value problem\n\nŒ≥(0) = mathrme quad Œ≥(s) = Œ≥(s)X\n\nSee also [HN12, Definition 9.2.2]. On matrix Lie groups this is the same as the matrix exponential.\n\nThe computation can be performed in-place of g.\n\ninfo: Naming convention\nThere are at least two different objects usually called ‚Äúexponential‚Äù that need to be distinguishedthe (Riemannian) exponential map exp(M, p, X) from ManifoldsBase.jl. This can be accessed here using exp(base_manifold(G), p, X)\nthe exponential map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric exp(G, g, X), which we use as a default within this package\nthe (matrix/Lie group) exponential function exp(G, g) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.is_point-Tuple{AbstractLieGroup, Any}","page":"Lie group","title":"ManifoldsBase.is_point","text":"is_point(G::AbstractLieGroup, g; kwargs...)\n\nCheck whether g is a valid point on the Lie Group G. This falls back to checking whether g is a valid point on the base_manifoldG. unless g is an Identity. Then, it is checked whether it is the identity element corresponding to G.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.log!-Tuple{AbstractLieGroup, Any, Any, Any}","page":"Lie group","title":"ManifoldsBase.log!","text":"log(G::AbstractLieGroup, g, h)\nlog!(G::AbstractLieGroup, X, g, h)\n\nCompute the Lie group logarithmic map log_g mathcal G  mathfrak g, where mathfrak g denotes the LieAlgebra of mathcal G. It is given by\n\nlog_g h = log_mathcal G(g^-1h)\n\nwhere log_mathcal G denotes the Lie group logarithmic function The computation can be performed in-place of X.\n\ninfo: Naming convention\nThere are at least two different objects usually called ‚Äúlogarithm‚Äù that need to be distinguishedthe (Riemannian) logarithmic map log(M, p, X) from ManifoldsBase.jl\nthe exponential map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric exp(G, g, X), which we use as a default within this package\nthe (matrix/Lie group) exponential function exp(G, g) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.log!-Tuple{AbstractLieGroup, Any, Any}","page":"Lie group","title":"ManifoldsBase.log!","text":"log(G::AbstractLieGroup, g, h)\nlog(G::AbstractLieGroup, g)\nlog(G::AbstractLieGroup, g::Identity, T)\nlog!(G::AbstractLieGroup, X::T, g)\n\nCompute the (Lie group) logarithmic function log_mathcal G mathcal G  mathfrak g, which is the inverse of the Lie group exponential function. For the allocating variant, you can specify the type T, when the point argument is the identity and hence does not provide the representation used. The computation can be performed in-place of X::T, which then determines the type.\n\ninfo: Naming convention\nThere are at least two different objects usually called ‚Äúlogarithm‚Äù that need to be distinguishedthe (Riemannian) logarithm map log(M, p, q) from ManifoldsBase.jl. This can be accessed here using log(base_manifold(G), p, q).\nthe logarithmic map for a (left/right/bi-invariant) Cartan-Schouten (pseudo-)metric log(G, g, h), which we use as a default within this package\nthe (matrix/Lie group) logarithm function log(G, h) which agrees with the previous one for g being the identity there.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Random.rand!-Tuple{AbstractLieGroup, Any}","page":"Lie group","title":"Random.rand!","text":"rand(::AbstractLieGroup; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand(::AbstractLieGroup, PT::Type; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, T::Type; œÉ::Real=1.0, kwargs...)\nrand!(::AbstractLieGroup, gX::PT; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, X::T; œÉ::Real=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\nFor both cases, you can provide the type T for the tangent vector and/or point PT, if you want to generate a random point in a certain representation. For the in-place variants the type is inferred from pX¬¥ andX`, respectively.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Internal-functions-and-macros","page":"Lie group","title":"Internal functions and macros","text":"","category":"section"},{"location":"interface/group/","page":"Lie group","title":"Lie group","text":"LieGroups.CommonUnitarySubAlgebra\nLieGroups.@default_lie_group_fallbacks","category":"page"},{"location":"interface/group/#LieGroups.CommonUnitarySubAlgebra","page":"Lie group","title":"LieGroups.CommonUnitarySubAlgebra","text":"CommonUnitarySubAlgebra{ùîΩ,T}\n\nA constant that allows to refer to several sub Algebras of mathfrak u(n) for implementations where\n\ncertain sub algebras real/complex share a common implementation, e.g. for the same sizes T usually via TypeParameter\ncertain functions are the same for all sizes T as long as the field ùîΩ is the same\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#LieGroups.@default_lie_group_fallbacks","page":"Lie group","title":"LieGroups.@default_lie_group_fallbacks","text":"default_lie_group_fallbacks(TG, TF, TP, TV, pfield::Symbol, Xfield::Symbol, groupOp)\n\nIntroduce default fallbacks for all basic functions on Lie groups, for Lie group of type TG with group operation Op, points of type TP, tangent vectors of type TV, with forwarding to fields pfield and Xfield for point and tangent vector functions, respectively.\n\n\n\n\n\n","category":"macro"},{"location":"interface/group/#A-validation-Lie-group","page":"Lie group","title":"A validation Lie group","text":"","category":"section"},{"location":"interface/group/","page":"Lie group","title":"Lie group","text":"ValidationLieGroup","category":"page"},{"location":"interface/group/#LieGroups.ValidationLieGroup","page":"Lie group","title":"LieGroups.ValidationLieGroup","text":"ValidationLieGroup{L<:AbstractLieGroup} <: AbstractLieGroup\n\nA Lie group to add tests to input parameters and output values of functions defined for LieGroups.\n\nUsing the ignore_contexts keyword allows to specify a single Symbol or a vector of Symbols Of which contexts to ignore.\n\nCurrent contexts are\n\n:All: disable all checks\n:Point: checks for points\n:Algebra: checks related to the LieAlgebra\n:Output: checks for output\n:Input: checks for input variables\n\nFields\n\nlie_group::L the AbstractLieGroup to be decorated\nmode::Symbol: The mode to be used for error handling, either :error or :warn\nignore_contexts::AbstractVector{Symbol}: store contexts to be ignored of validation.\nignore_functions::Dict{<:Function,<:Union{Symbol,<:AbstractVector{Symbol}}: store contexts to be ignored with in a function or its mutating variant.\n\nwhere all but the first field are analogous to the setups of the ValidationManifold. We refer to those docs for more examples on their meaning.\n\nConstructor\n\nValidationLieGroup(L::AbstractLieGroup, check_manifold=true; kwargs...)\n\nGenerate the Validation Lie Group for the given AbstractLieGroup L. If check_manifold is set to true the inner manifold is additionally wrapped in a ValidationManifold. All suitable keywords are passed to the constructor of the validation manifold as well.\n\nKeyword arguments\n\nerror::Symbol=:error: specify how errors in the validation should be reported. this is passed to is_point and is_vector as the error keyword argument. Available values are :error, :warn, :info, and :none. Every other value is treated as :none.\nignore_contexts = Vector{Symbol}() a vector to indicate which validation contexts should not be performed.\nignore_functions=Dict{Function,Union{Symbol,Vector{Symbol}}}() a dictionary to disable certain contexts within functions. The key here is the non-mutating function variant (if it exists). The contexts are the same as in ignore_contexts.\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#Internal-functions","page":"Lie group","title":"Internal functions","text":"","category":"section"},{"location":"interface/group/","page":"Lie group","title":"Lie group","text":"LieGroups._vLc\nLieGroups._msg","category":"page"},{"location":"interface/group/#LieGroups._vLc","page":"Lie group","title":"LieGroups._vLc","text":"_vLc(M::ValidationLieGroup, f::Function, context::Symbol)\n_vLc(M::ValidationLieGroup, f::Function, context::NTuple{N,Symbol}) where {N}\n_vLc(M::ValidationLieGroup, ::Nothing, context::NTuple{N,Symbol}) where {N}\n\nReturn whether a check should be performed within f and the context(s) provided, if the second argument is :Nothing, only the context is checked\n\nThis function returns false and hence indicates not to check, when\n\n(one of the) context(s) is in the ignore list for f within ignore_functions\n(one of the) context(s) is in the ignore_contexts list\n\nOtherwise the test is active.\n\n!!! Note    This function is internal and used very often, so it has a very short name;     _vLc stands for \"ValidationLieGroup check\".\n\n\n\n\n\n","category":"function"},{"location":"interface/group/#LieGroups._msg","page":"Lie group","title":"LieGroups._msg","text":"_msg(G::ValidationLieGroup, str; error=:None, within::Union{Nothing,<:Function} = nothing,\ncontext::Union{NTuple{N,Symbol} where N} = NTuple{0,Symbol}())\n\nissue a message str according to the mode mode (as @error, @warn, @info).\n\n\n\n\n\n","category":"function"},{"location":"interface/group/#Literature","page":"Lie group","title":"Literature","text":"","category":"section"},{"location":"interface/group/","page":"Lie group","title":"Lie group","text":"J.¬†Hilgert and K.-H.¬†Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\nJ.¬†Sol√†, J.¬†Deray and D.¬†Atchuthan. A micro Lie theory for state estimation in robotics (Dec 2021), arXiv:1812.01537 [cs.RO], arXiv: 1812.01537.\n\n\n\n","category":"page"},{"location":"interface/algebra/#An-interface-for-Lie-algebras","page":"Lie algebra","title":"An interface for Lie algebras","text":"","category":"section"},{"location":"interface/algebra/","page":"Lie algebra","title":"Lie algebra","text":"LieAlgebra\nDefaultLieAlgebraOrthogonalBasis","category":"page"},{"location":"interface/algebra/#LieGroups.LieAlgebra","page":"Lie algebra","title":"LieGroups.LieAlgebra","text":"LieAlgebra{ùîΩ, G} <: AbstractManifold{ùîΩ}\n\nRepresent the Lie algebra mathfrak g, that is a ùîΩ vector space with an associated lie_bracket  mathfrak gmathfrak g  mathfrak g which fulfills\n\nXX = 0 for all X  mathfrak g\nThe Jacobi identity X YZ = XYZ = Y XZ holds for all X Y Z  mathfrak g.\n\nThe Lie algebras considered here are those related to a AbstractLieGroup mathcal G, namely the tangent space T_mathrmemathcal G at the Identity, this is internally just a const of the corresponding TangentSpace.\n\nnote: Convention for representing tangent vectors in the Lie algebra\nA vector field mathcal X mathcal G  Tmathcal G, X(g)  T_gmathcal G is called a left-invariant vector field if it satisfiesmathcal X(Œª_g(h)) = DŒª_g(h)mathcal X(h) quadtextfor allquad g h  mathcal Gwhere Œª_g mathcal G  mathcal G is the left multiplication by g. Hence mathcal X is determined already when X  mathfrak g is given, since mathcal X(g) = DŒª_g(e)X, cf [HN12, Definition 9.1.7].Throughout LieGroups.jl, we use this left-invariant convention to store tangent vectors at points on a Lie group as elements of the corresponding Lie algebra.\n\nConstructor\n\nLieAlgebra(G::AbstractLieGroup)\n\nReturn the Lie Algebra belonging to the AbstractLieGroup G.\n\n\n\n\n\n","category":"type"},{"location":"interface/algebra/#LieGroups.DefaultLieAlgebraOrthogonalBasis","page":"Lie algebra","title":"LieGroups.DefaultLieAlgebraOrthogonalBasis","text":"DefaultLieAlgebraOrthogonalBasis{ùîΩ} <: ManifoldsBase.AbstractOrthogonalBasis{ùîΩ,ManifoldsBase.TangentSpaceType}\n\nSpecify an orthogonal basis for a Lie algebra. This is used as the default within hat and vee.\n\nIf not specifically overwritten/implemented for a Lie group, the DefaultOrthogonalBasis at the identity_element on the `base_manifold acts as a fallback.\n\nnote: Note\nIn order to implement the corresponding get_coordinates and get_vector functions, define get_coordinates_lie(::AbstractLieAlgebra, X, B) and get_vector_lie(::AbstractLieAlgebra, X, B), resp.\n\n\n\n\n\n","category":"type"},{"location":"interface/algebra/#Functions-on-Lie-algebras","page":"Lie algebra","title":"Functions on Lie algebras","text":"","category":"section"},{"location":"interface/algebra/","page":"Lie algebra","title":"Lie algebra","text":"Modules = [LieGroups]\nPages = [\"src/Lie_algebra/Lie_algebra_interface.jl\"]\nOrder = [:function]","category":"page"},{"location":"interface/algebra/#Base.rand-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s21\", O, M} where {var\"#s21\", M<:ManifoldsBase.AbstractManifold{var\"#s21\"}})}}","page":"Lie algebra","title":"Base.rand","text":"rand(::LieGroup; vector_at=nothing, œÉ=1.0, kwargs...)\nrand(::LieAlgebra; œÉ=1.0, kwargs...)\nrand!(::AbstractLieGroup, gX; vector_at=nothing, kwargs...)\nrand!(::LieAlgebra, X; œÉ=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#LieGroups.base_lie_group-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s21\", O, M} where {var\"#s21\", M<:ManifoldsBase.AbstractManifold{var\"#s21\"}})}}","page":"Lie algebra","title":"LieGroups.base_lie_group","text":"base_lie_group(ùî§::LieAlgebra)\n\nReturn the base_lie_group of the given LieAlgebra belongs to.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#LieGroups.lie_bracket!-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s21\", O, M} where {var\"#s21\", M<:ManifoldsBase.AbstractManifold{var\"#s21\"}})}, Any, Any, Any}","page":"Lie algebra","title":"LieGroups.lie_bracket!","text":"lie_bracket!(ùî§::LieAlgebra, X, Y)\nlie_bracket!(ùî§::LieAlgebra, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g which fulfills\n\nXX = 0 for all X  mathfrak g\nThe Jacobi identity X YZ = XYZ = Y XZ holds for all X Y Z  mathfrak g.\n\nThe computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#LieGroups.lie_bracket-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s21\", O, M} where {var\"#s21\", M<:ManifoldsBase.AbstractManifold{var\"#s21\"}})}, Any, Any}","page":"Lie algebra","title":"LieGroups.lie_bracket","text":"lie_bracket!(ùî§::LieAlgebra, X, Y)\nlie_bracket!(ùî§::LieAlgebra, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g which fulfills\n\nXX = 0 for all X  mathfrak g\nThe Jacobi identity X YZ = XYZ = Y XZ holds for all X Y Z  mathfrak g.\n\nThe computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.base_manifold-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s21\", O, M} where {var\"#s21\", M<:ManifoldsBase.AbstractManifold{var\"#s21\"}})}}","page":"Lie algebra","title":"ManifoldsBase.base_manifold","text":"base_manifold(ùî§::LieAlgebra)\n\nReturn the base_manifold the AbstractLieGroup of the given LieAlgebra is based on.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.get_coordinates","page":"Lie algebra","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(ùî§::LieAlgebra, X::T, B::AbstractBasis)\nget_coordinates!(ùî§::LieAlgebra, c, X::T, B::AbstractBasis)\n\nReturn the vector of coordinates to the decomposition of X with respect to an AbstractBasis of the LieAlgebra ùî§. The operation can be performed in-place of c.\n\nBy default this function requires that identity_element(G, T) is available and calls the corresponding get_coordinates function of the Riemannian manifold the Lie group is build on.\n\nThe inverse operation is get_vector.\n\nSee also vee.\n\n\n\n\n\n","category":"function"},{"location":"interface/algebra/#ManifoldsBase.get_coordinates!","page":"Lie algebra","title":"ManifoldsBase.get_coordinates!","text":"get_coordinates(ùî§::LieAlgebra, X::T, B::AbstractBasis)\nget_coordinates!(ùî§::LieAlgebra, c, X::T, B::AbstractBasis)\n\nReturn the vector of coordinates to the decomposition of X with respect to an AbstractBasis of the LieAlgebra ùî§. The operation can be performed in-place of c.\n\nBy default this function requires that identity_element(G, T) is available and calls the corresponding get_coordinates function of the Riemannian manifold the Lie group is build on.\n\nThe inverse operation is get_vector.\n\nSee also vee.\n\n\n\n\n\n","category":"function"},{"location":"interface/algebra/#ManifoldsBase.get_vector","page":"Lie algebra","title":"ManifoldsBase.get_vector","text":"get_vector(G::AbstractLieGroup, c, B::AbstractBasis; kwargs...)\nget_vector(ùî§::LieAlgebra, c, B::AbstractBasis; kwargs...)\nget_vector!(G::AbstractLieGroup, X::T, c, B::AbstractBasis; kwargs...)\nget_vector!(ùî§::LieAlgebra, X::T, c, B::AbstractBasis; kwargs...)\n\nReturn the vector corresponding to a set of coefficients in an AbstractBasis of the LieAlgebra ùî§. Since all tangent vectors are assumed to be represented in the Lie algebra, both signatures are equivalent. The operation can be performed in-place of a tangent vector X of type ::T.\n\nBy default this function requires identity_element(G) and calls the corresponding get_vector function of the Riemannian manifold the Lie group is build on.\n\nThe inverse operation is get_coordinates.\n\nKeyword arguments\n\ntangent_vector_type specify the tangent vector type to use for the allocating variants.\n\nSee also hat\n\n\n\n\n\n","category":"function"},{"location":"interface/algebra/#ManifoldsBase.get_vector!","page":"Lie algebra","title":"ManifoldsBase.get_vector!","text":"get_vector(G::AbstractLieGroup, c, B::AbstractBasis; kwargs...)\nget_vector(ùî§::LieAlgebra, c, B::AbstractBasis; kwargs...)\nget_vector!(G::AbstractLieGroup, X::T, c, B::AbstractBasis; kwargs...)\nget_vector!(ùî§::LieAlgebra, X::T, c, B::AbstractBasis; kwargs...)\n\nReturn the vector corresponding to a set of coefficients in an AbstractBasis of the LieAlgebra ùî§. Since all tangent vectors are assumed to be represented in the Lie algebra, both signatures are equivalent. The operation can be performed in-place of a tangent vector X of type ::T.\n\nBy default this function requires identity_element(G) and calls the corresponding get_vector function of the Riemannian manifold the Lie group is build on.\n\nThe inverse operation is get_coordinates.\n\nKeyword arguments\n\ntangent_vector_type specify the tangent vector type to use for the allocating variants.\n\nSee also hat\n\n\n\n\n\n","category":"function"},{"location":"interface/algebra/#ManifoldsBase.hat!-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s21\", O, M} where {var\"#s21\", M<:ManifoldsBase.AbstractManifold{var\"#s21\"}})}, Any, Any}","page":"Lie algebra","title":"ManifoldsBase.hat!","text":"hat(G::LieAlgebra, c)\nhat(G::LieAlgebra, c, T::Type)\nhat!(G::LieAlgebra, X::T, c)\n\nCompute the hat map ()^wedge mathcal V  ùî§ that maps a vector of coordinates mathbfc  mathcal V, to a tangent vector X  mathfrak g. The coefficients are given with respect to a specific basis to a tangent vector in the Lie algebra\n\nX = sum_imathcal I c_iB_i\n\nwhere  B_i _imathcal I is a basis of the Lie algebra and mathcal I a corresponding index set, which is usually mathcal I= 1ldotsn . Then mathcal V = ‚Ñù^n.\n\nFor the allocating variant, you can specify the type T of the tangent vector to obtain, in case there are different representations. The first signature produces the default representation.\n\nThe computation can be performed in-place of X. The inverse of hat is vee. Technically, hat is a specific case of get_vector and is implemented using the DefaultLieAlgebraOrthogonalBasis.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.hat-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s21\", O, M} where {var\"#s21\", M<:ManifoldsBase.AbstractManifold{var\"#s21\"}})}, Any}","page":"Lie algebra","title":"ManifoldsBase.hat","text":"hat(G::LieAlgebra, c)\nhat(G::LieAlgebra, c, T::Type)\nhat!(G::LieAlgebra, X::T, c)\n\nCompute the hat map ()^wedge mathcal V  ùî§ that maps a vector of coordinates mathbfc  mathcal V, to a tangent vector X  mathfrak g. The coefficients are given with respect to a specific basis to a tangent vector in the Lie algebra\n\nX = sum_imathcal I c_iB_i\n\nwhere  B_i _imathcal I is a basis of the Lie algebra and mathcal I a corresponding index set, which is usually mathcal I= 1ldotsn . Then mathcal V = ‚Ñù^n.\n\nFor the allocating variant, you can specify the type T of the tangent vector to obtain, in case there are different representations. The first signature produces the default representation.\n\nThe computation can be performed in-place of X. The inverse of hat is vee. Technically, hat is a specific case of get_vector and is implemented using the DefaultLieAlgebraOrthogonalBasis.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.is_point-Union{Tuple{T}, Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s21\", O, M} where {var\"#s21\", M<:ManifoldsBase.AbstractManifold{var\"#s21\"}})}, T}} where T","page":"Lie algebra","title":"ManifoldsBase.is_point","text":"is_point(ùî§::LieAlgebra, X; kwargs...)\n\nCheck whether X is a valid point on the Lie Algebra ùî§. This falls back to checking whether X is a valid point on the tangent space at the identity_element(G) on the base_manifold(G) on the AbstractLieGroup of ùî§\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.vee!-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s21\", O, M} where {var\"#s21\", M<:ManifoldsBase.AbstractManifold{var\"#s21\"}})}, Any, Any}","page":"Lie algebra","title":"ManifoldsBase.vee!","text":"vee(ùî§::LieAlgebra, X)\nvee!(ùî§::LieAlgebra, c, X)\n\nCompute the vee map ()vee mathfrak g  mathcal V that maps a tangent vector X from the LieAlgebra \\mathfrak g to its coordinates with respect to the DefaultLieAlgebraOrthogonalBasis basis in the Lie algebra\n\nX = sum_imathcal I c_iB_i\n\nwhere  B_i _imathcal I is a basis of the Lie algebra and mathcal I a corresponding index set, which is usually mathcal I= 1ldotsn . Then mathcal V = ‚Ñù^n\n\nThe computation can be performed in-place of c. The inverse of vee is hat. Technically, vee is a specific case of get_coordinates and is implemented using the DefaultLieAlgebraOrthogonalBasis.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.vee-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s21\", O, M} where {var\"#s21\", M<:ManifoldsBase.AbstractManifold{var\"#s21\"}})}, Any}","page":"Lie algebra","title":"ManifoldsBase.vee","text":"vee(ùî§::LieAlgebra, X)\nvee!(ùî§::LieAlgebra, c, X)\n\nCompute the vee map ()vee mathfrak g  mathcal V that maps a tangent vector X from the LieAlgebra \\mathfrak g to its coordinates with respect to the DefaultLieAlgebraOrthogonalBasis basis in the Lie algebra\n\nX = sum_imathcal I c_iB_i\n\nwhere  B_i _imathcal I is a basis of the Lie algebra and mathcal I a corresponding index set, which is usually mathcal I= 1ldotsn . Then mathcal V = ‚Ñù^n\n\nThe computation can be performed in-place of c. The inverse of vee is hat. Technically, vee is a specific case of get_coordinates and is implemented using the DefaultLieAlgebraOrthogonalBasis.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.zero_vector-Union{Tuple{O}, Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s21\", M} where {var\"#s21\"<:O, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Type}} where {ùîΩ, O<:AbstractGroupOperation}","page":"Lie algebra","title":"ManifoldsBase.zero_vector","text":"zero_vector(ùî§::LieAlgebra)\nzero_vector(ùî§::LieAlgebra, T::Type)\nzero_vector!(ùî§::LieAlgebra, X::T)\n\nGenerate a zero_vector of type T in the LieAlgebra ùî§ of the AbstractLieGroup G. By default this calls zero_vector on the manifold of G at the identity_element(G,T)\n\nFor the allocating variant the type T of the zero vector can be specified.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#Random.rand!-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(AbstractLieGroup{var\"#s21\", O, M} where {var\"#s21\", M<:ManifoldsBase.AbstractManifold{var\"#s21\"}})}, Any}","page":"Lie algebra","title":"Random.rand!","text":"rand(::LieGroup; vector_at=nothing, œÉ=1.0, kwargs...)\nrand(::LieAlgebra; œÉ=1.0, kwargs...)\nrand!(::AbstractLieGroup, gX; vector_at=nothing, kwargs...)\nrand!(::LieAlgebra, X; œÉ=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#Internal-functions-and-macros","page":"Lie algebra","title":"Internal functions and macros","text":"","category":"section"},{"location":"interface/algebra/","page":"Lie algebra","title":"Lie algebra","text":"LieGroups.@default_lie_algebra_fallbacks","category":"page"},{"location":"interface/algebra/#LieGroups.@default_lie_algebra_fallbacks","page":"Lie algebra","title":"LieGroups.@default_lie_algebra_fallbacks","text":"default_lie_algebra_fallbacks(TG, TF, Op, TV, Xfield::Symbol)\n\nIntroduce default fallbacks for all basic functions on Lie algebras, for Lie group of type TG with number system TF, an group operation Op, tangent vectors of type TV, with forwarding to fields Xfield and tangent vector functions\n\n\n\n\n\n","category":"macro"},{"location":"interface/algebra/#Literature","page":"Lie algebra","title":"Literature","text":"","category":"section"},{"location":"interface/algebra/","page":"Lie algebra","title":"Lie algebra","text":"J.¬†Hilgert and K.-H.¬†Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\n","category":"page"},{"location":"groups/unitary_group/#The-unitary-group","page":"Unitary group","title":"The unitary group","text":"","category":"section"},{"location":"groups/unitary_group/","page":"Unitary group","title":"Unitary group","text":"UnitaryGroup","category":"page"},{"location":"groups/unitary_group/#LieGroups.UnitaryGroup","page":"Unitary group","title":"LieGroups.UnitaryGroup","text":"UnitaryGroup{T}\n\nThe special orthogonal group mathrmU(n) is the Lie group consisting of the MatrixMultiplicationGroupOperation on the manifold of rotations UnitaryMatrices with absolute value of the determinant equal to one.\n\nConstructor\n\nUnitaryGroup(n::Int, ùîΩ::AbstractNumbers=‚ÑÇ; kwargs...)\n\nGenerate unitary group mathrmU(n). All keyword arguments in kwargs... are passed on to Rotations as well.\n\n\n\n\n\n","category":"type"},{"location":"groups/unitary_group/","page":"Unitary group","title":"Unitary group","text":"For this Lie group, several implementations are already covered by the defaults in the generic (matrix) multiplication operation. Besides that the following methods are implemented:","category":"page"},{"location":"groups/unitary_group/","page":"Unitary group","title":"Unitary group","text":"Modules = [LieGroups]\nPages = [\"groups/unitary.jl\"]\nOrder = [:function]","category":"page"},{"location":"groups/unitary_group/#Utility-functions-and-constants","page":"Unitary group","title":"Utility functions and constants","text":"","category":"section"},{"location":"groups/unitary_group/","page":"Unitary group","title":"Unitary group","text":"LieGroups.CommonUnitarySubGroup","category":"page"},{"location":"groups/unitary_group/#LieGroups.CommonUnitarySubGroup","page":"Unitary group","title":"LieGroups.CommonUnitarySubGroup","text":"CommonUnitarySubGroup{ùîΩ,T}\n\nA constant that allows to refer to several subgroups of mathrmU(n) for implementations where\n\ncertain subgroups real/complex share a common implementation, e.g. for the same sizes T usually via TypeParameter\ncertain functions are the same for all sizes T as long as the field ùîΩ is the same\n\n\n\n\n\n","category":"type"},{"location":"groups/semidirect_product_group/#The-semidirect-product-Lie-group","page":"Semidirect product group","title":"The semidirect product Lie group","text":"","category":"section"},{"location":"groups/semidirect_product_group/","page":"Semidirect product group","title":"Semidirect product group","text":"Modules = [LieGroups]\nPages = [\"groups/semidirect_product_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/semidirect_product_group/#LieGroups.LeftSemidirectProductGroupOperation","page":"Semidirect product group","title":"LieGroups.LeftSemidirectProductGroupOperation","text":"LeftSemidirectProductGroupOperation{O1,O2,A} <: SemiDirectProductGroupOperation{O1,O2,A}\n\nA struct to model a semidirect Lie group product.\n\nLet (mathcal N ) and (mathcal H ) be two Lie groups with group operations  and , respectively, as well as a group action œÉ mathcal Hmathcal N  mathcal N, cf AbstractLeftGroupActionType.\n\nWe use here as well use the notation œÉ_h mathcal N  mathcal N as a family of maps on mathcal N\n\nThen we define a group operation  on the product manifold mathcal Nmathcal H by\n\n    (h_1n_1)  (h_2n_2) = (h_1  h_2 œÉ_h_2(n_1)  n_2)\n\nSee [HN12, Definition 9.2.22], second definition for more details.\n\nConstructor\n\nLeftSemidirectProductGroupOperation(\n    op1::AbstractGroupOperation,\n    op2::AbstractGroupOperation,\n    action::AbstractGroupActionType\n)\n\nParameters\n\nop1::AbstractGroupOperation: The group operation  on mathcal H\nop2::AbstractGroupOperation: The group operation  on mathcal N\naction::AbstractGroupActionType The group action œÉ of mathcal H on mathcal N\n\n\n\n\n\n","category":"type"},{"location":"groups/semidirect_product_group/#LieGroups.RightSemidirectProductGroupOperation","page":"Semidirect product group","title":"LieGroups.RightSemidirectProductGroupOperation","text":"RightSemidirectProductGroupOperation{O1,O2,A} <: SemiDirectProductGroupOperation{O1,O2,A}\n\nA struct to model a right semidirect Lie group product.\n\nLet (mathcal N ) and (mathcal H ) be two Lie groups with group operations  and , respectively, as well as a group action œÉ mathcal Hmathcal N  mathcal N, cf AbstractGroupActionType.\n\nWe use here as well use the notation œÉ_h mathcal N  mathcal N as a family of maps on mathcal N\n\nThen we define a group operation  on the product manifold mathcal Nmathcal H by\n\n    (n_1h_1)  (n_2h_2) = (n_1  œÉ_h_1(n_2) h_1  h_2)\n\nSee [HN12, Definition 9.2.22], first definition for more details.\n\nConstructor\n\nRightSemidirectProductGroupOperation(\n    op1::AbstractGroupOperation,\n    op2::AbstractGroupOperation,\n    action::AbstractGroupActionType\n)\n\nParameters\n\nop1::AbstractGroupOperation: The group operation  on mathcal N\nop2::AbstractGroupOperation: The group operation  on mathcal H\naction::AbstractGroupActionType: The group action œÉ of mathcal H on mathcal N\n\n\n\n\n\n","category":"type"},{"location":"groups/semidirect_product_group/#LieGroups.SemiDirectProductGroupOperation","page":"Semidirect product group","title":"LieGroups.SemiDirectProductGroupOperation","text":"SemiDirectProductGroupOperation{\n    O1<:AbstractGroupOperation,\n    O2<:AbstractGroupOperation,\n    A<:AbstractGroupActionType\n} <: AbstractProductGroupOperation\n\nAn abstract type for all semdirect product group operations.\n\n\n\n\n\n","category":"type"},{"location":"groups/semidirect_product_group/#Base.inv-Union{Tuple{M}, Tuple{Op}, Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, Op, M}, Any}} where {ùîΩ, Op<:LieGroups.SemiDirectProductGroupOperation, M<:ManifoldsBase.ProductManifold}","page":"Semidirect product group","title":"Base.inv","text":"inv(SDPG::LieGroup{ùîΩ,Op,M}, g) where {ùîΩ,Op<:SemiDirectProductGroupOperation,M<:ProductManifold}\n\nCompute the inverse element of an element g = (g_1 g_2) given by\n\ng^-1 = (g_1^-1 œÉ_g_1^-1g_2)\n\nfor the left variant and\n\ng^-1 = (œÉ_g_2^-1 g_1 g_2^-1)\n\nfor the right variant, respectively. See also [HN12, Proof of Lemma 2.2.3].\n\n\n\n\n\n","category":"method"},{"location":"groups/semidirect_product_group/#LieGroups.:‚ãâ-Tuple{LieGroup, LieGroup}","page":"Semidirect product group","title":"LieGroups.:‚ãâ","text":"L1 ‚ãâ L2\n‚ãâ(L1, L2)\n\nFor two LieGroups L1, L2, generate the LeftSemidirectProductLieGroup(L1, L2), where the corresponding default_left_action(L1, L2) is used.\n\n\n\n\n\n","category":"method"},{"location":"groups/semidirect_product_group/#LieGroups.:‚ãä-Tuple{LieGroup, LieGroup}","page":"Semidirect product group","title":"LieGroups.:‚ãä","text":"L1 ‚ãä L2\n‚ãä(L1, L2)\n\nFor two LieGroups L1, L2, generate the RightSemidirectProductLieGroup(L1, L2), where the corresponding default_right_action(L1, L2) is used.\n\n\n\n\n\n","category":"method"},{"location":"groups/semidirect_product_group/#LieGroups.LeftSemidirectProductLieGroup","page":"Semidirect product group","title":"LieGroups.LeftSemidirectProductLieGroup","text":"LeftSemidirectProductLieGroup(\n    N::LieGroup, H::LieGroup, action::AbstractGroupActionType=default_left_action(N, H)\n)\n\nGenerate the semidirect product Lie Group mathcal G = N  H for an AbstractLeftGroupActionType using the LeftSemidirectProductGroupOperation for the group operation definition as well as [HN12, Definition 9.2.22], second definition, for more details.\n\nThe short form N‚ãâH can be used if the corresponding default_left_action(N,H) is the one you want to use.\n\n\n\n\n\n","category":"function"},{"location":"groups/semidirect_product_group/#LieGroups.RightSemidirectProductLieGroup","page":"Semidirect product group","title":"LieGroups.RightSemidirectProductLieGroup","text":"RightSemidirectProductLieGroup(\n    N::LieGroup, H::LieGroup, action::AbstractGroupActionType=default_right_action(N,H)\n)\n\nGenerate the semidirect product Lie Group mathcal G = N  H for an AbstractLeftGroupActionType using the RightSemidirectProductGroupOperation for the group operation definition as well as [HN12, Definition 9.2.22], first definition, for more details.\n\nThe short form N‚ãäH can be used if the corresponding default_right_action(N,H) is the one you want to use.\n\n\n\n\n\n","category":"function"},{"location":"groups/semidirect_product_group/#Manifolds.compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, LeftSemidirectProductGroupOperation, <:ManifoldsBase.ProductManifold}, Any, Any}} where ùîΩ","page":"Semidirect product group","title":"Manifolds.compose","text":"compose(L::LieGroup{ùîΩ,LeftSemidirectProductGroupOperation}, g, h)\n\nCompute the group operation  on the semidirect product Lie group L = G  H, that is for g = (g_1h_1), h = (g_2h_2) with g_1g_2  G, h_1h_2  H this computes\n\n    (g_1h_1)  (g_2h_2) = (g_1  g_2 h_1  œÉ_g_1(h_2))\n\nwhere  denotes the group operation on L,  and  those on G and H, respectively, and œÉ is the group action specified by the AbstractGroupActionType within the LeftSemidirectProductLieGroup  L.\n\n\n\n\n\n","category":"method"},{"location":"groups/semidirect_product_group/#Manifolds.compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, RightSemidirectProductGroupOperation, <:ManifoldsBase.ProductManifold}, Any, Any}} where ùîΩ","page":"Semidirect product group","title":"Manifolds.compose","text":"compose(L::LieGroup{ùîΩ,RightSemidirectProductGroupOperation}, g, h)\n\nCompute the group operation  on the semidirect product Lie group L = G  H, that is for g = (g_1h_1), h = (g_2h_2) with g_1g_2  G, h_1h_2  H this computes\n\n    (g_1h_1)  (g_2h_2) = (g_1  œÉ_h_1(g_2) h_1  h_2)\n\nwhere  denotes the group operation on L,  and  those on G and H, respectively, and œÉ is the group action specified by the AbstractGroupActionType within the RightSemidirectProductLieGroup L.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_linear/#The-special-linear-group","page":"Special linear","title":"The special linear group","text":"","category":"section"},{"location":"groups/special_linear/","page":"Special linear","title":"Special linear","text":"Modules = [LieGroups]\nPages = [\"groups/special_linear_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/special_linear/#LieGroups.SpecialLinearGroup","page":"Special linear","title":"LieGroups.SpecialLinearGroup","text":"SpecialLinear{ùîΩ,T}\n\nThe special linear group mathrmSL(nùîΩ) is the group of all invertible matrices with unit determinant in ùîΩ^nn and the MatrixMultiplicationGroupOperation as group operation.\n\nThe Lie algebra mathfrak sl(n ùîΩ) = T_e mathrmSL(nùîΩ) is the set of all matrices in ùîΩ^nn with trace of zero. By default, tangent vectors X_p  T_p mathrmSL(nùîΩ) for p  mathrmSL(nùîΩ) are represented with their corresponding Lie algebra vector X_e = p^-1X_p  ùî∞ùî©(n ùîΩ).\n\nConstructor\n\nGeneralLinearGroup(n::Int, field=‚Ñù; kwargs...)\n\nGenerate the general linear group  group on ùîΩ^nn. All keyword arguments in kwargs... are passed on to DeterminantOneMatrices.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_linear/#ManifoldsBase.hat!-Tuple{ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, <:SpecialLinearGroup, Identity{MatrixMultiplicationGroupOperation}}, Any, Any}","page":"Special linear","title":"ManifoldsBase.hat!","text":"X = hat(ùî§::LieAlgebra{‚Ñù,MatrixMultiplicationGroupOperation,<:SpecialLinearGroup}, c)\nhat!(ùî§::LieAlgebra{‚Ñù,MatrixMultiplicationGroupOperation,<:SpecialLinearGroup}, X, c)\n\nCompute the hat map ()^wedge  ‚Ñù^n^2-1  ùî§ that turns a vector of coordinates c into a tangent vector in the Lie algebra.\n\nThe formula on the Lie algebra ùî§ of the SpecialLinearGroup(n) is given by reshaping c  ‚Ñù^n^2-1 into an n-byn matrix X with the final entry X[n,n] initialised to zero and then set to the trace of this initial matrix.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_linear/#ManifoldsBase.hat-Tuple{ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, <:SpecialLinearGroup, Identity{MatrixMultiplicationGroupOperation}}, Any}","page":"Special linear","title":"ManifoldsBase.hat","text":"X = hat(ùî§::LieAlgebra{‚Ñù,MatrixMultiplicationGroupOperation,<:SpecialLinearGroup}, c)\nhat!(ùî§::LieAlgebra{‚Ñù,MatrixMultiplicationGroupOperation,<:SpecialLinearGroup}, X, c)\n\nCompute the hat map ()^wedge  ‚Ñù^n^2-1  ùî§ that turns a vector of coordinates c into a tangent vector in the Lie algebra.\n\nThe formula on the Lie algebra ùî§ of the SpecialLinearGroup(n) is given by reshaping c  ‚Ñù^n^2-1 into an n-byn matrix X with the final entry X[n,n] initialised to zero and then set to the trace of this initial matrix.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_linear/#ManifoldsBase.vee!-Tuple{ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, <:SpecialLinearGroup, Identity{MatrixMultiplicationGroupOperation}}, Any, Any}","page":"Special linear","title":"ManifoldsBase.vee!","text":"c = vee(ùî§::LieAlgebra{‚Ñù,MatrixMultiplicationGroupOperation,<:SpecialLinearGroup}, X)\nvee!(ùî§::LieAlgebra{‚Ñù,MatrixMultiplicationGroupOperation,<:SpecialLinearGroup}, c, X)\n\nCompute the vee map ()^vee mathfrak g   ‚Ñù^n^2-1 that maps a tangent vector from the Lie algebra to a vector of coordinates c.\n\nThe formula on the Lie algebra ùî§ of the SpecialLinearGroup(n) is given by reshaping X  ‚Ñù^nn into a vector and omitting the last entry, since that can be reconstructed by considering that X has to be of trace zero.\n\nThis can be computed in-place of c.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_linear/#ManifoldsBase.vee-Tuple{ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, <:SpecialLinearGroup, Identity{MatrixMultiplicationGroupOperation}}, Any}","page":"Special linear","title":"ManifoldsBase.vee","text":"c = vee(ùî§::LieAlgebra{‚Ñù,MatrixMultiplicationGroupOperation,<:SpecialLinearGroup}, X)\nvee!(ùî§::LieAlgebra{‚Ñù,MatrixMultiplicationGroupOperation,<:SpecialLinearGroup}, c, X)\n\nCompute the vee map ()^vee mathfrak g   ‚Ñù^n^2-1 that maps a tangent vector from the Lie algebra to a vector of coordinates c.\n\nThe formula on the Lie algebra ùî§ of the SpecialLinearGroup(n) is given by reshaping X  ‚Ñù^nn into a vector and omitting the last entry, since that can be reconstructed by considering that X has to be of trace zero.\n\nThis can be computed in-place of c.\n\n\n\n\n\n","category":"method"},{"location":"groups/general_linear/#The-general-linear-group","page":"General linear group","title":"The general linear group","text":"","category":"section"},{"location":"groups/general_linear/","page":"General linear group","title":"General linear group","text":"Modules = [LieGroups]\nPages = [\"groups/general_linear_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/general_linear/#LieGroups.GeneralLinearGroup","page":"General linear group","title":"LieGroups.GeneralLinearGroup","text":"GeneralLinearGroup{ùîΩ,T}\n\nThe general linear group mathrmGL(n) is the set of all invertible matrices\n\nmathrmGL(n) = bigl M  ùîΩ^nn big mathrmdet(M)  0bigr \nqquad ùîΩ   ‚Ñù ‚ÑÇ \n\nequipped with the MatrixMultiplicationGroupOperation as the group operation.\n\nThe set of invertible matrices is a Riemannian manifold, since it inherits its structure from the embedding as an open subset of the space of matrices ‚Ñù^nn.\n\nConstructor\n\nGeneralLinearGroup(n::Int; field=‚Ñù, kwargs...)\n\nGenerate the general linear group on ùîΩ^nn. All keyword arguments in kwargs... are passed on to InvertibleMatrices.\n\n\n\n\n\n","category":"type"},{"location":"groups/general_linear/#Base.exp-Tuple{GeneralLinearGroup, Any}","page":"General linear group","title":"Base.exp","text":"exp(::GeneralLinearGroup, X)\nexp!(::GeneralLinearGroup, g, X)\n\nCompute the Lie group exponential on the GeneralLinearGroup, which is given by the matrix exponential\n\nexp X = sum_k=0^ frac1kX^k\n\nsee also [HN12, Example 9.2.3 (b)]\n\n\n\n\n\n","category":"method"},{"location":"groups/general_linear/#ManifoldsBase.exp!-Tuple{GeneralLinearGroup, Any, Any}","page":"General linear group","title":"ManifoldsBase.exp!","text":"exp(::GeneralLinearGroup, X)\nexp!(::GeneralLinearGroup, g, X)\n\nCompute the Lie group exponential on the GeneralLinearGroup, which is given by the matrix exponential\n\nexp X = sum_k=0^ frac1kX^k\n\nsee also [HN12, Example 9.2.3 (b)]\n\n\n\n\n\n","category":"method"},{"location":"groups/symplectic_group/#The-symplectic-group","page":"Symplectic group","title":"The symplectic group","text":"","category":"section"},{"location":"groups/symplectic_group/","page":"Symplectic group","title":"Symplectic group","text":"SymplecticGroup","category":"page"},{"location":"groups/symplectic_group/#LieGroups.SymplecticGroup","page":"Symplectic group","title":"LieGroups.SymplecticGroup","text":"SymplecticGroup{T}\n\nThe manifold of real symplectic matrices, of size 2n2n for some n‚Ñï is given by\n\nmathrmSp(2n ‚Ñù) = bigl p  ‚Ñù^2n2n big p^mathrmTJ_2np = J_2nbigr \n\nwhere J_2n = beginpmatrix 0_n  I_n -I_n  0_nendpmatrix denotes the SymplecticElement.\n\nThis yields the SymplecticGroup together with the MatrixMultiplicationGroupOperation as the group operation.\n\nThe corresponding Lie algebra is given by the HamiltonianMatrices\n\nmathfrak so(2n ‚Ñù) = bigl X  ‚Ñù^2n2n big X^+ = -Xbigr \n\nwhere ^+ denotes the symplectic_inverse.\n\nSee [BZ21, Section 2] for more information.\n\n\n\n\n\n","category":"type"},{"location":"groups/symplectic_group/#Literature","page":"Symplectic group","title":"Literature","text":"","category":"section"},{"location":"groups/symplectic_group/","page":"Symplectic group","title":"Symplectic group","text":"T.¬†Bendokat and R.¬†Zimmermann. The real symplectic Stiefel and Grassmann manifolds: metrics, geodesics and applications, arXiv¬†Preprint,¬†2108.12447 (2021), arXiv:2108.12447.\n\n\n\n","category":"page"},{"location":"groups/#An-overview-of-Lie-groups","page":"List of Lie groups","title":"An overview of Lie groups","text":"","category":"section"},{"location":"groups/","page":"List of Lie groups","title":"List of Lie groups","text":"Group Manifold  Comment\nCircleGroup real or complex Circle, Sphere * \nGeneralLinearGroup InvertibleMatrices * \nHeisenbergGroup HeisenbergMatrices * \nOrthogonalGroup OrthogonalMatrices * This can be interpreted as all rotations and reflections.\nPowerLieGroup PowerManifold ‚àò ^ is a constructor\nProductLieGroup ProductManifold ‚àò √ó of two Lie groups is a constructor\nLeftSemidirectProductLieGroup ProductManifold ‚àò ‚ãâ of 2 Lie groups is a constructor, similarly ‚ãä for the right variant\nSpecialEuclideanGroup Rotations‚ãâEuclidean ‚àò Analogously you can also use a ‚ãä if you prefer tuples (t,R) having the rotation matrix in the second component\nSpecialLinearGroup DeterminantOneMatrices * \nSpecialOrthogonalGroup Rotations * \nSpecialUnitaryGroup GeneralUnitaryMatrices * \nSymplecticGroup SymplecticMatrices * \nTranslationGroup Euclidean + \nUnitaryGroup UnitaryMatrices * ","category":"page"},{"location":"groups/power_group/#The-power-Lie-group","page":"Power group","title":"The power Lie group","text":"","category":"section"},{"location":"groups/power_group/","page":"Power group","title":"Power group","text":"Modules = [LieGroups]\nPages = [\"groups/power_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/power_group/#LieGroups.PowerGroupOperation","page":"Power group","title":"LieGroups.PowerGroupOperation","text":"PowerGroupOperation{O<:AbstractGroupOperation} <: AbstractGroupOperation\n\nA struct do model a that a certain group operation is applied element-wise on a PowerManifold.\n\nConstructor\n\nPowerGroupOperation(o::AbstractGroupOperation)\n\n\n\n\n\n","category":"type"},{"location":"groups/power_group/#LieGroups.PowerLieGroup-Tuple{ManifoldsBase.AbstractManifold, Vararg{Any}}","page":"Power group","title":"LieGroups.PowerLieGroup","text":"PowerLieGroup(G::LieGroup, args...; kwargs...)\n(G::LieGroup)^(n::Integer) = PowerLieGroup(G, n)\n\nGenerate the LieGroup of the n-th power of a Lie group G or manifold M. If passed a Lie group G, the group operation on the PowerLieGroup is the same as on G, but applied elementwise. Internally, the corresponding PowerGroupOperation is created. If you pass a manifold M, you have to provide the corresponding PowerGroupOperation yourself.\n\nBot the arguments args... as well as the keyword arguments kwargs... are passed on to the constructor of the PowerManifold. This especially includes the size of the manifold and allows to specify a NestedPowerRepresentation.\n\n\n\n\n\n","category":"method"},{"location":"groups/power_group/","page":"Power group","title":"Power group","text":"On power Lie groups, all functions work element-wise, so for their formulae, check the corresponding single Lie group for details.","category":"page"},{"location":"groups/heisenberg_group/#The-Heisenberg-group","page":"Heisenberg group","title":"The Heisenberg group","text":"","category":"section"},{"location":"groups/heisenberg_group/","page":"Heisenberg group","title":"Heisenberg group","text":"Modules = [LieGroups]\nPages = [\"groups/heisenberg_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/heisenberg_group/#LieGroups.HeisenbergGroup","page":"Heisenberg group","title":"LieGroups.HeisenbergGroup","text":"HeisenbergGroup{T}\n\nThe HeisenbergGroup(n) is the group of (n+2)(n+2) matrices, see also [BP08] or Heisenberg group where T specifies the eltype of the matrix entries.\n\nbeginpmatrix 1  mathbfa^mathrmT  c mathbf0_n  I_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix\n\nwhere I_n is the nn unit matrix, mathbfa mathbfb  ‚Ñù^n are vectors of length n, mathbf0_n is the zero vector of length n, and c  ‚Ñù is a real number. The group operation is matrix multiplication.\n\nThe Lie algebra consists of the elements\n\nbeginpmatrix 0  mathbfa^mathrmT  c mathbf0_n  Z_n  mathbfb 0  mathbf0_n^mathrmT  0endpmatrix\n\nwhere additionally Z_n denotes the nn zero matrix.\n\n\n\n\n\n","category":"type"},{"location":"groups/heisenberg_group/#Base.exp-Tuple{HeisenbergGroup, Any, Any}","page":"Heisenberg group","title":"Base.exp","text":"exp(G::HeisenbergGroup, g, X)\n\nExponential map on the HeisenbergGroup G with the left-invariant metric.\n\nWe denote by g a point on the Heisenberg group and by X a vector from the Lie algebra. These are of the form\n\ng = beginpmatrix 1  mathbfa^mathrmT  c mathbf0_n  I_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix\nqquad\nX = beginpmatrix 0  mathbfd^mathrmT  f mathbf0_n  Z_n  mathbfe 0  mathbf0_n^mathrmT  0endpmatrix\n\nwhere I_n is the nn unit matrix, Z_n is the nn zero matrix, mathbfa mathbfb mathbfd mathbfe  ‚Ñù^n are vectors of length n, mathbf0_n is the zero vector of length n, and cf  ‚Ñù are real numbers.\n\nThen the formula reads\n\nexp_g(X) =\nbeginpmatrix 1  (mathbfa+mathbfd)^mathrmT  c+f+frac12mathbfd^mathrmTmathbfe + mathbfa^mathrmTmathbfe mathbf0_n  I_n  mathbfb+mathbfe 0  mathbf0_n^mathrmT  1endpmatrix\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#Base.exp-Tuple{HeisenbergGroup, Any}","page":"Heisenberg group","title":"Base.exp","text":"exp(G::HeisenbergGroup, X)\nexp!(G::HeisenbergGroup, g, X)\n\nCompute the Lie group exponential for the HeisenbergGroup G of the vector X.\n\nFor X = beginpmatrix 0  mathbfa^mathrmT  c mathbf0_n  Z_n  mathbfb 0  mathbf0_n^mathrmT  0endpmatrix from the Lie algebra of the Heisenberg group, where mathbfa mathbfb  ‚Ñù^n vectors of length n, mathbf0_n is the zero vector of length n, c  ‚Ñù, and Z_n denotes the nn zero matrix.\n\nThen the\n\nexp_mathcal G(X) =\nbeginpmatrix 1  mathbfa^mathrmT  c + frac12mathbfa^mathrmTmathbfb mathbf0_n  I_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix\n\nwhere I_n is the nn unit matrix.\n\nThis can be computed in-place of the Lie group element g.\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#Base.log-Tuple{HeisenbergGroup, Any, Any}","page":"Heisenberg group","title":"Base.log","text":"log(G::HeisenbergGroup, g, h)\n\nCompute the logarithmic map on the HeisenbergGroup group.\n\nWe denote two points g h from the Heisenberg by\n\ng = beginpmatrix 1  mathbfa^mathrmT  c mathbf0_n  I_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix\nqquad\nh = beginpmatrix 1  mathbfd^mathrmT  f mathbf0_n  I_n  mathbfe 0  mathbf0_n^mathrmT  1endpmatrix\n\nwhere I_n is the nn unit matrix, mathbfa mathbfb mathbfd mathbfe  ‚Ñù^n are vectors of length n, mathbf0_n is the zero vector of length n, and cf  ‚Ñù are real numbers.\n\nThen formula reads\n\nlog_g(h) = beginpmatrix 0  (mathbfd-mathbfq)^mathrmT  f - c + mathbfa^mathrmTmathbfb - mathbfd^mathrmTmathbfe - frac12(mathbfd-mathbfa)^mathrmT(mathbfe-mathbfb) mathbf0_n  Z_n  mathbfe - mathbfb 0  mathbf0_n^mathrmT  0endpmatrix\n\nwhere additionally Z_n denotes the nn zero matrix.\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#Base.log-Tuple{HeisenbergGroup, Any}","page":"Heisenberg group","title":"Base.log","text":"log(G::HeisenbergGroup, g)\nlog!(G::HeisenbergGroup, X, g)\n\nCompute the Lie group logarithm for the HeisenbergGroup G.\n\nFor g = beginpmatrix 1  mathbfa^mathrmT  c mathbf0_n  I_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix from the Lie algebra of the Heisenberg group, where mathbfa mathbfb  ‚Ñù^n vectors of length n, mathbf0_n is the zero vector of length n, c  ‚Ñù, and I_n is the nn unit matrix.\n\nThen the\n\nlog_mathcal G(g) =\nbeginpmatrix 1  mathbfa^mathrmT  c - frac12mathbfa^mathrmTmathbfb mathbf0_n  Z_n  mathbfb 0  mathbf0_n^mathrmT  1endpmatrix\n\nwhere Z_n denotes the nn zero matrix.\n\nThis can be computed in-place of the Lie algebra vector X.\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#ManifoldsBase.injectivity_radius-Tuple{HeisenbergGroup}","page":"Heisenberg group","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(G::HeisenbergGroup)\n\nReturn the injectivity radius on the HeisenbergGroup G, which is .\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#Literature","page":"Heisenberg group","title":"Literature","text":"","category":"section"},{"location":"groups/heisenberg_group/","page":"Heisenberg group","title":"Heisenberg group","text":"E.¬†Biny and S.¬†Pods. The Geometry of Heisenberg Groups: With Applications in Signal Theory, Optics, Quantization, and Field Quantization (American Mathematical Society, 2008).\n\n\n\n","category":"page"},{"location":"groups/product_group/#The-product-Lie-group","page":"Product group","title":"The product Lie group","text":"","category":"section"},{"location":"groups/product_group/","page":"Product group","title":"Product group","text":"Modules = [LieGroups]\nPages = [\"groups/product_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/product_group/#LieGroups.AbstractProductGroupOperation","page":"Product group","title":"LieGroups.AbstractProductGroupOperation","text":"AbstractProductGroupOperation <: AbstractGroupOperation\n\nAn abstract type to model group operations on a product manifold\n\n\n\n\n\n","category":"type"},{"location":"groups/product_group/#LieGroups.ProductGroupOperation","page":"Product group","title":"LieGroups.ProductGroupOperation","text":"ProductGroupOperation{O<:NTuple{N,AbstractGroupOperation} where N} <: AbstractProductGroupOperation\n\nA struct do model a tuple of group operations, one for each factor of a product group, that together forms a new group operation.\n\nAccess to the single operations can be done by pgo[i].\n\nConstructor\n\nProductGroupOperation(o::AbstractGroupOperation...)\n√ó(o::AbstractGroupOperation...) = ProductGroupOperation(o...)\n\n\n\n\n\n","category":"type"},{"location":"groups/product_group/#LieGroups.ProductLieGroup-Tuple{LieGroup, LieGroup}","page":"Product group","title":"LieGroups.ProductLieGroup","text":"ProductLieGroup(G, H, ...)\n\nReturn the LieGroup of the product of Lie groups G and H.\n\nAlternatively, the short hand G √ó H can be used.\n\n\n\n\n\n","category":"method"},{"location":"groups/product_group/#LinearAlgebra.cross-Tuple{Vararg{AbstractGroupOperation}}","page":"Product group","title":"LinearAlgebra.cross","text":"cross(O1::AbstractGroupOperation, O2::AbstractGroupOperation)\nO1 √ó O2\nO1 √ó O2 √ó O3 √ó ...\n\nReturn the ProductGroupOperation For two AbstractGroupOperation` O1 and O2, where for the case that one of them is a ProductGroupOperation itself, the other is either prepended (if O1 is a product) or appended (if O2 is). If both are product operations, they are combined into one, keeping the order of operations.\n\nFor the case that more than two are concatenated with √ó this is iterated.\n\n\n\n\n\n","category":"method"},{"location":"groups/product_group/#LinearAlgebra.cross-Tuple{Vararg{LieGroup}}","page":"Product group","title":"LinearAlgebra.cross","text":"cross(G::LieGroup, H::LieGroup)\nG √ó H\nG1 √ó G2 √ó G3 √ó ...\n\nReturn the ProductLieGroup For two LieGroups G and H, where for the case that one of them is a ProductLieGroup itself, the other is either prepended (if H is a product) or appended (if G is). If both are product Lie groups, they are combined into one, keeping the order of operations.\n\nFor the case that more than two are concatenated with √ó this is iterated.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#The-special-orthogonal-group","page":"Special orthogonal group","title":"The special orthogonal group","text":"","category":"section"},{"location":"groups/special_orthogonal_group/","page":"Special orthogonal group","title":"Special orthogonal group","text":"SpecialOrthogonalGroup","category":"page"},{"location":"groups/special_orthogonal_group/#LieGroups.SpecialOrthogonalGroup","page":"Special orthogonal group","title":"LieGroups.SpecialOrthogonalGroup","text":"SpecialOrthogonalGroup{T}\n\nThe special orthogonal group mathrmSO(n) is the Lie group consisting of the MatrixMultiplicationGroupOperation on the manifold of rotations Rotations.\n\nConstructor\n\nSpecialOrthogonalGroup(n::Int; kwargs...)\n\nGenerate  special orthogonal group mathrmSO(n). All keyword arguments in kwargs... are passed on to Rotations as well.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_orthogonal_group/","page":"Special orthogonal group","title":"Special orthogonal group","text":"For this Lie group, several implementations are already covered by the defaults in the generic (matrix) multiplication operation.","category":"page"},{"location":"groups/special_orthogonal_group/#Functions","page":"Special orthogonal group","title":"Functions","text":"","category":"section"},{"location":"groups/special_orthogonal_group/","page":"Special orthogonal group","title":"Special orthogonal group","text":"Modules = [LieGroups]\nPages = [\"groups/special_orthogonal_group.jl\"]\nOrder = [:function]","category":"page"},{"location":"groups/special_orthogonal_group/#Base.exp-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any}","page":"Special orthogonal group","title":"Base.exp","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, these simplify for the case of 22 matrices to X=beginpmatrix 0  -Œ± Œ±  0endpmatrix, for some Œ±‚Ñù.\n\nTheir exponential is\n\nexp_mathcal G(X) =  beginpmatrix cos(Œ±)  -sin(Œ±) sin(Œ±)  cos(Œ±)endpmatrix\n\nThis result can be computed in-place of g.\n\nNote that since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#Base.exp-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any}","page":"Special orthogonal group","title":"Base.exp","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, the 33 skew symmetric matrices are of the form\n\n    X = beginpmatrix 0  -c  b c  0  -a -b  a  0endpmatrix\n\nfor some a b c  ‚Ñù. To compute the exponential, the Rodrigues' rotation formula can be used. With Œ± = sqrta^2+b^2+c^2 = frac1sqrt2lVert X rVert_ we obtain for Œ±  0\n\nexp_mathcal G(X) = I_3 + fracsinŒ±X + frac(1 - cos)Œ±^2X^2\n\nand \\exp{\\mathcal G}(X) = I3`` otherwise.\n\nThis result can be computed in-place of g.\n\nNote that since mathrmSO(3) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#Base.exp-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any}","page":"Special orthogonal group","title":"Base.exp","text":"exp(G, e, X)\nexp!(G, e, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSimilar to the 33 case, an efficient computation is provided, adapted from [GX02], [AR13] with a few numerical stabilisations.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#Base.log-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any}","page":"Special orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nFor the two-dimensional case, any rotation matrix g can be represented as beginpmatrix cos(Œ±)  -sin(Œ±) sin(Œ±)  cos(Œ±)endpmatrix. For the SpecialOrthogonalGroup, g might also include reflections.\n\nThe logarithm is then\n\nlog_mathcal G(g) =  beginpmatrix 0  Œ± -Œ±  0endpmatrix\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#Base.log-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any}","page":"Special orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nHere, exp_mathcal G(X) = g is inverted using the Rodrigues' rotation formula\n\nexp_mathcal G(X) = I_3 + fracsinŒ±X + frac(1 - cos)Œ±^2X^2\n\nFor Œ±   0 œÄ  we obtain X from the observation that\n\nmathrmtr(g) = 1 + 2cos(Œ±)\nqquadtext and qquad\nfrac12(g-g^mathrmT) = sin(Œ±)X\n\nFor Œ± = 0 we have g = I_3 and X = 0.\n\nFor Œ± = œÄ we have to solve X^2 = frac12(g-I_3), where X is skew-symmetric and hence we have to solve for three unknowns.\n\nlog_mathcal G(g) = X\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(3) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#Base.log-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any}","page":"Special orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nThe implementation is based on a generalized variant of the Rodrigues' like formula. For details, see [GX02, Section 3].\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.exp!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, these simplify for the case of 22 matrices to X=beginpmatrix 0  -Œ± Œ±  0endpmatrix, for some Œ±‚Ñù.\n\nTheir exponential is\n\nexp_mathcal G(X) =  beginpmatrix cos(Œ±)  -sin(Œ±) sin(Œ±)  cos(Œ±)endpmatrix\n\nThis result can be computed in-place of g.\n\nNote that since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.exp!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, the 33 skew symmetric matrices are of the form\n\n    X = beginpmatrix 0  -c  b c  0  -a -b  a  0endpmatrix\n\nfor some a b c  ‚Ñù. To compute the exponential, the Rodrigues' rotation formula can be used. With Œ± = sqrta^2+b^2+c^2 = frac1sqrt2lVert X rVert_ we obtain for Œ±  0\n\nexp_mathcal G(X) = I_3 + fracsinŒ±X + frac(1 - cos)Œ±^2X^2\n\nand \\exp{\\mathcal G}(X) = I3`` otherwise.\n\nThis result can be computed in-place of g.\n\nNote that since mathrmSO(3) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.exp!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, e, X)\nexp!(G, e, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSimilar to the 33 case, an efficient computation is provided, adapted from [GX02], [AR13] with a few numerical stabilisations.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.get_coordinates!-Tuple{SpecialOrthogonalGroup, Any, Identity{MatrixMultiplicationGroupOperation}, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Special orthogonal group","title":"ManifoldsBase.get_coordinates!","text":"get_coordinates(ùî§::OrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates(G::SpecialOrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::OrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::SpecialOrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the vector of coordinates c  ‚Ñù^d from the Lie algebra tangent vector X  ùî¨(n) of the OrthogonalGroup O(n) in the DefaultLieAlgebraOrthogonalBasis, where d is the dimension of the Lie algebra. This is also the version used in vee.\n\nFor O(2) there is only one coefficient Œ± in the basis beginpmatrix 0  -Œ± Œ±  0endpmatrix, which is returned as c = (Œ±)^mathrmT.\n\nA usual basis representation of ``ùî¨(3) is given by\n\n    X = beginpmatrix 0  -Œ≥  Œ≤ Œ≥  0  -Œ± -Œ≤  Œ±  0endpmatrix\n\nhence the coordinate vector is c = (Œ± Œ≤ Œ≥)^mathrmT  ‚Ñù^3.\n\nFor n ‚â• 4the lower triangular part is added toc` row-wise.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.get_coordinates-Tuple{SpecialOrthogonalGroup, Identity{MatrixMultiplicationGroupOperation}, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Special orthogonal group","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(ùî§::OrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates(G::SpecialOrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::OrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::SpecialOrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the vector of coordinates c  ‚Ñù^d from the Lie algebra tangent vector X  ùî¨(n) of the OrthogonalGroup O(n) in the DefaultLieAlgebraOrthogonalBasis, where d is the dimension of the Lie algebra. This is also the version used in vee.\n\nFor O(2) there is only one coefficient Œ± in the basis beginpmatrix 0  -Œ± Œ±  0endpmatrix, which is returned as c = (Œ±)^mathrmT.\n\nA usual basis representation of ``ùî¨(3) is given by\n\n    X = beginpmatrix 0  -Œ≥  Œ≤ Œ≥  0  -Œ± -Œ≤  Œ±  0endpmatrix\n\nhence the coordinate vector is c = (Œ± Œ≤ Œ≥)^mathrmT  ‚Ñù^3.\n\nFor n ‚â• 4the lower triangular part is added toc` row-wise.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.get_vector!-Tuple{SpecialOrthogonalGroup, Any, Identity{MatrixMultiplicationGroupOperation}, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Special orthogonal group","title":"ManifoldsBase.get_vector!","text":"get_vector(G::OrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector(G::SpecialOrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::OrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::SpecialOrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the tangent vector X  ùî¨(n) based on a vector of coordinates c  ‚Ñù^d, where d is the dimension of the Lie algebra of the OrthogonalGroup O(n) and the coordinates are with respect to the DefaultLieAlgebraOrthogonalBasis. This is also the version used in hat.\n\nFor O(2) there is only one coefficient ``c = (Œ±)^mathrmT and hence X = beginpmatrix 0  -Œ± Œ±  0endpmatrix is returned.\n\nFor n=3 a usual representtion turns c = (Œ± Œ≤ Œ≥)^mathrmT  ‚Ñù^3 into\n\n    X = beginpmatrix 0  -Œ≥  Œ≤ Œ≥  0  -Œ± -Œ≤  Œ±  0endpmatrix\n\nhence the coordinate vector is .\n\nFor n ‚â• 4` all further coefficients are used to fill up the following rows of the lower triangular part ‚Äì which determines the upper triangular part due to skew-symmetry\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.get_vector-Tuple{SpecialOrthogonalGroup, Identity{MatrixMultiplicationGroupOperation}, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Special orthogonal group","title":"ManifoldsBase.get_vector","text":"get_vector(G::OrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector(G::SpecialOrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::OrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::SpecialOrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the tangent vector X  ùî¨(n) based on a vector of coordinates c  ‚Ñù^d, where d is the dimension of the Lie algebra of the OrthogonalGroup O(n) and the coordinates are with respect to the DefaultLieAlgebraOrthogonalBasis. This is also the version used in hat.\n\nFor O(2) there is only one coefficient ``c = (Œ±)^mathrmT and hence X = beginpmatrix 0  -Œ± Œ±  0endpmatrix is returned.\n\nFor n=3 a usual representtion turns c = (Œ± Œ≤ Œ≥)^mathrmT  ‚Ñù^3 into\n\n    X = beginpmatrix 0  -Œ≥  Œ≤ Œ≥  0  -Œ± -Œ≤  Œ±  0endpmatrix\n\nhence the coordinate vector is .\n\nFor n ‚â• 4` all further coefficients are used to fill up the following rows of the lower triangular part ‚Äì which determines the upper triangular part due to skew-symmetry\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.log!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{2}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nFor the two-dimensional case, any rotation matrix g can be represented as beginpmatrix cos(Œ±)  -sin(Œ±) sin(Œ±)  cos(Œ±)endpmatrix. For the SpecialOrthogonalGroup, g might also include reflections.\n\nThe logarithm is then\n\nlog_mathcal G(g) =  beginpmatrix 0  Œ± -Œ±  0endpmatrix\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.log!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{3}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nHere, exp_mathcal G(X) = g is inverted using the Rodrigues' rotation formula\n\nexp_mathcal G(X) = I_3 + fracsinŒ±X + frac(1 - cos)Œ±^2X^2\n\nFor Œ±   0 œÄ  we obtain X from the observation that\n\nmathrmtr(g) = 1 + 2cos(Œ±)\nqquadtext and qquad\nfrac12(g-g^mathrmT) = sin(Œ±)X\n\nFor Œ± = 0 we have g = I_3 and X = 0.\n\nFor Œ± = œÄ we have to solve X^2 = frac12(g-I_3), where X is skew-symmetric and hence we have to solve for three unknowns.\n\nlog_mathcal G(g) = X\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(3) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/special_orthogonal_group/#ManifoldsBase.log!-Tuple{SpecialOrthogonalGroup{ManifoldsBase.TypeParameter{Tuple{4}}}, Any, Any}","page":"Special orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nThe implementation is based on a generalized variant of the Rodrigues' like formula. For details, see [GX02, Section 3].\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#The-orthogonal-group","page":"Orthogonal group","title":"The orthogonal group","text":"","category":"section"},{"location":"groups/orthogonal_group/","page":"Orthogonal group","title":"Orthogonal group","text":"OrthogonalGroup","category":"page"},{"location":"groups/orthogonal_group/#LieGroups.OrthogonalGroup","page":"Orthogonal group","title":"LieGroups.OrthogonalGroup","text":"OrthogonalGroup{T}\n\nThe orthogonal group mathrmO(n) is the Lie group consisting of the MatrixMultiplicationGroupOperation on the manifold of rotations OrthogonalMatrices.\n\nConstructor\n\nOrthogonalGroup(n::Int; kwargs...)\n\nGenerate  orthogonal group mathrmO(n). All keyword arguments in kwargs... are passed on to OrthogonalMatrices as well.\n\n\n\n\n\n","category":"type"},{"location":"groups/orthogonal_group/","page":"Orthogonal group","title":"Orthogonal group","text":"For this Lie group, several implementations are already covered by the defaults in the generic (matrix) multiplication operation.","category":"page"},{"location":"groups/orthogonal_group/#Functions","page":"Orthogonal group","title":"Functions","text":"","category":"section"},{"location":"groups/orthogonal_group/","page":"Orthogonal group","title":"Orthogonal group","text":"Modules = [LieGroups]\nPages = [\"groups/orthogonal_group.jl\"]\nOrder = [:function]","category":"page"},{"location":"groups/orthogonal_group/#Base.exp-Tuple{LieGroup{‚Ñù, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ManifoldsBase.TypeParameter{Tuple{2}}, ‚Ñù, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any}","page":"Orthogonal group","title":"Base.exp","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, these simplify for the case of 22 matrices to X=beginpmatrix 0  -Œ± Œ±  0endpmatrix, for some Œ±‚Ñù.\n\nTheir exponential is\n\nexp_mathcal G(X) =  beginpmatrix cos(Œ±)  -sin(Œ±) sin(Œ±)  cos(Œ±)endpmatrix\n\nThis result can be computed in-place of g.\n\nNote that since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Base.exp-Tuple{LieGroup{‚Ñù, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ManifoldsBase.TypeParameter{Tuple{3}}, ‚Ñù, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any}","page":"Orthogonal group","title":"Base.exp","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, the 33 skew symmetric matrices are of the form\n\n    X = beginpmatrix 0  -c  b c  0  -a -b  a  0endpmatrix\n\nfor some a b c  ‚Ñù. To compute the exponential, the Rodrigues' rotation formula can be used. With Œ± = sqrta^2+b^2+c^2 = frac1sqrt2lVert X rVert_ we obtain for Œ±  0\n\nexp_mathcal G(X) = I_3 + fracsinŒ±X + frac(1 - cos)Œ±^2X^2\n\nand \\exp{\\mathcal G}(X) = I3`` otherwise.\n\nThis result can be computed in-place of g.\n\nNote that since mathrmSO(3) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Base.exp-Tuple{LieGroup{‚Ñù, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ManifoldsBase.TypeParameter{Tuple{4}}, ‚Ñù, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any}","page":"Orthogonal group","title":"Base.exp","text":"exp(G, e, X)\nexp!(G, e, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSimilar to the 33 case, an efficient computation is provided, adapted from [GX02], [AR13] with a few numerical stabilisations.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Base.log-Tuple{LieGroup{‚Ñù, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ManifoldsBase.TypeParameter{Tuple{2}}, ‚Ñù, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any}","page":"Orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nFor the two-dimensional case, any rotation matrix g can be represented as beginpmatrix cos(Œ±)  -sin(Œ±) sin(Œ±)  cos(Œ±)endpmatrix. For the SpecialOrthogonalGroup, g might also include reflections.\n\nThe logarithm is then\n\nlog_mathcal G(g) =  beginpmatrix 0  Œ± -Œ±  0endpmatrix\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Base.log-Tuple{LieGroup{‚Ñù, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ManifoldsBase.TypeParameter{Tuple{3}}, ‚Ñù, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any}","page":"Orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nHere, exp_mathcal G(X) = g is inverted using the Rodrigues' rotation formula\n\nexp_mathcal G(X) = I_3 + fracsinŒ±X + frac(1 - cos)Œ±^2X^2\n\nFor Œ±   0 œÄ  we obtain X from the observation that\n\nmathrmtr(g) = 1 + 2cos(Œ±)\nqquadtext and qquad\nfrac12(g-g^mathrmT) = sin(Œ±)X\n\nFor Œ± = 0 we have g = I_3 and X = 0.\n\nFor Œ± = œÄ we have to solve X^2 = frac12(g-I_3), where X is skew-symmetric and hence we have to solve for three unknowns.\n\nlog_mathcal G(g) = X\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(3) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Base.log-Tuple{LieGroup{‚Ñù, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ManifoldsBase.TypeParameter{Tuple{4}}, ‚Ñù, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any}","page":"Orthogonal group","title":"Base.log","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nThe implementation is based on a generalized variant of the Rodrigues' like formula. For details, see [GX02, Section 3].\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.exp!-Tuple{LieGroup{‚Ñù, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ManifoldsBase.TypeParameter{Tuple{2}}, ‚Ñù, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, these simplify for the case of 22 matrices to X=beginpmatrix 0  -Œ± Œ±  0endpmatrix, for some Œ±‚Ñù.\n\nTheir exponential is\n\nexp_mathcal G(X) =  beginpmatrix cos(Œ±)  -sin(Œ±) sin(Œ±)  cos(Œ±)endpmatrix\n\nThis result can be computed in-place of g.\n\nNote that since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.exp!-Tuple{LieGroup{‚Ñù, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ManifoldsBase.TypeParameter{Tuple{3}}, ‚Ñù, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, X)\nexp!(G, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSince the Lie algebra of both groups agrees and consist of the set of skew symmetric matrices, the 33 skew symmetric matrices are of the form\n\n    X = beginpmatrix 0  -c  b c  0  -a -b  a  0endpmatrix\n\nfor some a b c  ‚Ñù. To compute the exponential, the Rodrigues' rotation formula can be used. With Œ± = sqrta^2+b^2+c^2 = frac1sqrt2lVert X rVert_ we obtain for Œ±  0\n\nexp_mathcal G(X) = I_3 + fracsinŒ±X + frac(1 - cos)Œ±^2X^2\n\nand \\exp{\\mathcal G}(X) = I3`` otherwise.\n\nThis result can be computed in-place of g.\n\nNote that since mathrmSO(3) consists of two disjoint connected components and the exponential map is smooth, the result g always lies in the connected component of the identity.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.exp!-Tuple{LieGroup{‚Ñù, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ManifoldsBase.TypeParameter{Tuple{4}}, ‚Ñù, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.exp!","text":"exp(G, e, X)\nexp!(G, e, g, X)\n\nCompute the Lie group exponential function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nSimilar to the 33 case, an efficient computation is provided, adapted from [GX02], [AR13] with a few numerical stabilisations.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.get_coordinates!-Tuple{ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, LieGroup{‚Ñù, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{T, ‚Ñù, Manifolds.AbsoluteDeterminantOneMatrixType}}, Identity{MatrixMultiplicationGroupOperation}} where T, Any, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Orthogonal group","title":"ManifoldsBase.get_coordinates!","text":"get_coordinates(ùî§::OrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates(G::SpecialOrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::OrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::SpecialOrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the vector of coordinates c  ‚Ñù^d from the Lie algebra tangent vector X  ùî¨(n) of the OrthogonalGroup O(n) in the DefaultLieAlgebraOrthogonalBasis, where d is the dimension of the Lie algebra. This is also the version used in vee.\n\nFor O(2) there is only one coefficient Œ± in the basis beginpmatrix 0  -Œ± Œ±  0endpmatrix, which is returned as c = (Œ±)^mathrmT.\n\nA usual basis representation of ``ùî¨(3) is given by\n\n    X = beginpmatrix 0  -Œ≥  Œ≤ Œ≥  0  -Œ± -Œ≤  Œ±  0endpmatrix\n\nhence the coordinate vector is c = (Œ± Œ≤ Œ≥)^mathrmT  ‚Ñù^3.\n\nFor n ‚â• 4the lower triangular part is added toc` row-wise.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.get_coordinates-Tuple{ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, LieGroup{‚Ñù, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{T, ‚Ñù, Manifolds.AbsoluteDeterminantOneMatrixType}}, Identity{MatrixMultiplicationGroupOperation}} where T, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Orthogonal group","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(ùî§::OrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates(G::SpecialOrthogonalLieAlgebra, X, ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::OrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\nget_coordinates!(G::SpecialOrthogonalLieAlgebra, c, X ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the vector of coordinates c  ‚Ñù^d from the Lie algebra tangent vector X  ùî¨(n) of the OrthogonalGroup O(n) in the DefaultLieAlgebraOrthogonalBasis, where d is the dimension of the Lie algebra. This is also the version used in vee.\n\nFor O(2) there is only one coefficient Œ± in the basis beginpmatrix 0  -Œ± Œ±  0endpmatrix, which is returned as c = (Œ±)^mathrmT.\n\nA usual basis representation of ``ùî¨(3) is given by\n\n    X = beginpmatrix 0  -Œ≥  Œ≤ Œ≥  0  -Œ± -Œ≤  Œ±  0endpmatrix\n\nhence the coordinate vector is c = (Œ± Œ≤ Œ≥)^mathrmT  ‚Ñù^3.\n\nFor n ‚â• 4the lower triangular part is added toc` row-wise.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.get_vector!-Tuple{ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, LieGroup{‚Ñù, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{T, ‚Ñù, Manifolds.AbsoluteDeterminantOneMatrixType}}, Identity{MatrixMultiplicationGroupOperation}} where T, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Orthogonal group","title":"ManifoldsBase.get_vector!","text":"get_vector(G::OrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector(G::SpecialOrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::OrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::SpecialOrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the tangent vector X  ùî¨(n) based on a vector of coordinates c  ‚Ñù^d, where d is the dimension of the Lie algebra of the OrthogonalGroup O(n) and the coordinates are with respect to the DefaultLieAlgebraOrthogonalBasis. This is also the version used in hat.\n\nFor O(2) there is only one coefficient ``c = (Œ±)^mathrmT and hence X = beginpmatrix 0  -Œ± Œ±  0endpmatrix is returned.\n\nFor n=3 a usual representtion turns c = (Œ± Œ≤ Œ≥)^mathrmT  ‚Ñù^3 into\n\n    X = beginpmatrix 0  -Œ≥  Œ≤ Œ≥  0  -Œ± -Œ≤  Œ±  0endpmatrix\n\nhence the coordinate vector is .\n\nFor n ‚â• 4` all further coefficients are used to fill up the following rows of the lower triangular part ‚Äì which determines the upper triangular part due to skew-symmetry\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.get_vector-Tuple{ManifoldsBase.Fiber{‚Ñù, ManifoldsBase.TangentSpaceType, LieGroup{‚Ñù, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{T, ‚Ñù, Manifolds.AbsoluteDeterminantOneMatrixType}}, Identity{MatrixMultiplicationGroupOperation}} where T, Any, DefaultLieAlgebraOrthogonalBasis}","page":"Orthogonal group","title":"ManifoldsBase.get_vector","text":"get_vector(G::OrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector(G::SpecialOrthogonalLieAlgebra, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::OrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\nget_vector!(G::SpecialOrthogonalLieAlgebra, X, e, c, ::DefaultLieAlgebraOrthogonalBasis)\n\nCompute the tangent vector X  ùî¨(n) based on a vector of coordinates c  ‚Ñù^d, where d is the dimension of the Lie algebra of the OrthogonalGroup O(n) and the coordinates are with respect to the DefaultLieAlgebraOrthogonalBasis. This is also the version used in hat.\n\nFor O(2) there is only one coefficient ``c = (Œ±)^mathrmT and hence X = beginpmatrix 0  -Œ± Œ±  0endpmatrix is returned.\n\nFor n=3 a usual representtion turns c = (Œ± Œ≤ Œ≥)^mathrmT  ‚Ñù^3 into\n\n    X = beginpmatrix 0  -Œ≥  Œ≤ Œ≥  0  -Œ± -Œ≤  Œ±  0endpmatrix\n\nhence the coordinate vector is .\n\nFor n ‚â• 4` all further coefficients are used to fill up the following rows of the lower triangular part ‚Äì which determines the upper triangular part due to skew-symmetry\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.log!-Tuple{LieGroup{‚Ñù, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ManifoldsBase.TypeParameter{Tuple{2}}, ‚Ñù, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(2) or SpecialOrthogonalGroup mathrmSO(2), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nFor the two-dimensional case, any rotation matrix g can be represented as beginpmatrix cos(Œ±)  -sin(Œ±) sin(Œ±)  cos(Œ±)endpmatrix. For the SpecialOrthogonalGroup, g might also include reflections.\n\nThe logarithm is then\n\nlog_mathcal G(g) =  beginpmatrix 0  Œ± -Œ±  0endpmatrix\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(2) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.log!-Tuple{LieGroup{‚Ñù, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ManifoldsBase.TypeParameter{Tuple{3}}, ‚Ñù, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(3) or SpecialOrthogonalGroup mathrmSO(3), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nHere, exp_mathcal G(X) = g is inverted using the Rodrigues' rotation formula\n\nexp_mathcal G(X) = I_3 + fracsinŒ±X + frac(1 - cos)Œ±^2X^2\n\nFor Œ±   0 œÄ  we obtain X from the observation that\n\nmathrmtr(g) = 1 + 2cos(Œ±)\nqquadtext and qquad\nfrac12(g-g^mathrmT) = sin(Œ±)X\n\nFor Œ± = 0 we have g = I_3 and X = 0.\n\nFor Œ± = œÄ we have to solve X^2 = frac12(g-I_3), where X is skew-symmetric and hence we have to solve for three unknowns.\n\nlog_mathcal G(g) = X\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined. Especially, since mathrmO(3) consists of two disjoint connected components and the exponential map is smooth, for any g in the other component, the logarithmic map is defined, but not the inverse of the exponential map.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#ManifoldsBase.log!-Tuple{LieGroup{‚Ñù, MatrixMultiplicationGroupOperation, Manifolds.GeneralUnitaryMatrices{ManifoldsBase.TypeParameter{Tuple{4}}, ‚Ñù, Manifolds.AbsoluteDeterminantOneMatrixType}}, Any, Any}","page":"Orthogonal group","title":"ManifoldsBase.log!","text":"log(G, g)\nlog!(G, X, g)\n\nCompute the Lie group logarithm function on the OrthogonalGroup mathrmO(4) or SpecialOrthogonalGroup mathrmSO(4), where e is the Identity{MatrixMultiplicationGroupOperation} and G uses a TypeParameter for dispatch.\n\nThe implementation is based on a generalized variant of the Rodrigues' like formula. For details, see [GX02, Section 3].\n\nThis result can be computed in-place of X\n\nNote the logarithmic map is only locally around the identity uniquely determined.\n\n\n\n\n\n","category":"method"},{"location":"groups/orthogonal_group/#Utility-functions","page":"Orthogonal group","title":"Utility functions","text":"","category":"section"},{"location":"groups/orthogonal_group/","page":"Orthogonal group","title":"Orthogonal group","text":"LieGroups.angles_4d_skew_sym_matrix\nLieGroups.cos_angles_4d_rotation_matrix\nLieGroups.log_safe!\nLieGroups.usinc_from_cos","category":"page"},{"location":"groups/orthogonal_group/#LieGroups.angles_4d_skew_sym_matrix","page":"Orthogonal group","title":"LieGroups.angles_4d_skew_sym_matrix","text":"angles_4d_skew_sym_matrix(A)\n\nThe Lie algebra ùî∞ùî¨(4) of OrthogonalGroup(4) in ‚Ñù^44, consists of 44 skew-symmetric matrices. The unique imaginary components of their eigenvalues are the angles of the two plane rotations. This function computes these more efficiently than eigvals.\n\nBy convention, the returned values are sorted in decreasing order. See also cos_angles_4d_rotation_matrix.\n\n\n\n\n\n","category":"function"},{"location":"groups/orthogonal_group/#LieGroups.cos_angles_4d_rotation_matrix","page":"Orthogonal group","title":"LieGroups.cos_angles_4d_rotation_matrix","text":"cos_angles_4d_rotation_matrix(R)\n\n4D rotations can be described by two orthogonal planes that are unchanged by the action of the rotation (vectors within a plane rotate only within the plane). The cosines of the two angles Œ±Œ≤ of rotation about these planes may be obtained from the distinct real parts of the eigenvalues of the rotation matrix. This function computes these more efficiently by solving the system\n\nbeginaligned cosŒ± + cosŒ≤ = frac12mathrmtr(R) cosŒ± cosŒ≤ = frac18mathrmtr(R)^2 - frac116mathrmtr((R - R^T)^2) - 1endaligned\n\nBy convention, the returned values are sorted in decreasing order. See also angles_4d_skew_sym_matrix.\n\n\n\n\n\n","category":"function"},{"location":"groups/orthogonal_group/#LieGroups.log_safe!","page":"Orthogonal group","title":"LieGroups.log_safe!","text":"log_safe!(y, x)\n\nCompute the matrix logarithm of x. If the eltype of y is real, then the imaginary part of x is ignored, and a DomainError is raised if real(x) has no real logarithm.\n\n\n\n\n\n","category":"function"},{"location":"groups/orthogonal_group/#LieGroups.usinc_from_cos","page":"Orthogonal group","title":"LieGroups.usinc_from_cos","text":"usinc_from_cos(x::Real)\n\nUnnormalized version of sinc function, i.e. mathrmusinc(Œ∏) = fracsin(Œ∏)Œ∏, computed from x = cos(Œ∏).\n\n\n\n\n\n","category":"function"},{"location":"groups/special_unitary_group/#The-special-unitary-group","page":"Special unitary group","title":"The special unitary group","text":"","category":"section"},{"location":"groups/special_unitary_group/","page":"Special unitary group","title":"Special unitary group","text":"SpecialUnitaryGroup","category":"page"},{"location":"groups/special_unitary_group/#LieGroups.SpecialUnitaryGroup","page":"Special unitary group","title":"LieGroups.SpecialUnitaryGroup","text":"SpecialUnitaryGroup{T}\n\nThe special orthogonal group mathrmSO(n) is the Lie group consisting of the MatrixMultiplicationGroupOperation on the manifold of rotations GeneralUnitaryMatrices with determinant one.\n\nConstructor\n\nSpecialUnitaryGroup(n::Int; kwargs...)\n\nGenerate special unitary group mathrmSO(n). All keyword arguments in kwargs... are passed on to Rotations as well.\n\n\n\n\n\n","category":"type"},{"location":"groups/special_unitary_group/","page":"Special unitary group","title":"Special unitary group","text":"For this Lie group, several implementations are already covered by the defaults in the generic (matrix) multiplication operation.","category":"page"},{"location":"#LieGroups.jl","page":"Home","title":"LieGroups.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the Documentation of LieGroups.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = LieGroups","category":"page"},{"location":"","page":"Home","title":"Home","text":"LieGroups.LieGroups","category":"page"},{"location":"#LieGroups.LieGroups","page":"Home","title":"LieGroups.LieGroups","text":"LieGroups.jl: Lie groups and Lie algebras in Julia.\n\nThe package is named after the Norwegian mathematician Marius Sophus Lie (1842‚Äì1899).\n\nüìö Documentation: juliamanifolds.github.io/LieGroups.jl/\nüì¶ Repository: github.com/JuliaManifolds/LieGroups.jl\nüí¨ Discussions: github.com/JuliaManifolds/LieGroups.jl/discussions\nüéØ Issues: github.com/JuliaManifolds/LieGroups.jl/issues\n\n\n\n\n\n","category":"module"},{"location":"","page":"Home","title":"Home","text":"The implemented Lie groups use the interface for manifolds in ManifoldsBase.jl together with an interface for Lie groups and Lie algebras as well as internally using the manifolds implemented in Manifolds.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more general information about the history of and contributions to the package see the About page.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package just type","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(\"LieGroups\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then you can directly start, for example consider the SpecialEuclideanGroup mathrmSE(3) representing all orientations and places an object can take in ‚Ñù^3. These are characterised by a 33 rotation matrix together with a point the object is at. For example. having such a point, we can use the Lie group logarithmic function log(G::SpecialEuclideanGroup, g) and the Lie group exponential function exp(G::SpecialEuclideanGroup, X) to create an orientation ‚Äúhalf the way‚Äù from the origin pose.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The default representation is in homogeneous coordinates","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LieGroups\nSE3 = SpecialEuclideanGroup(3)\ng = 1/sqrt(2) .* [1.0 -1.0 0.0 0.0; 1.0 1.0 0.0 3.0*sqrt(2); 0.0 0.0 sqrt(2) 0.0; 0.0 0.0 0.0 sqrt(2)]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then half that pose is","category":"page"},{"location":"","page":"Home","title":"Home","text":"h = exp(SE3, 0.5 .* log(SE3, g))","category":"page"},{"location":"","page":"Home","title":"Home","text":"To check, just ‚Äúperform that movement‚Äù twice with the group operation compose of h with itself to get g back","category":"page"},{"location":"","page":"Home","title":"Home","text":"compose(SE3, h, h)","category":"page"},{"location":"","page":"Home","title":"Home","text":"for more details see the get started tutorial.","category":"page"},{"location":"groups/translation_group/#The-Lie-group-of-translations-on-a-Euclidean-space","page":"Translation group","title":"The Lie group of translations on a Euclidean space","text":"","category":"section"},{"location":"groups/translation_group/","page":"Translation group","title":"Translation group","text":"TranslationGroup","category":"page"},{"location":"groups/translation_group/#LieGroups.TranslationGroup","page":"Translation group","title":"LieGroups.TranslationGroup","text":"TranslationGroup{ùîΩ,T}\n\nThe translation group mathcal T(n) is Lie group consisting of the AdditionGroupOperation on some Euclidean space.\n\nConstructor\n\nTranslationGroup(n‚ÇÅ,...,n·µ¢; kwargs...)\n\nGenerate the translation group on ùîΩ^n‚ÇÅn·µ¢ = Euclidean(n‚ÇÅ,...,n·µ¢; field=ùîΩ), which is isomorphic to the group itself. All keyword arguments in kwargs... are passed on to Euclidean as well\n\nWe denote the Lie algebra of mathcal T(n) by mathfrak t(n).\n\n\n\n\n\n","category":"type"},{"location":"groups/translation_group/","page":"Translation group","title":"Translation group","text":"For this Lie group, all implementations are already covered by the defaults in the generic addition operation.","category":"page"},{"location":"notation/#Notation-on-Lie-groups","page":"Notation","title":"Notation on Lie groups","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"In this package,the notation introduced in Manifolds.jl Notation is used with the following additional parts.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Symbol Description Also used Comment\n a group operation  \nc_gmathcal G  mathcal G the conjugation map (with g)  \nmathrme identity element of a group  \nexp_mathcal G(X) The Lie group exponential function  \nexp_g(X) The Lie group exponential map (w.r.t. a Cartan Schouten connection)  \ng h k elements on a (Lie) group. Sometimes called points. g_1 g_2  \nmathfrak g a Lie algebra  \nmathcalG a Lie group  \nŒª_g mathcal G  mathcal G the left group operation map Œª_g(h) = gh  \nlog_mathcal G(g) The Lie group logarithmic function  \nlog_g(h) The Lie group logarithmic map (w.r.t. a Cartan Schouten connection)  \nœÅ_g mathcal G  mathcal G the right group operation map œÅ_g(h) = hg  \nœÉ mathcal G  mathcal M a left group action  œÉ_g(p) to emphasize a fixed group element\nœÑ mathcal M  mathcal G a right group action œÉ_mathrmR œÑ_g(p) to emphasize a fixed group element","category":"page"}]
}
