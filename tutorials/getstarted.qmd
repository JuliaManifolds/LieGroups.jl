# üöÄ Get Started with LieGroups.jl

## Introduction

This tutorial introduces both a few basics of [Lie groups](https://en.wikipedia.org/wiki/Lie_group) as well as how to use [LieGroups.jl](https://juliamanifolds.github.io/LieGroups.jl/stable/). The Lie groups we consider are the rotations in the plane,
or [special orthogonal group](../groups/special_orthogonal_group.md) as well as rigid body motions,
or in other words the [special euclidean group](../groups/special_euclidean_group.md).

In a nutshell a Lie group ``ùí¢`` is a [manifold](https://en.wikipedia.org/wiki/Manifold) that also is a group a group operation.
A manifold informally be described as a set that ‚Äúlocally looks like a Euclidean space‚Äù
and has some way to measure angles at every point, to be precise an inner product, that is allowed to (smoothly)
depend on the point we are at.
A [group](https://en.wikipedia.org/wiki/Group_(mathematics)) means that on the set there also
exists an operation, within this package usually denoted by ``‚àò: ``,
`LieGroups.jl` uses the manifolds defined in [`Manifolds.jl`](https://juliamanifolds.github.io/Manifolds.jl/stable/). For more details on that, see also the [introductory tutorial](https://juliamanifolds.github.io/Manifolds.jl/stable/tutorials/getstarted/) there.

For more theoretical background, see for example [HilgertNeeb:2012](@cite), especially their Chapter 9.

## Rotations on the plane ``‚Ñù^2`` and in ``‚Ñù^3``.

This first part considers rotations in the plane. These can be represented by rotation matrices
```math
R_Œ± = \begin{pmatrix} \cos(Œ±),& -\sin(Œ±)\\ \sin(Œ±) & \cos(Œ±) \end{pmatrix},\qquad Œ± ‚àà ‚Ñù,
```

where we already represent all possible rotations when restricting ``Œ±`` to ``[0,2œÄ]``.
Adding two matrices ``R_Œ± + R_Œ≤`` does not yield a valid rotation matrix again, but we
can have these matrices in mind as being ‚Äúlocally like the real line‚Äù, since changing the rotation angle
slightly yields rotation matrices that are ‚Äúclose by‚Äù in the sense that they perform nearly the same rotation
when applied to a point ``x ‚àà ‚Ñù^2`` by computing ``R_Œ±x```.
Matrix multiplication ``R_Œ≤ = R_{Œ±_1}*R_{Œ±_1}`` does yield a new rotation and also fulfils all other
properties to yield a group operation. Using trigonometric identities we observe that ``Œ≤ = Œ±_1 + Œ±_2``.

The set of rotation matrices is hence a Lie group and called the [special orthogonal group](../groups/special_orthogonal_group.md) ``\mathrm{SO}(2)``. In `LieGroups.jl` we initialise this as

```{julia}
using LieGroups, RecursiveArrayTools
G = SpecialOrthogonalGroup(2)
```

Elements ``g, h ‚àà \mathrm{SO}(2)`` we generate as

```{julia}
g = [1.0 0.0; 0.0 1.0]
h = 1/sqrt(2) .* [1.0 -1.0; 1.0 1.0]
```

A first thing to do is to use [`is_point`](@ref) to verify they are valid.

```{julia}
[is_point(G,g), is_point(G,h)]
```

# TODO
* compose
* lie group exponential & logarithm
* Lie algebra

SO(3)
* hat/vee to get to vectors
* group action and apply

(towards) SE(3)
* product of two Lie groups
* semidirect product


## Technical details

This tutorial is cached. It was last run on the following package versions.

```{julia}
#| code-fold: true
#| echo: false
using Pkg
Pkg.status()
```
```{julia}
#| code-fold: true
#| echo: false
#| output: asis
using Dates
println("This tutorial was last rendered $(Dates.format(now(), "U d, Y, H:M:S")).");
```

## Literature

````{=commonmark}
```@bibliography
Pages = ["getstarted.md"]
Canonical=false
```
````