var documenterSearchIndex = {"docs":
[{"location":"groups/translation/#The-Lie-group-of-translations-on-a-Euclidean-space","page":"Translation group","title":"The Lie group of translations on a Euclidean space","text":"","category":"section"},{"location":"groups/translation/","page":"Translation group","title":"Translation group","text":"TranslationGroup","category":"page"},{"location":"groups/translation/#LieGroups.TranslationGroup","page":"Translation group","title":"LieGroups.TranslationGroup","text":"TranslationGroup{ùîΩ,T}\n\nThe Lie group consisting of the AdditionGroupOperation on some Euclidean space.\n\nConstructor\n\nTranslationGroup(n‚ÇÅ,...,n·µ¢; kwargs...)\n\nGenerate the translation group on ùîΩ^n‚ÇÅn·µ¢ = Euclidean(n‚ÇÅ,...,n·µ¢; field=ùîΩ), which is isomorphic to the group itself. All keyword arguments in kwargs... are passed on to Euclidean as well\n\n\n\n\n\n","category":"type"},{"location":"groups/translation/","page":"Translation group","title":"Translation group","text":"For this Lie group, all implementations are already covered by the defaults in the generic addition operation.","category":"page"},{"location":"references/#Literature","page":"References","title":"Literature","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"This is all literature mentioned / referenced in the LieGroups.jl documentation. You can find a small reference section at the end of every documentation page that contains the corresponding references as well.","category":"page"},{"location":"references/","page":"References","title":"References","text":"E.¬†Biny and S.¬†Pods. The Geometry of Heisenberg Groups: With Applications in Signal Theory, Optics, Quantization, and Field Quantization (American Mathematical Society, 2008).\n\n\n\nM.¬†B.¬†Giles. Collected Matrix Derivative Results for Forward and Reverse Mode Algorithmic Differentiation. In: Advances in Automatic Differentiation, Lecture Notes in Computational Science and Engineering, edited by C.¬†H.¬†Bischof, H.¬†M.¬†B√ºcker, P.¬†Hovland, U.¬†Naumann and J.¬†Utke (Springer, Berlin, Heidelberg, 2008); pp.¬†35‚Äì44.\n\n\n\nJ.¬†Hilgert and K.-H.¬†Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\n","category":"page"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"EditURL = \"https://github.com/JuliaManifolds/LieGroups.jl/blob/main/CONTRIBUTING.md\"","category":"page"},{"location":"contributing/#Contributing-to-LieGroups.jl","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"First, thanks for taking the time to contribute. We appreciate and welcome any contribution.","category":"page"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"The following is a set of guidelines to LieGroups.jl.","category":"page"},{"location":"contributing/#Table-of-contents","page":"Contributing to LieGroups.jl","title":"Table of contents","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Contributing to LieGroups.jl     - Table of Contents\nHow to just ask a question\nHow to file an issue\nHow to contribute\nCode style","category":"page"},{"location":"contributing/#How-to-just-ask-a-question","page":"Contributing to LieGroups.jl","title":"How to just ask a question","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"You can most easily reach the developers in the Julia Slack channel #manifolds. You can apply for the Julia Slack workspace here if you haven't joined yet. You can also ask your question on discourse.julialang.org.","category":"page"},{"location":"contributing/#How-to-file-an-issue","page":"Contributing to LieGroups.jl","title":"How to file an issue","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"If you found a bug or want to propose a feature, please open an issue in within the GitHub repository.","category":"page"},{"location":"contributing/#How-to-contribute","page":"Contributing to LieGroups.jl","title":"How to contribute","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Currently most details are still work-in-progress. Feel free to contribute ideas, features you would like to see, Lie groups you want to have or would like to contribute, or any other idea for LieGroups.jl. For these, use either the discussions or issues in the GitHub repository","category":"page"},{"location":"contributing/#Code-style","page":"Contributing to LieGroups.jl","title":"Code style","text":"","category":"section"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Please follow the documentation guidelines from the Julia documentation as well as Blue Style. Run JuliaFormatter.jl on the repository running using JuliaFormatter; format(\".\") on the main folder of the project.","category":"page"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Please follow a few internal conventions:","category":"page"},{"location":"contributing/","page":"Contributing to LieGroups.jl","title":"Contributing to LieGroups.jl","text":"Include the mathematical formulae for any implemented function if a closed form exists.\nDefine a Lie group, a Lie group action, or a Lie algebra in its own file. Include all related functions in the same file\nan alphabetical order of functions in every file is preferable.\nThe preceding implies that the mutating variant of a function follows the non-mutating variant.\nDocument both the allocating and the mutating variants of a function. To avoid duplication, attach one doc string defined before both functions and attach it to both.\nThere should be no dangling = signs.\nAdd a newline between things of different types (struct/method/const).\nAdd a newline between methods for different functions (including allocating/mutating variants).\nPrefer to have no newline between methods for the same function; when reasonable, merge the documentation strings.\nAll import/using/include should be in the main module file.\nAvoid using import and use the explicit full name, like Base.exp, when implementing functions, that extend functions of other packages.\nif possible provide both mathematical formulae and literature references using DocumenterCitations.jl and BibTeX where possible\nAlways document all input variables and keyword arguments","category":"page"},{"location":"interface/operations/#An-interface-for-Lie-group-operations","page":"Group operation","title":"An interface for Lie group operations","text":"","category":"section"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"AbstractGroupOperation\nIdentity","category":"page"},{"location":"interface/operations/#LieGroups.AbstractGroupOperation","page":"Group operation","title":"LieGroups.AbstractGroupOperation","text":"AbstractGroupOperation\n\nRepresent a type of group operation for a LieGroup mathcal G, that is a smooth binary operation   mathcal G  mathcal G  mathcal G on elements of a Lie group mathcal G.\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#LieGroups.Identity","page":"Group operation","title":"LieGroups.Identity","text":"Identity{O<:AbstractGroupOperation}\n\nRepresent the group identity element e  mathcal G on a LieGroup mathcal G with AbstractGroupOperation of type O.\n\nSimilar to the philosophy that points are agnostic of their group at hand, the identity does not store the group mathcal G it belongs to. However it depends on the type of the AbstractGroupOperation used.\n\nSee also identity_element on how to obtain the corresponding AbstractManifoldPoint or array representation.\n\nConstructors\n\nIdentity(::LieGroup{ùîΩ,O}) where {ùîΩ,O<:AbstractGroupOperation}\nIdentity(o::AbstractGroupOperation)\nIdentity(::Type{AbstractGroupOperation})\n\ncreate the identity of the corresponding subtype O<:AbstractGroupOperation\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"You can combine some specific group operations with one of several manifolds to form a Lie group. You can still define the corresponding functions generically for all groups with this group operation regardless of the manifold. The following sections collect these.","category":"page"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"an AdditionGroupOperation","category":"page"},{"location":"interface/operations/#addition-operation-sec","page":"Group operation","title":"Additive group operation","text":"","category":"section"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"Modules = [LieGroups]\nPages = [\"addition_operation.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"interface/operations/#LieGroups.AdditionGroupOperation","page":"Group operation","title":"LieGroups.AdditionGroupOperation","text":"AdditionGroupOperation <: AbstractGroupOperation\n\nA group operation that is realised introducing defaults that fall back to + and - being overloaded, for example _compose(G::LieGroup{ùîΩ,AdditionGroupOperation}, a, b) = a + b\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#Base.exp-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Identity{AdditionGroupOperation}, Any}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Identity{AdditionGroupOperation}, Any, Number}} where ùîΩ","page":"Group operation","title":"Base.exp","text":"exp(G::LieGroup{ùîΩ,AdditionGroupOperation}, e::Identity{AdditionGroupOperation}, X, t::Number=1)\nexp!(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, e::Identity{AdditionGroupOperation}, X, t::Number=1)\n\nCompute the Lie group exponential on a LieGroup with an AdditionGroupOperation. This can be computed in-place of g.\n\nSince e is just the zero-element with respect to the corresponding +, the formula reads g=0+X=X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.inv-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any}} where ùîΩ","page":"Group operation","title":"Base.inv","text":"inv(G::LieGroup{ùîΩ,AdditionGroupOperation}, g)\ninv!(G::LieGroup{ùîΩ,AdditionGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for the AdditionGroupOperation simplifies to -g. This can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.log-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Identity{AdditionGroupOperation}, Any}} where ùîΩ","page":"Group operation","title":"Base.log","text":"log(G::LieGroup{ùîΩ,AdditionGroupOperation}, e::Identity{AdditionGroupOperation}, g)\nlog!(G::LieGroup{ùîΩ,AdditionGroupOperation}, X, e::Identity{AdditionGroupOperation}, g)\n\nCompute the Lie group logarithm on a LieGroup with an AdditionGroupOperation. This can be computed in-place of X.\n\nSince e is just the zero-element with respect to the corresponding +, the formula reads X=g-0=g.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.compose!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.compose!","text":"compose(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, h)\ncompose!(G::LieGroup{ùîΩ,AdditionGroupOperation}, k, g, h)\n\nCompute the group operation composition of g and h with respect to the AdditionGroupOperation on G, which falls back to calling g+h, where + is assumed to be overloaded accordingly.\n\nThis can be computed in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Vararg{Any, 4}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_conjugate!","text":"diff_conjugate(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjutage c_g(h) = ghg^-1 = g+h-g = h, which simplifies for AdditionGroupOperation to D(c_g(h))X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_conjugate","text":"diff_conjugate(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjutage c_g(h) = ghg^-1 = g+h-g = h, which simplifies for AdditionGroupOperation to D(c_g(h))X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_inv!","text":"diff_inv(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, g, X)\n\nCompute the differential of the inverse operation Œπ_mathcal G(g) = g^-1 = -g, which simplifies for AdditionGroupOperation to DŒπ_mathcal G(g)X = -X\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_inv","text":"diff_inv(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, g, X)\n\nCompute the differential of the inverse operation Œπ_mathcal G(g) = g^-1 = -g, which simplifies for AdditionGroupOperation to DŒπ_mathcal G(g)X = -X\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Vararg{Any, 4}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_left_compose!","text":"diff_left_compose(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh, which simplifies for AdditionGroupOperation to DŒª_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_left_compose","text":"diff_left_compose(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh, which simplifies for AdditionGroupOperation to DŒª_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Vararg{Any, 4}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_right_compose!","text":"diff_right_compose(G::LieGroup{ùîΩ,AdditionGroupOperation}, h, g, X)\ndiff_right_compose!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, h, g, X)\n\nCompute the differential of the right group multiplication œÅ_g(h) = hg, which simplifies for AdditionGroupOperation to DœÅ_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_right_compose","text":"diff_right_compose(G::LieGroup{ùîΩ,AdditionGroupOperation}, h, g, X)\ndiff_right_compose!(G::LieGroup{ùîΩ,AdditionGroupOperation}, Y, h, g, X)\n\nCompute the differential of the right group multiplication œÅ_g(h) = hg, which simplifies for AdditionGroupOperation to DœÅ_g(h)X = X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.identity_element!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.identity_element!","text":"identity_element(G::LieGroup{ùîΩ,AdditionGroupOperation})\nidentity_element!(G::LieGroup{ùîΩ,AdditionGroupOperation}, e)\n\nReturn the a point representation of the Identity, which for the AdditionGroupOperation is the zero element or array.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.inv!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.inv!","text":"inv(G::LieGroup{ùîΩ,AdditionGroupOperation}, g)\ninv!(G::LieGroup{ùîΩ,AdditionGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for the AdditionGroupOperation simplifies to -g. This can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket!-Union{Tuple{ùîΩ}, Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{AdditionGroupOperation}} where G<:(LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}), Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.lie_bracket!","text":"lie_bracket!(ùî§::LieAlgebra{ùîΩ,AdditionGroupOperation}, X, Y)\nlie_bracket!(ùî§::LieAlgebra{ùîΩ,AdditionGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the AdditionGroupOperation simplifies to the corresponding zero_vector. The computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket-Union{Tuple{ùîΩ}, Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{AdditionGroupOperation}} where G<:(LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}), Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.lie_bracket","text":"lie_bracket!(ùî§::LieAlgebra{ùîΩ,AdditionGroupOperation}, X, Y)\nlie_bracket!(ùî§::LieAlgebra{ùîΩ,AdditionGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the AdditionGroupOperation simplifies to the corresponding zero_vector. The computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Manifolds.compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Any}} where ùîΩ","page":"Group operation","title":"Manifolds.compose","text":"compose(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, h)\ncompose!(G::LieGroup{ùîΩ,AdditionGroupOperation}, k, g, h)\n\nCompute the group operation composition of g and h with respect to the AdditionGroupOperation on G, which falls back to calling g+h, where + is assumed to be overloaded accordingly.\n\nThis can be computed in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Manifolds.identity_element-Union{Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Tuple{ùîΩ}} where ùîΩ","page":"Group operation","title":"Manifolds.identity_element","text":"identity_element(G::LieGroup{ùîΩ,AdditionGroupOperation})\nidentity_element!(G::LieGroup{ùîΩ,AdditionGroupOperation}, e)\n\nReturn the a point representation of the Identity, which for the AdditionGroupOperation is the zero element or array.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.exp!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Identity{AdditionGroupOperation}, Any}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Identity{AdditionGroupOperation}, Any, Number}} where ùîΩ","page":"Group operation","title":"ManifoldsBase.exp!","text":"exp(G::LieGroup{ùîΩ,AdditionGroupOperation}, e::Identity{AdditionGroupOperation}, X, t::Number=1)\nexp!(G::LieGroup{ùîΩ,AdditionGroupOperation}, g, e::Identity{AdditionGroupOperation}, X, t::Number=1)\n\nCompute the Lie group exponential on a LieGroup with an AdditionGroupOperation. This can be computed in-place of g.\n\nSince e is just the zero-element with respect to the corresponding +, the formula reads g=0+X=X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.log!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, AdditionGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Identity{AdditionGroupOperation}, Any}} where ùîΩ","page":"Group operation","title":"ManifoldsBase.log!","text":"log(G::LieGroup{ùîΩ,AdditionGroupOperation}, e::Identity{AdditionGroupOperation}, g)\nlog!(G::LieGroup{ùîΩ,AdditionGroupOperation}, X, e::Identity{AdditionGroupOperation}, g)\n\nCompute the Lie group logarithm on a LieGroup with an AdditionGroupOperation. This can be computed in-place of X.\n\nSince e is just the zero-element with respect to the corresponding +, the formula reads X=g-0=g.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#multiplication-operation-sec","page":"Group operation","title":"Multiplication group operation","text":"","category":"section"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"Modules = [LieGroups]\nPages = [\"multiplication_operation.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"interface/operations/#LieGroups.AbstractMultiplicationGroupOperation","page":"Group operation","title":"LieGroups.AbstractMultiplicationGroupOperation","text":"AbstractMultiplicationGroupOperation <: AbstractGroupOperation\n\nA group operation that is realised introducing defaults that fall back to * being overloaded, for example _compose(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, a, b) = a * b\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#LieGroups.MatrixMultiplicationGroupOperation","page":"Group operation","title":"LieGroups.MatrixMultiplicationGroupOperation","text":"AbstractMultiplicationGroupOperation <: AbstractMultiplicationGroupOperation\n\nA group operation that is realised by a matrix multiplication.\n\n\n\n\n\n","category":"type"},{"location":"interface/operations/#Base.exp-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, MatrixMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Identity{MatrixMultiplicationGroupOperation}, Any}, Tuple{LieGroup{ùîΩ, MatrixMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Identity{MatrixMultiplicationGroupOperation}, Any, Number}} where ùîΩ","page":"Group operation","title":"Base.exp","text":"exp(G::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, e::Identity{MatrixMultiplicationGroupOperation}, X, t::Number=1)\nexp!(G::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, g, e::Identity{MatrixMultiplicationGroupOperation}, X, t::Number=1)\n\nCompute the Lie group exponential on a LieGroup with a MatrixMultiplicationGroupOperation, which simplifies to the matrix exponential.\n\nThis can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.inv-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s17\", M} where {var\"#s17\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any}} where ùîΩ","page":"Group operation","title":"Base.inv","text":"inv(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperationroupOperation}, g)\ninv!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for an AbstractMultiplicationGroupOperation simplifies to the multiplicative inverse g^-1. This can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Base.log-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, MatrixMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Identity{MatrixMultiplicationGroupOperation}, Any}} where ùîΩ","page":"Group operation","title":"Base.log","text":"log(G::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, e::Identity{MatrixMultiplicationGroupOperation}, g)\nlog!(G::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, X, e::Identity{MatrixMultiplicationGroupOperation}, g)\n\nCompute the Lie group logarithm on a LieGroup with a MatrixMultiplicationGroupOperation, which simplifies to the matrix logarithm.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.compose!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s17\", M} where {var\"#s17\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.compose!","text":"compose(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, h)\ncompose!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, k, g, h)\n\nCompute the group operation composition of g and h with respect to an AbstractMultiplicationGroupOperation on G, which falls back to calling g*h, where * is assumed to be overloaded accordingly.\n\nThis can be computed in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s16\", M} where {var\"#s16\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Vararg{Any, 4}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_conjugate!","text":"diff_conjugate(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjutage c_g(h) = ghg^-1 = ghg^-1, which simplifies for an AbstractMultiplicationGroupOperation to D(c_g(h))X = gXg^-1.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_conjugate-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s17\", M} where {var\"#s17\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_conjugate","text":"diff_conjugate(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_conjugate!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the conjutage c_g(h) = ghg^-1 = ghg^-1, which simplifies for an AbstractMultiplicationGroupOperation to D(c_g(h))X = gXg^-1.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s16\", M} where {var\"#s16\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_inv!","text":"diff_inv(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, g, X)\n\nCompute the value of differential DŒπ_mathcal G(g)X of matrix inversion Œπ_mathcal G(g) = g^-1 at X  ùî§ in the LieAlgebra ùî§ of the LieGroup G.\n\nThe formula is given by\n\nDŒπ_mathcal G(g)X = -g^mathrmTXg^-1\n\nwhich stems from using the differential of the inverse from [Gil08] given by D(g^-1)X = -g^-1Xg^-1 composed with the push forward of the left composition DŒª_mathrme(g)X = gX mapping from the Liea algebra into the tangent space at g, and its adjoint D^*Œª_mathrme(g)X = g^mathrmTX. Then we get g^mathrmT(g^-1(gX)g^-1) which simplifies to -g^mathrmTXg^-1 from above.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_inv-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s17\", M} where {var\"#s17\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_inv","text":"diff_inv(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, X)\ndiff_inv!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, g, X)\n\nCompute the value of differential DŒπ_mathcal G(g)X of matrix inversion Œπ_mathcal G(g) = g^-1 at X  ùî§ in the LieAlgebra ùî§ of the LieGroup G.\n\nThe formula is given by\n\nDŒπ_mathcal G(g)X = -g^mathrmTXg^-1\n\nwhich stems from using the differential of the inverse from [Gil08] given by D(g^-1)X = -g^-1Xg^-1 composed with the push forward of the left composition DŒª_mathrme(g)X = gX mapping from the Liea algebra into the tangent space at g, and its adjoint D^*Œª_mathrme(g)X = g^mathrmTX. Then we get g^mathrmT(g^-1(gX)g^-1) which simplifies to -g^mathrmTXg^-1 from above.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s16\", M} where {var\"#s16\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Vararg{Any, 4}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_left_compose!","text":"diff_left_compose(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh, which simplifies for an AbstractMultiplicationGroupOperation to DŒª_g(h)X = gX.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_left_compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s17\", M} where {var\"#s17\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_left_compose","text":"diff_left_compose(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, h, X)\ndiff_left_compose!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh, which simplifies for an AbstractMultiplicationGroupOperation to DŒª_g(h)X = gX.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s16\", M} where {var\"#s16\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Vararg{Any, 4}}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_right_compose!","text":"diff_right_compose(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, h, g, X)\ndiff_right_compose!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, h, g, X)\n\nCompute the differential of the right group multiplication œÅ_g(h) = hg, which simplifies for an AbstractMultiplicationGroupOperation to DœÅ_g(h)X = Xg.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.diff_right_compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s17\", M} where {var\"#s17\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.diff_right_compose","text":"diff_right_compose(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, h, g, X)\ndiff_right_compose!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, Y, h, g, X)\n\nCompute the differential of the right group multiplication œÅ_g(h) = hg, which simplifies for an AbstractMultiplicationGroupOperation to DœÅ_g(h)X = Xg.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.identity_element!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s17\", M} where {var\"#s17\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.identity_element!","text":"identity_element(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation})\nidentity_element!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, e)\n\nReturn the a point representation of the Identity, which for an AbstractMultiplicationGroupOperation is the one-element or identity array.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.inv!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s16\", M} where {var\"#s16\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.inv!","text":"inv(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperationroupOperation}, g)\ninv!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, h, g)\n\nCompute the inverse group element g^-1, which for an AbstractMultiplicationGroupOperation simplifies to the multiplicative inverse g^-1. This can be done in-place of h.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket!-Union{Tuple{ùîΩ}, Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{MatrixMultiplicationGroupOperation}} where G<:(LieGroup{ùîΩ, MatrixMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}), Any, Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.lie_bracket!","text":"lie_bracket(::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, X, Y)\nlie_bracket!(::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the MatrixMultiplicationGroupOperation yields the commutator bracket\n\nX Y = XY-YX\n\nThe computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#LieGroups.lie_bracket-Union{Tuple{ùîΩ}, Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{MatrixMultiplicationGroupOperation}} where G<:(LieGroup{ùîΩ, MatrixMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}), Any, Any}} where ùîΩ","page":"Group operation","title":"LieGroups.lie_bracket","text":"lie_bracket(::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, X, Y)\nlie_bracket!(::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g, which for the for the MatrixMultiplicationGroupOperation yields the commutator bracket\n\nX Y = XY-YX\n\nThe computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Manifolds.compose-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, var\"#s17\", M} where {var\"#s17\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any}} where ùîΩ","page":"Group operation","title":"Manifolds.compose","text":"compose(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, g, h)\ncompose!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, k, g, h)\n\nCompute the group operation composition of g and h with respect to an AbstractMultiplicationGroupOperation on G, which falls back to calling g*h, where * is assumed to be overloaded accordingly.\n\nThis can be computed in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Manifolds.identity_element-Union{Tuple{LieGroup{ùîΩ, var\"#s17\", M} where {var\"#s17\"<:AbstractMultiplicationGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}}, Tuple{ùîΩ}} where ùîΩ","page":"Group operation","title":"Manifolds.identity_element","text":"identity_element(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation})\nidentity_element!(G::LieGroup{ùîΩ,<:AbstractMultiplicationGroupOperation}, e)\n\nReturn the a point representation of the Identity, which for an AbstractMultiplicationGroupOperation is the one-element or identity array.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.exp!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, MatrixMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Identity{MatrixMultiplicationGroupOperation}, Any}, Tuple{LieGroup{ùîΩ, MatrixMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Identity{MatrixMultiplicationGroupOperation}, Any, Number}} where ùîΩ","page":"Group operation","title":"ManifoldsBase.exp!","text":"exp(G::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, e::Identity{MatrixMultiplicationGroupOperation}, X, t::Number=1)\nexp!(G::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, g, e::Identity{MatrixMultiplicationGroupOperation}, X, t::Number=1)\n\nCompute the Lie group exponential on a LieGroup with a MatrixMultiplicationGroupOperation, which simplifies to the matrix exponential.\n\nThis can be computed in-place of g.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#ManifoldsBase.log!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, MatrixMultiplicationGroupOperation, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Identity{MatrixMultiplicationGroupOperation}, Any}} where ùîΩ","page":"Group operation","title":"ManifoldsBase.log!","text":"log(G::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, e::Identity{MatrixMultiplicationGroupOperation}, g)\nlog!(G::LieGroup{ùîΩ,MatrixMultiplicationGroupOperation}, X, e::Identity{MatrixMultiplicationGroupOperation}, g)\n\nCompute the Lie group logarithm on a LieGroup with a MatrixMultiplicationGroupOperation, which simplifies to the matrix logarithm.\n\nThis can be computed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"interface/operations/#Literature","page":"Group operation","title":"Literature","text":"","category":"section"},{"location":"interface/operations/","page":"Group operation","title":"Group operation","text":"M.¬†B.¬†Giles. Collected Matrix Derivative Results for Forward and Reverse Mode Algorithmic Differentiation. In: Advances in Automatic Differentiation, Lecture Notes in Computational Science and Engineering, edited by C.¬†H.¬†Bischof, H.¬†M.¬†B√ºcker, P.¬†Hovland, U.¬†Naumann and J.¬†Utke (Springer, Berlin, Heidelberg, 2008); pp.¬†35‚Äì44.\n\n\n\n","category":"page"},{"location":"about/#About-LieGroups.jl","page":"About","title":"About LieGroups.jl","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"LieGroups.jl is a ‚Äúspin-off‚Äù from `Manifolds.jl, where GroupManifolds where implemented around 2021. Around the same time, Yueh-Hua Tu started a package LieGroups.jl, which was continued than here with a full rewrite to use the manifolds from Manifolds.jl.","category":"page"},{"location":"interface/actions/#An-Interface-for-Lie-group-actions","page":"Group action","title":"An Interface for Lie group actions","text":"","category":"section"},{"location":"interface/actions/","page":"Group action","title":"Group action","text":"Modules = [LieGroups]\nPages = [\"group_action_interface.jl\"]\nOrder = [:type]","category":"page"},{"location":"interface/actions/#LieGroups.AbstractGroupActionType","page":"Group action","title":"LieGroups.AbstractGroupActionType","text":"AbstractGroupActionType\n\nAn abstract supertype for group action types, which are used within a GroupAction.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.AbstractLeftGroupActionType","page":"Group action","title":"LieGroups.AbstractLeftGroupActionType","text":"AbstractLeftGroupActionType <: AbstractGroupActionType\n\nA type representing a (smooth) group action œÉ mathcal G  mathcal M  mathcal M of a LieGroup mathcal G acting (from the left) on an AbstractManifold mathcal M. with the following properties\n\nœÉ(mathrme p) = p holds for all p  mathcal M\nœÉ(g œÉ(h p)) = œÉ(gh p) holds for all gh  mathcal G, p  mathcal M\n\nwhere  denotes the group operation of the LieGroup mathcal G. See also [HN12, Definition 9.1.11].\n\nThe type of action can be seen a bit better when writing the action as a family œÉ_g(p): we obtain from the second property as\n\n  œÉ_g(œÉ_h(p)) = œÉ_gh(p)\n\nand see that g appears on the left.\n\nTo emphasize the side the group operation is acting from, we sometimes write œÉ^mathrmL. If the action is clear from context we write œÉ(g p) = g  p.\n\nOne notable example of a left action is the inverse of an action of AbstractRightGroupActionType œÉ^mathrmR, which is given by œÑ_g = (œÉ^mathrmR_g)^-1 = œÉ^mathrmR_g^-1. We obtain\n\nœÑ_g(œÑ_h(p))\n= œÉ^mathrmR_g^-1(œÉ^mathrmR_h^-1(p))\n= œÉ^mathrmR_h^-1g^-1(p)\n= œÉ^mathrmR_(gh)^-1(p)\nœÑ_gh(p)\n\nnote: Note\nIn function definitions we follow the idea of the family of actions and use the order (M, g, p) in function signatures.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.AbstractRightGroupActionType","page":"Group action","title":"LieGroups.AbstractRightGroupActionType","text":"AbstractRightGroupActionType <: AbstractGroupActionType\n\nA type representing a (smooth) group action œÉ mathcal M  mathcal G  mathcal M of a LieGroup mathcal G acting (from the right) on an AbstractManifold mathcal M. with the following properties\n\nœÉ(p mathrme) = p holds for all p  mathcal M\nœÉ(œÉ(p g) h) = œÉ(p gh) holds for all gh  mathcal G, p  mathcal M\n\nwhere  denotes the group operation of the LieGroup mathcal G. See also [HN12, Remark 9.1.12].\n\nThe type of action can be seen a bit better when writing the action as a family œÉ_g(p): we obtain from the second property as\n\n  œÉ_g(œÉ_h(p)) = œÉ_hg(p)\n\nand see that g appears on the right.\n\nTo emphasize the side the group operation is acting from, we sometimes write œÉ^mathrmR. If the action is clear from context we write œÉ(p g) = p  g.\n\nOne notable example of a right action is the inverse of an action of  AbstractLeftGroupActionType œÉ^mathrmL, which is given by œÑ_g = (œÉ^mathrmL_g)^-1 = œÉ^mathrmL_g^-1. We obtain\n\nœÑ_g(œÑ_h(p))\n= œÉ^mathrmL_g^-1(œÉ^mathrmL_h^-1(p))\n= œÉ^mathrmL_g^-1h^-1(p)\n= œÉ^mathrmL_(hg)^-1(p)\nœÑ_hg(p)\n\nnote: Note\nIn function definitions we follow the idea of the family of actions and use the order (M, g, p) in function signatures.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.GroupAction","page":"Group action","title":"LieGroups.GroupAction","text":"GroupAction{T<:GroupActionType, L<:LieGroup, M<:AbstractManifold}\n\nSpecify a group action of AbstractGroupActionType T of a LieGroup G acting on M.\n\nLet mathcal M be a AbstractManifold and mathcal G be a LieGroup with group operation .\n\nA (smooth) action of the group mathcal G on the manifold mathcal M is a map\n\nœÉ mathcal G  mathcal M  mathcal M\n\nwith the properties\n\nœÉ(mathrme p) = p holds for all p  mathcal M\nœÉ(g œÉ(h p)) = œÉ(gh p) holds for all gh  mathcal G, p  mathcal M\n\nFields\n\ntype::T: The type of the group action.\ngroup::L: The group acting.\nmanifold::M: The manifold the group acts upon.\n\nSee [HN12, Section 9.1.3] for more details.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#Functions-for-Lie-group-actions","page":"Group action","title":"Functions for Lie group actions","text":"","category":"section"},{"location":"interface/actions/","page":"Group action","title":"Group action","text":"Modules = [LieGroups]\nPages = [\"group_action_interface.jl\"]\nOrder = [:function]","category":"page"},{"location":"interface/actions/#Base.inv-Tuple{AbstractGroupActionType}","page":"Group action","title":"Base.inv","text":"inv(::AbstractGroupActionType)\n\nreturn the inverse group operation action, that is, use the type representing the inverse operation.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Base.inv-Tuple{GroupAction}","page":"Group action","title":"Base.inv","text":" inv(A::GroupAction{T})\n\nReturn the GroupAction representing the inverse of an GroupAction of AbstractGroupActionType T. This is usually done by returning the group action with the inverse type of T.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.base_lie_group-Tuple{GroupAction}","page":"Group action","title":"LieGroups.base_lie_group","text":"base_lie_group(A::GroupAction)\n\nReturn the LieGroup of the GroupAction specifying the action.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.default_left_action-Tuple{LieGroup, ManifoldsBase.AbstractManifold}","page":"Group action","title":"LieGroups.default_left_action","text":"default_left_action(G::LieGroup, M::AbstractManifold)\n\nReturn the default left action for a Lie group G acting on a manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.default_right_action-Tuple{LieGroup, ManifoldsBase.AbstractManifold}","page":"Group action","title":"LieGroups.default_right_action","text":"default_right_action(G::LieGroup, M::AbstractManifold)\n\nReturn the default right action for a Lie group G acting on a manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.diff_apply!-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"LieGroups.diff_apply!","text":"diff_apply(A::GroupAction{T, L, M}, g, p, X)\ndiff_apply!(A::GroupAction{T, L, M}, Y, g, p, X)\n\nCompute the differential D_p œÉ_g(p) T_pmathcal M  T_œÉ_g(p)mathcal M, where for a left group action we have œÉ_g(p) = œÉ(gp), for a right action œÉ_g(p) = œÉ(p g).\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.diff_apply-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"LieGroups.diff_apply","text":"diff_apply(A::GroupAction{T, L, M}, g, p, X)\ndiff_apply!(A::GroupAction{T, L, M}, Y, g, p, X)\n\nCompute the differential D_p œÉ_g(p) T_pmathcal M  T_œÉ_g(p)mathcal M, where for a left group action we have œÉ_g(p) = œÉ(gp), for a right action œÉ_g(p) = œÉ(p g).\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.diff_group_apply!-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"LieGroups.diff_group_apply!","text":"diff_group_apply(A::GroupAction{T, L, M}, g, p, X)\ndiff_group_apply!(A::GroupAction{T, L, M}, Y, g, p, X)\n\nCompute the differential D_g œÉ_g(p) mathfrak g  mathfrak g, where we use the short hand notation œÉ_p(g) = œÉ(gp) for a left action, and for a right action œÉ_p(g) = œÉ(p g).\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.diff_group_apply-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"LieGroups.diff_group_apply","text":"diff_group_apply(A::GroupAction{T, L, M}, g, p, X)\ndiff_group_apply!(A::GroupAction{T, L, M}, Y, g, p, X)\n\nCompute the differential D_g œÉ_g(p) mathfrak g  mathfrak g, where we use the short hand notation œÉ_p(g) = œÉ(gp) for a left action, and for a right action œÉ_p(g) = œÉ(p g).\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{AbstractGroupActionType}","page":"Group action","title":"LieGroups.switch","text":"switch(T::AbstractGroupActionType)\n\nReturn the object representing an AbstractGroupActionType related to a group operation action that switched the side, that is it turns a left action type into its corresponding right action type.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{GroupAction}","page":"Group action","title":"LieGroups.switch","text":" switch(A::GroupAction{T})\n\nReturn the group operation action representing the similar GroupAction of AbstractGroupActionType T but acting from the other side. It switches left to right and vice versa. This is done by returning the group action with the ‚Äúswitched‚Äù type of T.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Manifolds.apply!-Tuple{GroupAction, Any, Any, Any}","page":"Group action","title":"Manifolds.apply!","text":"apply(A::GroupAction{T, L, M}, g, p)\napply!(A::GroupAction{T, L, M}, q, g, p)\n\nApply the group action induced by g  mathcal G to p  mathcal M, where the kind of group action is indicated by the AbstractGroupActionType T. This can be performed in-place of q.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Manifolds.apply-Tuple{GroupAction, Any, Any}","page":"Group action","title":"Manifolds.apply","text":"apply(A::GroupAction{T, L, M}, g, p)\napply!(A::GroupAction{T, L, M}, q, g, p)\n\nApply the group action induced by g  mathcal G to p  mathcal M, where the kind of group action is indicated by the AbstractGroupActionType T. This can be performed in-place of q.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#ManifoldsBase.base_manifold-Tuple{GroupAction}","page":"Group action","title":"ManifoldsBase.base_manifold","text":"base_manifold(A::GroupAction)\n\nReturn the AbstractManifold the group action acts upon.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Generic-Lie-group-actions","page":"Group action","title":"Generic Lie group actions","text":"","category":"section"},{"location":"interface/actions/","page":"Group action","title":"Group action","text":"Modules = [LieGroups]\nPages = [\"group_operation_action.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"interface/actions/#LieGroups.InverseLeftGroupOperationAction","page":"Group action","title":"LieGroups.InverseLeftGroupOperationAction","text":"InverseLeftGroupOperationAction <: AbstractRightGroupActionType\n\nA type for the AbstractLeftGroupActionType when acting on the group itself given by the inverse of a LeftGroupOperationAction œÉ_h as\n\nœÑ_h(g) coloneqq œÉ_h^-1(g) = œÉ(h^-1g) = h^-1g\n\nNote that while in naming it is the inverse of the left action, it's properties yield that is is an AbstractRightGroupActionType, since\n\nœÑ_g(œÑ_h(p))\n= œÉ^mathrmL_g^-1(œÉ^mathrmL_h^-1(p))\n= œÉ^mathrmL_g^-1h^-1(p)\n= œÉ^mathrmL_(hg)^-1(p)\nœÑ_hg(p)\n\nfor its inverse (œÉ_h)^-1 see InverseLeftGroupOperationAction.\n\nnote: Note\nSome literature also calls this by itself the right group operation action.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.InverseRightGroupOperationAction","page":"Group action","title":"LieGroups.InverseRightGroupOperationAction","text":"InverseRightGroupOperationAction <: AbstractLeftGroupActionType\n\nA type for the AbstractLeftGroupActionType when acting on the group itself given by the inverse of a RightGroupOperationAction œÉ_h as\n\nœÑ_h(g) coloneqq œÉ_h^-1(g) = œÉ(h^-1g) = gh^-1\n\nNote that while in naming it is the inverse of the right action, it's properties yield that is is an AbstractLeftGroupActionType, since\n\nœÑ_g(œÑ_h(p))\n= œÉ^mathrmR_g^-1(œÉ^mathrmR_h^-1(p))\n= œÉ^mathrmR_h^-1g^-1(p)\n= œÉ^mathrmR_(gh)^-1(p)\nœÑ_gh(p)\n\nfor its inverse (œÉ_h)^-1 see InverseLeftGroupOperationAction.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.LeftGroupOperationAction","page":"Group action","title":"LieGroups.LeftGroupOperationAction","text":"LeftGroupOperationAction <: AbstractLeftGroupActionType\n\nA type for the AbstractLeftGroupActionType when acting on the group itself from the left, that is\n\nœÉ_h(g) = œÉ(hg) = hg\n\nfor its inverse (œÉ_h)^-1 see InverseLeftGroupOperationAction.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#LieGroups.RightGroupOperationAction","page":"Group action","title":"LieGroups.RightGroupOperationAction","text":"RightGroupOperationAction <: AbstractRightGroupActionType\n\nA type for the AbstractLeftGroupActionType when acting on the group itself from the right.\n\nœÉ_h(g) = œÉ(hg) = gh\n\nfor its inverse (œÉ_h)^-1 see InverseRightGroupOperationAction.\n\n\n\n\n\n","category":"type"},{"location":"interface/actions/#Base.inv-Tuple{InverseLeftGroupOperationAction}","page":"Group action","title":"Base.inv","text":"inv(::InverseLeftGroupOperationAction)\n\nReturn the inverse of the InverseLeftGroupOperationAction, that is the LeftGroupOperationAction.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Base.inv-Tuple{InverseRightGroupOperationAction}","page":"Group action","title":"Base.inv","text":"inv(::InverseRightGroupOperationAction)\n\nReturn the inverse of the InverseRightGroupOperationAction, that is the RightGroupOperationAction.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Base.inv-Tuple{LeftGroupOperationAction}","page":"Group action","title":"Base.inv","text":"inv(::LeftGroupOperationAction)\n\nReturn the inverse of the LeftGroupOperationAction, that is the InverseLeftGroupOperationAction.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Base.inv-Tuple{RightGroupOperationAction}","page":"Group action","title":"Base.inv","text":"inv(::RightGroupOperationAction)\n\nReturn the inverse of the RightGroupOperationAction, that is the InverseRightGroupOperationAction.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.GroupOperationAction-Tuple{AbstractGroupActionType, LieGroup}","page":"Group action","title":"LieGroups.GroupOperationAction","text":"GroupOperationAction(action::AbstractGroupActionType, group::LieGroup)\n\nReturn a GroupAction for an AbstractGroupActionType action representing the group operation as an action of the group on itself.\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{InverseLeftGroupOperationAction}","page":"Group action","title":"LieGroups.switch","text":"switch(::InverseLeftGroupOperationAction)\n\nReturn the InverseRightGroupOperationAction, that is, turns œÉ_g = g^-1h into œÑ_g(h) = hg^-1\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{InverseRightGroupOperationAction}","page":"Group action","title":"LieGroups.switch","text":"switch(::InverseRightGroupOperationAction)\n\nReturn the InverseLeftGroupOperationAction, that is, turns œÉ_g = hg^-1 into œÑ_g(h) = g^-1h\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{LeftGroupOperationAction}","page":"Group action","title":"LieGroups.switch","text":"switch(::LeftGroupOperationAction)\n\nReturn the RightGroupOperationAction, that is, turns œÉ_g = gh into œÑ_g(h) = hg\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#LieGroups.switch-Tuple{RightGroupOperationAction}","page":"Group action","title":"LieGroups.switch","text":"switch(::RightGroupOperationAction)\n\nReturn the LeftGroupOperationAction, that is, turns œÉ_g = hg into œÑ_g(h) = gh\n\n\n\n\n\n","category":"method"},{"location":"interface/actions/#Literature","page":"Group action","title":"Literature","text":"","category":"section"},{"location":"interface/actions/","page":"Group action","title":"Group action","text":"J.¬†Hilgert and K.-H.¬†Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\n","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"EditURL = \"https://github.com/JuliaManifolds/LieGroups.jl/blob/main/NEWS.md\"","category":"page"},{"location":"news/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"All notable Changes to the Julia package LieGroups.jl will be documented in this file.","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"news/#[0.1.0]-‚Äì-unreleased","page":"Changelog","title":"[0.1.0] ‚Äì unreleased","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Everything denoted by ‚Äúformerly‚Äù refers to the previous name in Manifolds.jl.","category":"page"},{"location":"news/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"LieAlgebra\nLieGroup (formerly GroupManifold) as well as the concrete groups\nTranslationGroup\nGeneralLinearGroup (formerly GeneralLinear)\nHeisenbergGroup\nLeftSemidirectProductLieGroup (formerly SemidirectProductGroup)\n‚ãâ (alias for LeftSemidirectProductGroupOperation when a default_left_action(G,H) is defined for the two groups)\nPowerLieGroup (formerly PowerGroup)\nPowerGroupOperation to internally avoid ambiguities. Since the constructor always expects a Lie group, this is only necessary internally\nProductLieGroup (formerly ProductGroup)\nRightSemidirectProductLieGroup\n‚ãä (alias for RightSemidirectProductGroupOperation when a default_right_action(G,H) is defined for the two groups)\nAbstractGroupOperation as well as its concrete subtypes\nAdditionGroupOperation (formerly AdditionOperation)\nMultiplicationGroupOperation (formerly MultiplicationOperation)\nPowerGroupOperation (formerly the Lie group was stored inside a power manifold)\nProductGroupOperation (formerly the Lie groups were stored inside a product manifold)\nLeftSemidirectProductGroupOperation (this was formerly only implicitly stored in the SemidirectProductGroup)\nRightSemidirectProductGroupOperation\nAbstractGroupActionType with its 2 specific (new) abstract subtypes\nAbstractLeftGroupActionType\nAbstractRightGroupActionType\nFor the group operation actions there are now\nLeftGroupOperationAction (formerly LeftForwardAction)\nRightGroupOperationAction (formerly RightBackwardAction)\nInverseLeftGroupOperationAction (formerly RightForwardAction)\nInverseRightGroupOperationAction (formerly LeftBackwardAction)\nLieAlgebraOrthogonalBasis (replaces VeeOrthogonalBasis, which is still available in ManifoldsBase.jl)\nIdentity\napplyand apply!\nbase_manifold to access the manifold within a Lie group\ncompose and compose!\nconjugate and conjugate!\ndiff_apply, diff_apply!, diff_group_apply, and diff_group_apply! (formerly apply_diff_[group][!])\ndiff_conjugate and diff_conjugate!\ndiff_left_compose, diff_left_compose!, diff_right_compose, diff_right_compose! (formerly translate_diff with different sides)\nexp(G::LieGroup, g, X) and exp!(G::LieGroup, h, g, X) (formerly exp_inv and exp_inv!)\nexp(G::LieGroup, ::Identity, X) and exp!(G::LieGroup, h, ::Identity, X) (formerly exp_lie and exp_lie!)\nhat and hat!, with slightly different signatures, since the base point is omitted.\nidentity_element and identity_element!\ninv and inv! (inv(::AbstractGroupAction) was formerly switch_direction)\ninv_left_compose, inv_left_compose! and inv_right_compose, inv_right_compose! (these functions correspond to inverse_translate with corresponding direction and side)\nis_identity\nlie_bracket and lie_bracket!\nlog(G::LieGroup, g, h) and log!(G::LieGroup, X, g, h) (formerly log_inv and log_inv!)\nlog(G::LieGroup, ::Identity, g) and log!(G::LieGroup, X, ::Identity, g) (formerly log_lie and log_lie!)\nswitch (formerly switch_side)\nvee and vee!, with slightly different signatures, since the base point is omitted.","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Compared to Manifolds.jl","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"all translate functions are not implemented here, since you can just use compose. The differentials are implemented as listed above with respect to both left and right argument of compose\nall inverse_apply functions are not implemented here, since it is recommended to use apply(inv(A), g, p) as a replacement.","category":"page"},{"location":"news/#Old-Changelog-pre-0.1.0","page":"Changelog","title":"Old Changelog pre 0.1.0","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Two previous releases where done by Yueh-Hua Tu in 2022 before he was so kind to transfer the development to the JuliaManifolds GitHub organisation.","category":"page"},{"location":"news/","page":"Changelog","title":"Changelog","text":"All notable changes to this project will be documented in this file.","category":"page"},{"location":"news/#[0.0.2]","page":"Changelog","title":"[0.0.2]","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"fix SE{3} and add jacobian\ndefine dof and dim for Lie algebra and jacobian of inv\nadd action for SE{N}\nadd se3_location example","category":"page"},{"location":"interface/group/#An-interface-for-Lie-groups","page":"Lie group","title":"An interface for Lie groups","text":"","category":"section"},{"location":"interface/group/","page":"Lie group","title":"Lie group","text":"LieGroup","category":"page"},{"location":"interface/group/#LieGroups.LieGroup","page":"Lie group","title":"LieGroups.LieGroup","text":"LieGroup{ùîΩ, O<:AbstractGroupOperation, M<:AbstractManifold{ùîΩ}} <: AbstractManifold{ùîΩ}\n\nRepresent a Lie Group mathcal G.\n\nA Lie Group mathcal G is a group endowed with the structure of a manifold such that the group operations  mathcal Gmathcal G  mathcal G, see compose and the inverse operation ^-1 mathcal G  mathcal G, see inv are smooth, see for example [HN12, Definition 9.1.1].\n\nLie groups are named after the Norwegian mathematician Marius Sophus Lie (1842‚Äì1899).\n\nFields\n\nmanifold: an AbstractManifold mathcal M\nop: an AbstractGroupOperation  on that manifold\n\nConstructor\n\nLieGroup(M::AbstractManifold, op::AbstractGroupOperation)\n\nGenerate a Lie group based on a manifold M and a group operation op, where vectors by default are stored in the Lie Algebra.\n\n\n\n\n\n","category":"type"},{"location":"interface/group/#Functions-on-Lie-groups","page":"Lie group","title":"Functions on Lie groups","text":"","category":"section"},{"location":"interface/group/","page":"Lie group","title":"Lie group","text":"Modules = [LieGroups]\nPages = [\"src/interface.jl\"]\nOrder = [:function]","category":"page"},{"location":"interface/group/#Base.adjoint-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"Base.adjoint","text":"adjoint(G::LieGroup, g X)\nadjoint!(G::LieGroup, Y, g, X)\n\nCompute the adjoint mathrmAd(g) mathfrak g  mathfrak g, which is defined as the differential diff_conjugate of the conjugate c_g(h) = ghg^-1 evaluated at the Identity h=mathrme. The operation can be performed in-place of Y.\n\n  mathrmAd(g)X = D c_g(mathrme) X qquad X  mathfrak g\n\nsee [HN12, Section 9.2.3].\n\nOn matrix Lie groups the adjoint reads mathrmAd(g)X = gXg^-1.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.exp","page":"Lie group","title":"Base.exp","text":"exp(G::LieGroup, g, X, t::Number=1)\nexp!(G::LieGroup, h, g, X, t::Number=1)\n\nCompute the Lie group exponential map for gmathcal G and Xmathfrak g, where mathfrak g denotes the LieAlgebra of mathcal G. It is given by\n\nexp_g X = gexp_mathcal G(X)\n\nwhere X can be scaled by t, the computation can be performed in-place of h, and exp_mathcal G denotes the  Lie group exponential function.\n\nIf g is the Identity the Lie group exponential function exp_mathcal G is computed directly. Implementing the Lie group exponential function introduces a default implementation with the formula above.\n\nnote: Note\nThe Lie group exponential map is usually different from the exponential map with respect to the metric of the underlying Riemannian manifold mathcal M. To access the (Riemannian) exponential map, use exp(base_manifold(G), g, X).\n\n\n\n\n\n","category":"function"},{"location":"interface/group/#Base.exp-Union{Tuple{O}, Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Identity{O}, Any}, Tuple{LieGroup{ùîΩ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Identity{O}, Any, Number}} where {ùîΩ, O<:AbstractGroupOperation}","page":"Lie group","title":"Base.exp","text":"exp(G::LieGroup, e::Identity, X)\nexp!(G::LieGroup, h, e::Identity, X)\n\nCompute the (Lie group) exponential function\n\nexp_mathcal G mathfrak g  mathcal Gqquad exp_mathcal G(X) = Œ≥_X(1)\n\nwhere Œ≥_X is the unique solution of the initial value problem\n\nŒ≥(0) = mathrme quad Œ≥(t) = Œ≥(t)X\n\nThe computation can be performed in-place of h.\n\nSee also [HN12, Definition 9.2.2].\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.inv-Tuple{LieGroup, Any}","page":"Lie group","title":"Base.inv","text":"inv(G::LieGroup, g)\ninv!(G::LieGroup, h, g)\n\nCompute the inverse group element g^-1 with respect to the AbstractGroupOperation  on the LieGroup mathcal G, that is, return the unique element h=g^-1 such that hg=mathrme, where mathrme denotes the Identity.\n\nThis can be done in-place of h, without side effects, that is you can do inv!(G, g, g).\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.isapprox-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"Base.isapprox","text":"isapprox(M::LieGroup, g, h; kwargs...)\n\nCheck if points g and h from LieGroup are approximately equal. this function calls the corresponding isapprox on the AbstractManifold after handling the cases where one or more of the points are the Identity. All keyword argments are passed to this function as well.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.log-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"Base.log","text":"log(G::LieGroup, g, h)\nlog!(G::LieGroup, X, g, h)\n\nCompute the Lie group logarithmic map log_g mathcal G  mathfrak g, where mathfrak g denotes the LieAlgebra of mathcal G. It is given by\n\nlog_g h = log_mathcal G(g^-1h)\n\nwhere log_mathcal G denotes the Lie group logarithmic function The computation can be performed in-place of X.\n\nIf g is the Identity the Lie group logarithmic function log_mathcal G is computed directly. Implementing the Lie group logarithmic function introduces a default implementation for this function with the formula above.\n\nnote: Note\nThe Lie group logarithmic map is usually different from the logarithmic map with respect to the metric of the underlying Riemannian manifold mathcal M. To access the (Riemannian) logarithmic map, use log(base_manifoldG, g, h).\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.log-Tuple{LieGroup, Identity, Any}","page":"Lie group","title":"Base.log","text":"log(G::LieGroup, e::Identity, g)\nlog!(G::LieGroup, X, e::Identity, g)\n\nCompute the (Lie group) logarithmic function log_mathcal G mathcal G  mathfrak g, which is the inverse of the Lie group exponential function The compuation can be performed in-place of X.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Base.rand-Tuple{LieGroup}","page":"Lie group","title":"Base.rand","text":"rand(::LieGroup; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand(::LieAlgebra; œÉ::Real=1.0, kwargs...)\nrand!(::LieGroup, gX; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, X; œÉ::Real=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.adjoint!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.adjoint!","text":"adjoint(G::LieGroup, g X)\nadjoint!(G::LieGroup, Y, g, X)\n\nCompute the adjoint mathrmAd(g) mathfrak g  mathfrak g, which is defined as the differential diff_conjugate of the conjugate c_g(h) = ghg^-1 evaluated at the Identity h=mathrme. The operation can be performed in-place of Y.\n\n  mathrmAd(g)X = D c_g(mathrme) X qquad X  mathfrak g\n\nsee [HN12, Section 9.2.3].\n\nOn matrix Lie groups the adjoint reads mathrmAd(g)X = gXg^-1.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.compose!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.compose!","text":"compose(G::LieGroup, g, h)\ncompose!(G::LieGroup, k, g, h)\n\nPerform the group oepration g  h for two g h  mathcal G on the LieGroup G. This can also be done in-place of h.\n\ninfo: Info\nThis function also handles the case where g or/and h are the Identity(G). Since this would lead to ambiguities when implementing a new group operations, this function calls _compose and _compose!, respectively, which is meant for the actual computation of group operations on (non-Identity` but maybe its numerical representation) elements.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.conjugate!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.conjugate!","text":"conjugate(G::LieGroup, g, h)\nconjugate!(G::LieGroup, k, g, h)\n\nCompute the conjugation map c_g mathcal G  mathcal G given by c_g(h) = ghg^-1. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.conjugate-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"LieGroups.conjugate","text":"conjugate(G::LieGroup, g, h)\nconjugate!(G::LieGroup, k, g, h)\n\nCompute the conjugation map c_g mathcal G  mathcal G given by c_g(h) = ghg^-1. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_conjugate!-Tuple{LieGroup, Vararg{Any, 4}}","page":"Lie group","title":"LieGroups.diff_conjugate!","text":"diff_conjugate(G::LieGroup, g, h, X)\ndiff_conjugate!(G::LieGroup, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1, which can be performed in-place of Y.\n\n  D(c_g(h))X qquad X  mathfrak g\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_conjugate-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.diff_conjugate","text":"diff_conjugate(G::LieGroup, g, h, X)\ndiff_conjugate!(G::LieGroup, Y, g, h, X)\n\nCompute the differential of the conjugate c_g(h) = ghg^-1, which can be performed in-place of Y.\n\n  D(c_g(h))X qquad X  mathfrak g\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_inv!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.diff_inv!","text":"diff_inv(G::LieGroup, g, X)\ndiff_inv!(G::LieGroup, Y, g, X)\n\nCompute the differential of the function Œπ_mathcal G(g) = g^-1, where DŒπ_mathcal G(g) mathfrak g  mathfrak g. This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_inv-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"LieGroups.diff_inv","text":"diff_inv(G::LieGroup, g, X)\ndiff_inv!(G::LieGroup, Y, g, X)\n\nCompute the differential of the function Œπ_mathcal G(g) = g^-1, where DŒπ_mathcal G(g) mathfrak g  mathfrak g. This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_left_compose!-Tuple{LieGroup, Vararg{Any, 4}}","page":"Lie group","title":"LieGroups.diff_left_compose!","text":"diff_left_compose(G::LieGroup, g, h, X)\ndiff_left_compose!(G::LieGroup, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh, on the LieGroup G, that is Compute DŒª_g(h)X, X  ùî§. This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_left_compose-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.diff_left_compose","text":"diff_left_compose(G::LieGroup, g, h, X)\ndiff_left_compose!(G::LieGroup, Y, g, h, X)\n\nCompute the differential of the left group multiplication Œª_g(h) = gh, on the LieGroup G, that is Compute DŒª_g(h)X, X  ùî§. This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_right_compose!-Tuple{LieGroup, Vararg{Any, 4}}","page":"Lie group","title":"LieGroups.diff_right_compose!","text":"diff_right_compose(G::LieGroup, h, g, X)\ndiff_right_compose!(G::LieGroup, Y, h, g, X)\n\nCompute the differential of the right group multiplication œÅ_g(h) = hg, on the LieGroup G, that is Compute DœÅ_g(h)X, X  ùî§ This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.diff_right_compose-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.diff_right_compose","text":"diff_right_compose(G::LieGroup, h, g, X)\ndiff_right_compose!(G::LieGroup, Y, h, g, X)\n\nCompute the differential of the right group multiplication œÅ_g(h) = hg, on the LieGroup G, that is Compute DœÅ_g(h)X, X  ùî§ This can be done in-place of Y.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.identity_element!-Tuple{LieGroup, Any}","page":"Lie group","title":"LieGroups.identity_element!","text":"identity_element(G::LieGroup)\nidentity_element!(G::LieGroup, e)\n\nReturn a point representation of the Identity on the LieGroup G. By default this representation is the default array or number representation. It should return the corresponding default representation of e as a point on G if points are not represented by arrays. This can be performed in-place of e.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv!-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"LieGroups.inv!","text":"inv(G::LieGroup, g)\ninv!(G::LieGroup, h, g)\n\nCompute the inverse group element g^-1 with respect to the AbstractGroupOperation  on the LieGroup mathcal G, that is, return the unique element h=g^-1 such that hg=mathrme, where mathrme denotes the Identity.\n\nThis can be done in-place of h, without side effects, that is you can do inv!(G, g, g).\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv_left_compose!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.inv_left_compose!","text":"compose(G::LieGroup, g, h)\ncompose!(G::LieGroup, k, g, h)\n\nPerform the group oepration g  h for two g h  mathcal G on the LieGroup G. This can also be done in-place of h.\n\ninfo: Info\nThis function also handles the case where g or/and h are the Identity(G). Since this would lead to ambiguities when implementing a new group operations, this function calls _compose and _compose!, respectively, which is meant for the actual computation of group operations on (non-Identity` but maybe its numerical representation) elements.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv_left_compose-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"LieGroups.inv_left_compose","text":"inv_left_compose(G::LieGroup, g, h)\ninv_left_compose!(G::LieGroup, k, g, h)\n\nCompute the inverse of the left group operation Œª_g(h) = gh, on the LieGroup G, that is, compute Œª_g^-1(h) = g^-1h. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv_right_compose!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"LieGroups.inv_right_compose!","text":"inv_right_compose(G::LieGroup, h, g)\ninv_right_compose!(G::LieGroup, k, h, g)\n\nCompute the inverse of the right group operation œÅ_g(h) = hg, on the LieGroup G, that is compute œÅ_g^-1(h) = hg^-1. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#LieGroups.inv_right_compose-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"LieGroups.inv_right_compose","text":"inv_right_compose(G::LieGroup, h, g)\ninv_right_compose!(G::LieGroup, k, h, g)\n\nCompute the inverse of the right group operation œÅ_g(h) = hg, on the LieGroup G, that is compute œÅ_g^-1(h) = hg^-1. This can be done in-place of k.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Manifolds.compose-Tuple{LieGroup, Any, Any}","page":"Lie group","title":"Manifolds.compose","text":"compose(G::LieGroup, g, h)\ncompose!(G::LieGroup, k, g, h)\n\nPerform the group oepration g  h for two g h  mathcal G on the LieGroup G. This can also be done in-place of h.\n\ninfo: Info\nThis function also handles the case where g or/and h are the Identity(G). Since this would lead to ambiguities when implementing a new group operations, this function calls _compose and _compose!, respectively, which is meant for the actual computation of group operations on (non-Identity` but maybe its numerical representation) elements.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Manifolds.identity_element-Tuple{LieGroup}","page":"Lie group","title":"Manifolds.identity_element","text":"identity_element(G::LieGroup)\nidentity_element!(G::LieGroup, e)\n\nReturn a point representation of the Identity on the LieGroup G. By default this representation is the default array or number representation. It should return the corresponding default representation of e as a point on G if points are not represented by arrays. This can be performed in-place of e.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Manifolds.is_identity-Tuple{LieGroup, Any}","page":"Lie group","title":"Manifolds.is_identity","text":"is_identity(G::LieGroup, q; kwargs)\n\nCheck whether q is the identity on the LieGroup mathcal G. This means it is either the Identity{O} with the respect to the corresponding AbstractGroupOperation O, or (approximately) the correct point representation.\n\nSee also\n\nidentity_element, identity_element!\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.base_manifold-Tuple{LieGroup}","page":"Lie group","title":"ManifoldsBase.base_manifold","text":"base_manifold(G::LieGroup)\n\nReturn the manifold stored within the LieGroup G.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.exp!","page":"Lie group","title":"ManifoldsBase.exp!","text":"exp(G::LieGroup, g, X, t::Number=1)\nexp!(G::LieGroup, h, g, X, t::Number=1)\n\nCompute the Lie group exponential map for gmathcal G and Xmathfrak g, where mathfrak g denotes the LieAlgebra of mathcal G. It is given by\n\nexp_g X = gexp_mathcal G(X)\n\nwhere X can be scaled by t, the computation can be performed in-place of h, and exp_mathcal G denotes the  Lie group exponential function.\n\nIf g is the Identity the Lie group exponential function exp_mathcal G is computed directly. Implementing the Lie group exponential function introduces a default implementation with the formula above.\n\nnote: Note\nThe Lie group exponential map is usually different from the exponential map with respect to the metric of the underlying Riemannian manifold mathcal M. To access the (Riemannian) exponential map, use exp(base_manifold(G), g, X).\n\n\n\n\n\n","category":"function"},{"location":"interface/group/#ManifoldsBase.exp!-Union{Tuple{Op}, Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, Op, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Identity{Op}, Any}, Tuple{LieGroup{ùîΩ, Op, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Any, Identity{Op}, Any, Number}} where {ùîΩ, Op<:AbstractGroupOperation}","page":"Lie group","title":"ManifoldsBase.exp!","text":"exp(G::LieGroup, e::Identity, X)\nexp!(G::LieGroup, h, e::Identity, X)\n\nCompute the (Lie group) exponential function\n\nexp_mathcal G mathfrak g  mathcal Gqquad exp_mathcal G(X) = Œ≥_X(1)\n\nwhere Œ≥_X is the unique solution of the initial value problem\n\nŒ≥(0) = mathrme quad Œ≥(t) = Œ≥(t)X\n\nThe computation can be performed in-place of h.\n\nSee also [HN12, Definition 9.2.2].\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.get_coordinates!-Tuple{LieGroup, Any, Any, Any, ManifoldsBase.AbstractBasis}","page":"Lie group","title":"ManifoldsBase.get_coordinates!","text":"exp(G::LieGroup, e::Identity, X)\nexp!(G::LieGroup, h, e::Identity, X)\n\nCompute the (Lie group) exponential function\n\nexp_mathcal G mathfrak g  mathcal Gqquad exp_mathcal G(X) = Œ≥_X(1)\n\nwhere Œ≥_X is the unique solution of the initial value problem\n\nŒ≥(0) = mathrme quad Œ≥(t) = Œ≥(t)X\n\nThe computation can be performed in-place of h.\n\nSee also [HN12, Definition 9.2.2].\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.get_coordinates-Tuple{LieGroup, Any, Any, ManifoldsBase.AbstractBasis}","page":"Lie group","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(G::LieGroup, g, X, B::AbstractBasis)\nget_coordinates(ùî§::LieAlgebra, X, B::AbstractBasis)\nget_coordinates!(G::LieGroup, c, g, X, B::AbstractBasis)\nget_coordinates!(ùî§::LieAlgebra, c, X, B::AbstractBasis)\n\nReturn the vector of coordinates to the decomposition of X with respect to an AbstractBasis of the LieAlgebra ùî§. Since all tangent vectors are assumed to be represented in the Lie algebra, both signatures are equivalent. The operation can be performed in-place of c.\n\nBy default this function requires identity_element(G) and calls the corresponding get_coordinates function of the Riemannian manifold the Lie group is build on.\n\nThe inverse operation is get_vector.\n\nSee also vee.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.get_vector!-Tuple{LieGroup, Any, Any, Any, ManifoldsBase.AbstractBasis}","page":"Lie group","title":"ManifoldsBase.get_vector!","text":"exp(G::LieGroup, e::Identity, X)\nexp!(G::LieGroup, h, e::Identity, X)\n\nCompute the (Lie group) exponential function\n\nexp_mathcal G mathfrak g  mathcal Gqquad exp_mathcal G(X) = Œ≥_X(1)\n\nwhere Œ≥_X is the unique solution of the initial value problem\n\nŒ≥(0) = mathrme quad Œ≥(t) = Œ≥(t)X\n\nThe computation can be performed in-place of h.\n\nSee also [HN12, Definition 9.2.2].\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.get_vector-Tuple{LieGroup, Any, Any, ManifoldsBase.AbstractBasis}","page":"Lie group","title":"ManifoldsBase.get_vector","text":"get_vector(G::LieGroup, g, c, B::AbstractBasis)\nget_vector(ùî§::LieAlgebra, c, B::AbstractBasis)\nget_vector!(G::LieGroup, X, g, c, B::AbstractBasis)\nget_vector!(ùî§::LieAlgebra, X, c, B::AbstractBasis)\n\nReturn the vector corresponding to a set of coefficients in an AbstractBasis of the LieAlgebra ùî§. Since all tangent vectors are assumed to be represented in the Lie algebra, both signatures are equivalend. The operation can be performed in-place of a tangent vector X.\n\nBy default this function requires identity_element(G) and calls the corresponding get_vector function of the Riemannian manifold the Lie group is build on.\n\nThe inverse operation is get_coordinates.\n\nSee also hat\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.hat!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, O, M} where {O<:AbstractGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any}} where ùîΩ","page":"Lie group","title":"ManifoldsBase.hat!","text":"hat(G::LieGroup, c)\nhat!(G::LieGroup, X, c)\n\nCompute the hat map ()^ that maps a vector of coordinates c_i with respect to a certain basis to a tangent vector in the Lie algebra\n\nX = sum_imathcal I c_iB_i\n\nwhere  B_i _imathcal I is a basis of the Lie algebra and mathcal I a corresponding index set, which is usually mathcal I= 1ldotsn .\n\nThe computation can be performed in-place of X. The inverse of hat is vee.\n\nTechnically, hat is a specific case of get_vector and is implemented using the LieAlgebraOrthogonalBasis\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.hat-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, O, M} where {O<:AbstractGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any}} where ùîΩ","page":"Lie group","title":"ManifoldsBase.hat","text":"hat(G::LieGroup, c)\nhat!(G::LieGroup, X, c)\n\nCompute the hat map ()^ that maps a vector of coordinates c_i with respect to a certain basis to a tangent vector in the Lie algebra\n\nX = sum_imathcal I c_iB_i\n\nwhere  B_i _imathcal I is a basis of the Lie algebra and mathcal I a corresponding index set, which is usually mathcal I= 1ldotsn .\n\nThe computation can be performed in-place of X. The inverse of hat is vee.\n\nTechnically, hat is a specific case of get_vector and is implemented using the LieAlgebraOrthogonalBasis\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.is_point-Tuple{LieGroup, Any}","page":"Lie group","title":"ManifoldsBase.is_point","text":"is_point(G::LieGroup, g; kwargs...)\n\nCheck whether g is a valid point on the Lie Group G. This falls back to checking whether g is a valid point on G.manifold, unless g is an Identity. Then, it is checked whether it is the identity element corresponding to G.\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.is_vector-Tuple{LieGroup, Any}","page":"Lie group","title":"ManifoldsBase.is_vector","text":"is_vector(G::LieGroup, X; kwargs...)\nis_vector(G::LieGroup{ùîΩ,O}, e::Indentity{O}, X; kwargs...)\n\nCheck whether X is a tangent vector, that is an element of the LieAlgebra of G. The first variant calls is_point on the LieAlgebra ùî§ of G. The second variant calls is_vector on the AbstractManifold at the identity_element.\n\nAll keyword arguments are passed on to the corresponding call\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.is_vector-Union{Tuple{O}, Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ}, Identity{O}, Any}} where {ùîΩ, O<:AbstractGroupOperation}","page":"Lie group","title":"ManifoldsBase.is_vector","text":"is_vector(G::LieGroup, X; kwargs...)\nis_vector(G::LieGroup{ùîΩ,O}, e::Indentity{O}, X; kwargs...)\n\nCheck whether X is a tangent vector, that is an element of the LieAlgebra of G. The first variant calls is_point on the LieAlgebra ùî§ of G. The second variant calls is_vector on the AbstractManifold at the identity_element.\n\nAll keyword arguments are passed on to the corresponding call\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.log!-Tuple{LieGroup, Any, Any, Any}","page":"Lie group","title":"ManifoldsBase.log!","text":"log(G::LieGroup, g, h)\nlog!(G::LieGroup, X, g, h)\n\nCompute the Lie group logarithmic map log_g mathcal G  mathfrak g, where mathfrak g denotes the LieAlgebra of mathcal G. It is given by\n\nlog_g h = log_mathcal G(g^-1h)\n\nwhere log_mathcal G denotes the Lie group logarithmic function The computation can be performed in-place of X.\n\nIf g is the Identity the Lie group logarithmic function log_mathcal G is computed directly. Implementing the Lie group logarithmic function introduces a default implementation for this function with the formula above.\n\nnote: Note\nThe Lie group logarithmic map is usually different from the logarithmic map with respect to the metric of the underlying Riemannian manifold mathcal M. To access the (Riemannian) logarithmic map, use log(base_manifoldG, g, h).\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.vee!-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, O, M} where {O<:AbstractGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any, Any}} where ùîΩ","page":"Lie group","title":"ManifoldsBase.vee!","text":"vee(G::LieGroup, X)\nvee!(G::LieGroup, c, X)\n\nCompute the vee map ()^ that maps a tangent vector X from the LieAlgebra to its coordinates with respect to the LieAlgebraOrthogonalBasis basis in the Lie algebra\n\nX = sum_imathcal I c_iB_i\n\nwhere  B_i _imathcal I is a basis of the Lie algebra and mathcal I a corresponding index set, which is usually mathcal I= 1ldotsn .\n\nThe computation can be performed in-place of c. The inverse of vee is hat.\n\nTechnically, vee is a specific case of get_coordinates and is implemented using the LieAlgebraOrthogonalBasis\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#ManifoldsBase.vee-Union{Tuple{ùîΩ}, Tuple{LieGroup{ùîΩ, O, M} where {O<:AbstractGroupOperation, M<:ManifoldsBase.AbstractManifold{ùîΩ}}, Any}} where ùîΩ","page":"Lie group","title":"ManifoldsBase.vee","text":"vee(G::LieGroup, X)\nvee!(G::LieGroup, c, X)\n\nCompute the vee map ()^ that maps a tangent vector X from the LieAlgebra to its coordinates with respect to the LieAlgebraOrthogonalBasis basis in the Lie algebra\n\nX = sum_imathcal I c_iB_i\n\nwhere  B_i _imathcal I is a basis of the Lie algebra and mathcal I a corresponding index set, which is usually mathcal I= 1ldotsn .\n\nThe computation can be performed in-place of c. The inverse of vee is hat.\n\nTechnically, vee is a specific case of get_coordinates and is implemented using the LieAlgebraOrthogonalBasis\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Random.rand!-Tuple{LieGroup, Any}","page":"Lie group","title":"Random.rand!","text":"rand(::LieGroup; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand(::LieAlgebra; œÉ::Real=1.0, kwargs...)\nrand!(::LieGroup, gX; vector_at=nothing, œÉ::Real=1.0, kwargs...)\nrand!(::LieAlgebra, X; œÉ::Real=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"interface/group/#Literature","page":"Lie group","title":"Literature","text":"","category":"section"},{"location":"interface/group/","page":"Lie group","title":"Lie group","text":"J.¬†Hilgert and K.-H.¬†Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\n","category":"page"},{"location":"interface/algebra/#An-interface-for-Lie-algebras","page":"Lie algebra","title":"An interface for Lie algebras","text":"","category":"section"},{"location":"interface/algebra/","page":"Lie algebra","title":"Lie algebra","text":"LieAlgebra\nLieAlgebraOrthogonalBasis","category":"page"},{"location":"interface/algebra/#LieGroups.LieAlgebra","page":"Lie algebra","title":"LieGroups.LieAlgebra","text":"LieAlgebra{ùîΩ, G} <: AbstractManifold{ùîΩ}\n\nRepresent the Lie algebra mathfrak g, that is a ùîΩ vector space with an associated lie_bracket  mathfrak gmathfrak g  mathfrak g which fulfills\n\nXX = 0 for all X  mathfrak g\nThe Jacobi identity X YZ = XYZ = Y XZ holds for all X Y Z  mathfrak g.\n\nThe Lie algebras considered here are those related to a LieGroup mathcal G, namely the tangent space T_mathrmemathcal G at the Identity, this is internally just a const of the corresponding TangentSpace.\n\nnote: Convention for representing tangent vectors in the Lie algebra\nA vector field mathcal X mathcal G  Tmathcal G, X(g)  T_gmathcal G is called a left-invariant vector field if it satisfiesmathcal X(Œª_g(h)) = DŒª_g(h)mathcal X(h) quadtextfor allquad g h  mathcal Gwhere Œª_g mathcal G  mathcal G is the left multiplication by g. Hence mathcal X is determined already when X  mathfrak g is given, since mathcal X(g) = DŒª_g(e)X, cf [HN12, Definition 9.1.7].Throughout LieGroups.jl, we use this left-invariant convention to store tangent vectors at points on a Lie group as elements of the corresponding Lie algebra.\n\nConstructor\n\nLieAlgebra(G::LieGroup)\n\nReturn the Lie Algebra belonging to the LieGroup G.\n\n\n\n\n\n","category":"type"},{"location":"interface/algebra/#LieGroups.LieAlgebraOrthogonalBasis","page":"Lie algebra","title":"LieGroups.LieAlgebraOrthogonalBasis","text":"LieAlgebraOrthogonalBasis{ùîΩ} <: ManifoldsBase.AbstractOrthogonalBasis{ùîΩ,ManifoldsBase.TangentSpaceType}\n\nSpecify an orthogonal basis for a Lie algebra. This is used as the default within hat and vee.\n\nIf not specifically overwritten/implemented for a Lie group, the DefaultOrthogonalBasis at the identity_element on the `base_manifold acts as a fallback.\n\nnote: Note\nIn order to implement the corresponding get_coordinates and get_vector functions, define get_coordiinates_lie(::LieGroup, p, X, N) and get_vector_lie(::LieGroup, p, X, N), resp.\n\n\n\n\n\n","category":"type"},{"location":"interface/algebra/#Functions-on-Lie-algebras","page":"Lie algebra","title":"Functions on Lie algebras","text":"","category":"section"},{"location":"interface/algebra/","page":"Lie algebra","title":"Lie algebra","text":"Modules = [LieGroups]\nPages = [\"src/Lie_algebra/Lie_algebra_interface.jl\"]\nOrder = [:function]","category":"page"},{"location":"interface/algebra/#Base.rand-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(LieGroup{ùîΩ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ})}}","page":"Lie algebra","title":"Base.rand","text":"rand(::LieGroup; vector_at=nothing, œÉ=1.0, kwargs...)\nrand(::LieAlgebra; œÉ=1.0, kwargs...)\nrand!(::LieGroup, gX; vector_at=nothing, kwargs...)\nrand!(::LieAlgebra, X; œÉ=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#LieGroups.lie_bracket!-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(LieGroup{ùîΩ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ})}, Any, Any, Any}","page":"Lie algebra","title":"LieGroups.lie_bracket!","text":"lie_bracket!(ùî§::LieAlgebra, X, Y)\nlie_bracket!(ùî§::LieAlgebra, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g which fulfills\n\nXX = 0 for all X  mathfrak g\nThe Jacobi identity X YZ = XYZ = Y XZ holds for all X Y Z  mathfrak g.\n\nThe computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#LieGroups.lie_bracket-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(LieGroup{ùîΩ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ})}, Any, Any}","page":"Lie algebra","title":"LieGroups.lie_bracket","text":"lie_bracket!(ùî§::LieAlgebra, X, Y)\nlie_bracket!(ùî§::LieAlgebra, Z, X, Y)\n\nCompute the Lie bracket  mathfrak gmathfrak g  mathfrak g which fulfills\n\nXX = 0 for all X  mathfrak g\nThe Jacobi identity X YZ = XYZ = Y XZ holds for all X Y Z  mathfrak g.\n\nThe computation can be done in-place of Z.\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#ManifoldsBase.is_point-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(LieGroup{ùîΩ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ})}, Any}","page":"Lie algebra","title":"ManifoldsBase.is_point","text":"is_point(ùî§::LieAlgebra, X; kwargs...)\n\nCheck whether X is a valid point on the Lie Algebra ùî§. This falls back to checking whether X is a valid point on the tangent space at the identity_element(G) on G.manifold on the LieGroup of G\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#Random.rand!-Tuple{ManifoldsBase.Fiber{ùîΩ, ManifoldsBase.TangentSpaceType, G, Identity{O}} where {ùîΩ, O<:AbstractGroupOperation, G<:(LieGroup{ùîΩ, O, M} where M<:ManifoldsBase.AbstractManifold{ùîΩ})}, Any}","page":"Lie algebra","title":"Random.rand!","text":"rand(::LieGroup; vector_at=nothing, œÉ=1.0, kwargs...)\nrand(::LieAlgebra; œÉ=1.0, kwargs...)\nrand!(::LieGroup, gX; vector_at=nothing, kwargs...)\nrand!(::LieAlgebra, X; œÉ=1.0, kwargs...)\n\nCompute a random point or tangent vector on a Lie group.\n\nFor points this just means to generate a random point on the underlying manifold itself.\n\nFor tangent vectors, an element in the Lie Algebra is generated, see also rand(::LieAlgebra; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"interface/algebra/#Literature","page":"Lie algebra","title":"Literature","text":"","category":"section"},{"location":"interface/algebra/","page":"Lie algebra","title":"Lie algebra","text":"J.¬†Hilgert and K.-H.¬†Neeb. Structure and Geometry of Lie Groups (Springer Monographs in Mathematics, 2012).\n\n\n\n","category":"page"},{"location":"groups/semidirect_product_group/#The-semidirect-product-Lie-group","page":"Semidirect product group","title":"The semidirect product Lie group","text":"","category":"section"},{"location":"groups/semidirect_product_group/","page":"Semidirect product group","title":"Semidirect product group","text":"Modules = [LieGroups]\nPages = [\"groups/semidirect_product_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/semidirect_product_group/#LieGroups.LeftSemidirectProductGroupOperation","page":"Semidirect product group","title":"LieGroups.LeftSemidirectProductGroupOperation","text":"LeftSemidirectProductGroupOperation{O1,O2,A} <: AbstractGroupOperation\n\nA struct to model a semidirect Lie group product.\n\nLet (mathcal N ) and (mathcal H ) be two Lie groups with group operations  and , respectively, as well as a group action œÉ mathcal Hmathcal N  mathcal N, cf AbstractLeftGroupActionType.\n\nWe use here as well use the notation œÉ_h mathcal N  mathcal N as a family of maps on mathcal N\n\nThen we define a group operation  on the product manifold mathcal Nmathcal H by\n\n    (h_1n_1)  (h_2n_2) = (h_1  h_2 œÉ_h_2(n_1)  n_1)\n\nSee [HN12, Definition 9.2.22], second definition for more details.\n\nConstructor\n\nLeftSemidirectProductGroupOperation(\n    op1::AbstractGroupOperation,\n    op2::AbstractGroupOperation,\n    action::AbstractGroupActionType\n)\n\nParameters\n\nop1::AbstractGroupOperation: The group operation  on mathcal H\nop2::AbstractGroupOperation: The group operation  on mathcal N\naction::AbstractGroupActionType The group action œÉ of mathcal H on mathcal N\n\n\n\n\n\n","category":"type"},{"location":"groups/semidirect_product_group/#LieGroups.RightSemidirectProductGroupOperation","page":"Semidirect product group","title":"LieGroups.RightSemidirectProductGroupOperation","text":"RightSemidirectProductGroupOperation{O1,O2,A} <: AbstractGroupOperation\n\nA struct to model a semidirect Lie group product.\n\nLet (mathcal N ) and (mathcal H ) be two Lie groups with group operations  and , respectively, as well as a group action œÉ mathcal Hmathcal N  mathcal N, cf AbstractGroupActionType.\n\nWe use here as well use the notation œÉ_h mathcal N  mathcal N as a family of maps on mathcal N\n\nThen we define a group operation  on the product manifold mathcal Nmathcal H by\n\n    (n_1h_1)  (n_2h_2) = (n_1  œÉ_h_1(n_2) h_1  h_2)\n\nSee [HN12, Definition 9.2.22], first definition for more details.\n\nConstructor\n\nRightSemidirectProductGroupOperation(\n    op1::AbstractGroupOperation,\n    op2::AbstractGroupOperation,\n    action::AbstractGroupActionType\n)\n\nParameters\n\nop1::AbstractGroupOperation: The group operation  on mathcal N\nop2::AbstractGroupOperation: The group operation  on mathcal H\naction::AbstractGroupActionType: The group action œÉ of mathcal H on mathcal N\n\n\n\n\n\n","category":"type"},{"location":"groups/semidirect_product_group/#LieGroups.:‚ãâ-Tuple{LieGroup, LieGroup}","page":"Semidirect product group","title":"LieGroups.:‚ãâ","text":"L1 ‚ãâ L2\n‚ãâ(L1, L2)\n\nFor two LieGroups L1, L2, generate the LeftSemidirectProductLieGroup(L1, L2), where the corresponding default_left_action(L1, L2) is used.\n\n\n\n\n\n","category":"method"},{"location":"groups/semidirect_product_group/#LieGroups.:‚ãä-Tuple{LieGroup, LieGroup}","page":"Semidirect product group","title":"LieGroups.:‚ãä","text":"L1 ‚ãä L2\n‚ãä(L1, L2)\n\nFor two LieGroups L1, L2, generate the RightSemidirectProductLieGroup(L1, L2), where the corresponding default_right_action(L1, L2) is used.\n\n\n\n\n\n","category":"method"},{"location":"groups/semidirect_product_group/#LieGroups.LeftSemidirectProductLieGroup","page":"Semidirect product group","title":"LieGroups.LeftSemidirectProductLieGroup","text":"LeftSemidirectProductLieGroup(\n    N::LieGroup, H::LieGroup, action::AbstractGroupActionType=default_left_action(N, H)\n)\n\nGenerate the semidirect product Lie Group mathcal G = N  H for an AbstractLeftGroupActionType using the LeftSemidirectProductGroupOperation for the group operation definition as well as [HN12, Definition 9.2.22], second definition, for more details.\n\nThe short form N‚ãâH can be used if the corresponding default_left_action(N,H) is the one you want to use.\n\n\n\n\n\n","category":"function"},{"location":"groups/semidirect_product_group/#LieGroups.RightSemidirectProductLieGroup","page":"Semidirect product group","title":"LieGroups.RightSemidirectProductLieGroup","text":"RightSemidirectProductLieGroup(\n    N::LieGroup, H::LieGroup, action::AbstractGroupActionType=default_right_action(N,H)\n)\n\nGenerate the semidirect product Lie Group mathcal G = N  H for an AbstractLeftGroupActionType using the RightSemidirectProductGroupOperation for the group operation definition as well as [HN12, Definition 9.2.22], first definition, for more details.\n\nThe short form N‚ãäH can be used if the corresponding default_right_action(N,H) is the one you want to use.\n\n\n\n\n\n","category":"function"},{"location":"groups/general_linear/#The-general-linear-group","page":"General Linear","title":"The general linear group","text":"","category":"section"},{"location":"groups/general_linear/","page":"General Linear","title":"General Linear","text":"Modules = [LieGroups]\nPages = [\"groups/general_linear_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/general_linear/#LieGroups.GeneralLinearGroup","page":"General Linear","title":"LieGroups.GeneralLinearGroup","text":"GeneralLinearGroup{ùîΩ,T}\n\nThe general linear group mathrmGL(n) is the set of all invertible matrices\n\nmathrmGL(n) = bigl g  ùîΩ^nn big mathrmdet(p)  0bigr \nqquad ùîΩ   ‚Ñù ‚ÑÇ \n\nequipped with the MatrixMultiplicationGroupOperation as the group operation.\n\nThe set of invertible matrices is a Riemannian manifold, since it inherits its structure from the embedding as an open subset of the space of matrices ‚Ñù^nn.\n\nConstructor\n\nGeneralLinearGroup(n::Int; field=‚Ñù, kwargs...)\n\nGenerate the general linear group  group on ùîΩ^nn. All keyword arguments in kwargs... are passed on to InvertibleMatrices.\n\n\n\n\n\n","category":"type"},{"location":"groups/general_linear/#Base.exp-Tuple{GeneralLinearGroup, Identity{MatrixMultiplicationGroupOperation}, Any}","page":"General Linear","title":"Base.exp","text":"exp(::GeneralLinearGroup, ::Identity{MatrixMultiplicationGroupOperation}, X)\nexp!(::GeneralLinearGroup, g, ::Identity{MatrixMultiplicationGroupOperation}, X)\n\nCompute the Lie group exponential on the GeneralLinearGroup, which is given by the matrix exponential\n\nexp X = sum_k=0^ frac1kX^k\n\nsee also [HN12, Example 9.2.3 (b)]\n\n\n\n\n\n","category":"method"},{"location":"groups/general_linear/#ManifoldsBase.exp!-Tuple{GeneralLinearGroup, Any, Identity{MatrixMultiplicationGroupOperation}, Any}","page":"General Linear","title":"ManifoldsBase.exp!","text":"exp(::GeneralLinearGroup, ::Identity{MatrixMultiplicationGroupOperation}, X)\nexp!(::GeneralLinearGroup, g, ::Identity{MatrixMultiplicationGroupOperation}, X)\n\nCompute the Lie group exponential on the GeneralLinearGroup, which is given by the matrix exponential\n\nexp X = sum_k=0^ frac1kX^k\n\nsee also [HN12, Example 9.2.3 (b)]\n\n\n\n\n\n","category":"method"},{"location":"groups/#An-overview-of-Lie-groups","page":"List of Lie groups","title":"An overview of Lie groups","text":"","category":"section"},{"location":"groups/#Alphabetical-list-of-Lie-groups","page":"List of Lie groups","title":"Alphabetical list of Lie groups","text":"","category":"section"},{"location":"groups/","page":"List of Lie groups","title":"List of Lie groups","text":"Group Manifold  Comment\nGeneralLinearGroup InvertibleMatrices * \nTranslationGroup Euclidean + ","category":"page"},{"location":"groups/power_group/#The-power-Lie-group","page":"Power group","title":"The power Lie group","text":"","category":"section"},{"location":"groups/power_group/","page":"Power group","title":"Power group","text":"Modules = [LieGroups]\nPages = [\"groups/power_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/power_group/#LieGroups.PowerGroupOperation","page":"Power group","title":"LieGroups.PowerGroupOperation","text":"PowerGroupOperation{O<:AbstractGroupOperation} <: AbstractGroupOperation\n\nA struct do model a that a certain group operation is applied element-wise on a PowerManifold.\n\nConstructor\n\nPowerGroupOperation(o::AbstractGroupOperation)\n\n\n\n\n\n","category":"type"},{"location":"groups/power_group/#LieGroups.PowerLieGroup-Tuple{ManifoldsBase.AbstractManifold, Vararg{Any}}","page":"Power group","title":"LieGroups.PowerLieGroup","text":"PowerLieGroup(G::LieGroup, args...; kwargs...)\n(G::LieGroup)^(n::Integer) = PowerLieGroup(G, n)\n\nGenerate the LieGroup of the n-th power of a Lie group G or manifold M. If passed a Lie group G, the group operation on the PowerLieGroup is the same as on G, but applied elementwise. Internally, the corresponding PowerGroupOperation is created. If you pass a manifold M, you have to provide the corresponding PowerGroupOperation yourself.\n\nBot the arguments args... as well as the keyword arguments kwargs... are passed on to the constructor of the PowerManifold. This especially includes the size of the manifold and allows to specify a NestedPowerRepresentation.\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#The-Heisenberg-group","page":"Heisenberg","title":"The Heisenberg group","text":"","category":"section"},{"location":"groups/heisenberg_group/","page":"Heisenberg","title":"Heisenberg","text":"Modules = [LieGroups]\nPages = [\"groups/heisenberg_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/heisenberg_group/#LieGroups.HeisenbergGroup","page":"Heisenberg","title":"LieGroups.HeisenbergGroup","text":"HeisenbergGroup{T} <: AbstractDecoratorManifold{‚Ñù}\n\nHeisenberg group HeisenbergGroup(n) is the group of (n+2)(n+2) matrices [BP08]\n\nbeginbmatrix 1  mathbfa  c \nmathbf0  I_n  mathbfb \n0  mathbf0  1 endbmatrix\n\nwhere I_n is the nn unit matrix, mathbfa is a row vector of length n, mathbfb is a column vector of length n and c is a real number. The group operation is matrix multiplication.\n\nThe left-invariant metric on the manifold is used.\n\n\n\n\n\n","category":"type"},{"location":"groups/heisenberg_group/#Base.exp-Tuple{HeisenbergGroup, Any, Any}","page":"Heisenberg","title":"Base.exp","text":"exp(G::HeisenbergGroup, g, X)\n\nExponential map on the HeisenbergGroup G with the left-invariant metric. The expression reads\n\nexp_beginbmatrix 1  mathbfa_p  c_p \nmathbf0  I_n  mathbfb_p \n0  mathbf0  1 endbmatrixleft(beginbmatrix 0  mathbfa_X  c_X \nmathbf0  0_n  mathbfb_X \n0  mathbf0  0 endbmatrixright) =\nbeginbmatrix 1  mathbfa_p + mathbfa_X  c_p + c_X + mathbfa_Xmathbfb_X2 + mathbfa_pmathbfb_X \nmathbf0  I_n  mathbfb_p + mathbfb_X \n0  mathbf0  1 endbmatrix\n\nwhere I_n is the nn identity matrix, 0_n is the nn zero matrix and mathbfamathbfb is dot product of vectors.\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#Base.exp-Tuple{HeisenbergGroup, Identity{MatrixMultiplicationGroupOperation}, Any}","page":"Heisenberg","title":"Base.exp","text":"exp(G::HeisenbergGroup, ::Identity{MatrixMultiplicationGroupOperation}, X)\n\nLie group exponential for the HeisenbergGroup G of the vector X. The formula reads\n\nexpleft(beginbmatrix 0  mathbfa  c \nmathbf0  0_n  mathbfb \n0  mathbf0  0 endbmatrixright) = beginbmatrix 1  mathbfa  c + mathbfamathbfb2 \nmathbf0  I_n  mathbfb \n0  mathbf0  1 endbmatrix\n\nwhere I_n is the nn identity matrix, 0_n is the nn zero matrix and mathbfamathbfb is dot product of vectors.\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#Base.log-Tuple{HeisenbergGroup, Any, Any}","page":"Heisenberg","title":"Base.log","text":"log(G::HeisenbergGroup, g, h)\n\nCompute the logarithmic map on the HeisenbergGroup group. The formula reads\n\nlog_beginbmatrix 1  mathbfa_p  c_p \nmathbf0  I_n  mathbfb_p \n0  mathbf0  1 endbmatrixleft(beginbmatrix 1  mathbfa_q  c_q \nmathbf0  I_n  mathbfb_q \n0  mathbf0  1 endbmatrixright) =\nbeginbmatrix 0  mathbfa_q - mathbfa_p  c_q - c_p + mathbfa_pmathbfb_p - mathbfa_qmathbfb_q - (mathbfa_q - mathbfa_p)(mathbfb_q - mathbfb_p)  2 \nmathbf0  0_n  mathbfb_q - mathbfb_p \n0  mathbf0  0 endbmatrix\n\nwhere I_n is the nn identity matrix, 0_n is the nn zero matrix and mathbfamathbfb is dot product of vectors.\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#Base.log-Tuple{HeisenbergGroup, Identity{MatrixMultiplicationGroupOperation}, Any}","page":"Heisenberg","title":"Base.log","text":"log(G::HeisenbergGroup, ::Identity{MatrixMultiplicationGroupOperation}, g)\n\nLie group logarithm for the HeisenbergGroup G of the point g. The formula reads\n\nlogleft(beginbmatrix 1  mathbfa  c \nmathbf0  I_n  mathbfb \n0  mathbf0  1 endbmatrixright) =\nbeginbmatrix 0  mathbfa  c - mathbfamathbfb2 \nmathbf0  0_n  mathbfb \n0  mathbf0  0 endbmatrix\n\nwhere I_n is the nn identity matrix, 0_n is the nn zero matrix and mathbfamathbfb is dot product of vectors.\n\n\n\n\n\n","category":"method"},{"location":"groups/heisenberg_group/#ManifoldsBase.injectivity_radius-Tuple{HeisenbergGroup}","page":"Heisenberg","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(G::HeisenbergGroup)\n\nReturn the injectivity radius on the HeisenbergGroup G, which is .\n\n\n\n\n\n","category":"method"},{"location":"groups/product_group/#The-product-Lie-group","page":"Product group","title":"The product Lie group","text":"","category":"section"},{"location":"groups/product_group/","page":"Product group","title":"Product group","text":"Modules = [LieGroups]\nPages = [\"groups/product_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"groups/product_group/#LieGroups.ProductGroupOperation","page":"Product group","title":"LieGroups.ProductGroupOperation","text":"ProductGroupOperation{O<:<:NTuple{N,AbstractGroupOperation} where N} <: AbstractGroupOperation\n\nA struct do model a tuple of group operations, one for each factor of a product group, that together forms a new group operation.\n\nConstructor\n\nProductGroupOperation(o::AbstractGroupOperation...)\n√ó(o::AbstractGroupOperation...) = ProductGroupOperation(o...)\n\n\n\n\n\n","category":"type"},{"location":"groups/product_group/#LieGroups.ProductLieGroup-Tuple{LieGroup, LieGroup}","page":"Product group","title":"LieGroups.ProductLieGroup","text":"ProductLieGroup(G, H, ...)\n\nReturn the LieGroup of the product of Lie groups G and H.\n\nAlternatively, the short hand G √ó H can be used.\n\n\n\n\n\n","category":"method"},{"location":"groups/product_group/#LinearAlgebra.cross-Tuple{Vararg{AbstractGroupOperation}}","page":"Product group","title":"LinearAlgebra.cross","text":"cross(O1::AbstractGroupOperation, O2::AbstractGroupOperation)\nO1 √ó O2\nO1 √ó O2 √ó O3 √ó ...\n\nReturn the ProductGroupOperation For two AbstractGroupOperation` O1 and O2, where for the case that one of them is a ProductGroupOperation itself, the other is either prepended (if O1 is a product) or appended (if O2 is). If both are product operations, they are combined into one, keeping the order of operations.\n\nFor the case that more than two are concatenated with √ó this is iterated.\n\n\n\n\n\n","category":"method"},{"location":"groups/product_group/#LinearAlgebra.cross-Tuple{Vararg{LieGroup}}","page":"Product group","title":"LinearAlgebra.cross","text":"cross(G::LieGroup, H::LieGroup)\nG √ó H\nG1 √ó G2 √ó G3 √ó ...\n\nReturn the ProductLieGroup For two LieGroups G and H, where for the case that one of them is a ProductLieGroup itself, the other is either prepended (if H is a product) or appended (if G is). If both are product Lie groups, they are combined into one, keeping the order of operations.\n\nFor the case that more than two are concatenated with √ó this is iterated.\n\n\n\n\n\n","category":"method"},{"location":"#LieGroups.jl","page":"Home","title":"LieGroups.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the Documentation of LieGroups.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = LieGroups","category":"page"},{"location":"","page":"Home","title":"Home","text":"LieGroups.LieGroups","category":"page"},{"location":"#LieGroups.LieGroups","page":"Home","title":"LieGroups.LieGroups","text":"LieGroups.jl: Lie groups and Lie algebras in Julia.\n\nThe package is named after the norwegian mathematician Sophus Lie.\n\nüìö Documentation: manoptjl.org\nüì¶ Repository: github.com/JuliaManifolds/LieGroups.jl\nüí¨ Discussions: github.com/JuliaManifolds/LieGroups.jl/discussions\nüéØ Issues: github.com/JuliaManifolds/LieGroups.jl/issues\n\n\n\n\n\n","category":"module"},{"location":"tutorials/transition/#Transition-from-GroupManifolds-in-Manifolds.jl","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds in Manifolds.jl","text":"","category":"section"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"One predecessor of LieGroups.jl are the GroupManifolds in Manifolds.jl. While this package provides the same features, one reason for a new package is, that a ‚Äúrestart‚Äù offers the opportunity to put the main focus for the functions in this package really on Lie groups.","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"This tutorial provides an overview of the necessary changes to your code if you based it on the predecessor.","category":"page"},{"location":"tutorials/transition/#Table-of-function-names-and-its-successors","page":"Transition from GroupManifolds","title":"Table of function names and its successors","text":"","category":"section"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"The following table lists all functions related to GroupManifolds and their new names or replacements here in LieGroups.jl. In this code G always refers to the GroupManifold in the first column and the LieGroup in the second. Lie group elements (points) are always g,h, Lie algebra elements (vectors) always X, Y.","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"New functions and types in this package are only mentioned, if they are worth a comment and if something changed.","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"The list is alphabetical, but first lists types, then functions","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"Manifolds.jl LieGroups.jl Comment\nAdditionOperation AdditionGroupOperation \nLeftForwardAction LeftGroupOperationAction \nRightBackwardAction RightGroupOperationAction \nLeftBackwardAction InverseRightGroupOperationAction note that this is now also aa AbstractLeftGroupActionType\n LieAlgebra(G) new alias to emphasize its manifold- and vector structure as well as for a few dispatch methods.\nGroupManifold(M, op) LieGroup(M, op) \nPowerGroup(M) PowerLieGroup(G,n) The main change is, that the constructor now requires a Lie group to build the power Lie group; This also allows for G^n. The other two former constructors for nested and nested-replacing are no longer necessary. PowerLieGroup behaves exactly the same as PowerManifold.\nProductGroup(M) ProductLieGroup(G, H) The main change is, that the constructor now requires two Lie groups to build their product. This also allows for the short hand G√óH to generate this product.\nSemidirectProductGroup(G, H, a) LeftSemidirectProductLieGroup(G, H, a) While this staid the same, there is now also the default_left_action(G,H). When this agrees with a you can use the short hand G‚ãâH to generate this semidirect product. Analogously there now also exists the RightSemidirectProductLieGroup(G,H) withdefault_left_action(G,H) that allows for the short cut G‚ãäH\nRightForwardAction InverseLeftGroupOperationAction note that this is an AbstractRightGroupActionType\nadjoint adjoint now implemented with a default, when you provide diff_conjugate!.\napply_diff diff_apply modifiers (diff) come first, consistent with ManifoldsDiff.jl\napply_diff_group diff_group_apply modifiers (diff/group) come first, consistent with ManifoldsDiff.jl\n conjugate, diff_conjugate a new function to model c_g mathcal G  mathcal G given by c_g(h) = ghg^-1\nexp(G, g, X) exp(base_manifold(G), g, X) the previous defaults whenever not agreeing with the invariant one can now be accessed on the internal manifold\nexp_inv(G, g, X) exp(G, g, X) the exponential map invariant to the group operation is the default on Lie groups here\nexp_lie(G, X) exp(G,Identity(G), X) the (matrix) exponential is now the one at the Identity(G), since there it agrees with the invariant one\ninverse_translate(G, g, h, c) inv_left_compose(G, g, h), inv_right_compose(G, g, h) compute g^-1h and gh^-1, resp.\ninverse_tranlsate_diff(G, g, h, X, LeftForwardAction()) - discontinued, use diff_left_compose(G, inv(G,g), h)\ninverse_tranlsate_diff(G, g, h, X, RightBackwardAction()) - discontinued, use diff_left_compose(G, h, inv(G,g))\nlog(G, g, h) log(base_manifold(G), g, h) you can now access the previous defaults on the internal manifold whenever they do not agree with the invariant one\nlog_inv(G, g, h) log(G, g, h) the logarithmic map invariant to the group operation is the default on Lie groups here\nlog_lie(G, g) log(G,Identity(G), g) the (matrix) logarithm is now the one at the identity, since there it agrees with the invariant one\nswitch_direction(A) inv(A) switches from an action to its inverse action (formerly the direction forward/backward, sometimes even left/right, do not confuse with the side left/right).\nswitch_side(A) switch(A) switches from a left action to its corresponding right action.\ntranslate(G, g, h) compose(G, g, h) unified to compose\ntranslate_diff(G, g, X, c) diff_left_compose(G, g, h, X), diff_right_compose(G, g, h, X) for compose gh the functions now specify whether the derivative is taken w.r.t. to the left (g) or right (h) argument\nVeeOrthogonalBasis LieAlgebraOrthogonalBasis ","category":"page"},{"location":"tutorials/transition/#Further-notable-changes","page":"Transition from GroupManifolds","title":"Further notable changes","text":"","category":"section"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"The GeneralLinearGroup (formerly GeneralLinear) switched to using its Lie algebra to represent tangent vectors.\nFormerly, both a power of LieGroups as well as a LieGroup on the power manifold was possible. This is now unified to the latter,","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"the operation for power manifolds can hence stay the same as for the single manifold.","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"Formerly, product manifolds were stored as a ProductManifold of Lie groups and an indicator for the group operation, that the direct product should be used. This is switched to (as for the last point) internally only store a ProductManifold as well as a (new) ProductGroupOperation that specifies one group operation for every factor.\nboth the last two points achieve one unified modelling aspect of Lie groups: They are now always a Riemannian manifold M together with a group operation op,","category":"page"},{"location":"tutorials/transition/","page":"Transition from GroupManifolds","title":"Transition from GroupManifolds","text":"but a Lie group does not store another Lie group (or product of them) internally.","category":"page"},{"location":"notation/#Notation-on-Lie-groups","page":"Notation","title":"Notation on Lie groups","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"In this package,the notation introduced in Manifolds.jl Notation is used with the following additional parts.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Symbol Description Also used Comment\n a group operation  \nc_gmathcal G  mathcal G the conjugation map (with g)  \nmathrme identity element of a group  \ng h k elements on a (Lie) group. Sometimes called points. g_1 g_2  \nmathfrak g a Lie algebra  \nmathcalG a (Lie) group  \nŒª_g mathcal G  mathcal G the left group operation map Œª_g(h) = gh  \nœÅ_g mathcal G  mathcal G the right group operation map œÅ_g(h) = hg  \nœÉ mathcal G  mathcal M a left group action  œÉ_g(p) to emphasize a fixed group element\nœÑ mathcal M  mathcal G a right group action œÉ_mathrmR œÑ_g(p) to emphasize a fixed group element","category":"page"}]
}
